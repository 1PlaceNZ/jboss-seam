<chapter id="remoting">
    <title>Remoting</title>
    <para>
        Seam provides a convenient method of remotely accessing components from a web page, using
        AJAX (Asynchronous Javascript and XML). The framework for this functionality is provided 
        with almost no up-front development effort - your components only require simple annotating
        to become accessible via AJAX.  This chapter describes the steps required to build an 
        AJAX-enabled web page, then goes on to explain the features of the Seam Remoting framework in
        more detail.
    </para>

    <sect1>
        <title>Configuration</title>
        <para>
            To use remoting, the Seam Remoting servlet must first be configured in your
            <literal>web.xml</literal> file:
        </para>

        <programlisting>
          <![CDATA[
  <servlet>
    <servlet-name>Seam Remoting</servlet-name>
    <servlet-class>org.jboss.seam.remoting.SeamRemotingServlet</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>Seam Remoting</servlet-name>
    <url-pattern>/seam/remoting/*</url-pattern>
  </servlet-mapping>
        ]]>
        </programlisting>

        <para>
          The next step is to import the necessary Javascript into your web page.  There are a minimum
          of two scripts that must be imported.  The first one contains all the client-side framework
          code that enables remoting functionality:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/resource/remote.js">
    <!--
    // This space intentionally left blank
    //-->
  </script>
            ]]>
        </programlisting>

        <para>
          The second script contains the stubs and type definitions for the components you wish to call.
          It is generated dynamically based on the local interface of your components, and includes 
          type definitions for all of the classes that can be used to call the remotable methods of the interface.
          The name of the script reflects the name of your component. For example, if you have a stateless
          session bean annotated with <literal>@Name("customerAction")</literal>, then your script tag 
          should look like this:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
        </programlisting>
        
        <para>
          If you wish to access more than one component from the same page, then include them all as parameters of your script tag:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction&accountAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
        </programlisting>

    </sect1>

    <sect1>
      <title>The "Seam" object</title>

      <para>
        Client-side interaction with your components is all performed via the <literal>Seam</literal> 
        Javascript object. This object is defined in <literal>remote.js</literal>, and you'll be using it to
        make asynchronous calls against your component.  It is split into two areas of functionality; 
        <literal>Seam.Component</literal> contains methods for working with components and 
        <literal>Seam.Remoting</literal> contains methods for
        executing remote requests.  The easiest way to become familiar with this object is to start with a 
        simple example.
      </para>

      <sect2>
        <title>A Hello World example</title>

        <para>
          Let's step through a simple example to see how the <literal>Seam</literal> object works.
          First of all, let's create a new Seam component called <literal>helloAction</literal>.
        </para>

        <programlisting>
          <![CDATA[
  @Stateless
  @Name("helloAction")
  @Scope(SESSION)
  public class HelloAction implements HelloLocal {
    public String sayHello(String name) {
      return "Hello, " + name;
    }
  }
          ]]>
        </programlisting>

        <para>You also need to create a local interface for our new component - take special note of the 
        <literal>@WebRemote</literal> annotation, as it's required to make our method accessible via remoting:</para>

        <programlisting>
          <![CDATA[
  @Local
  public interface HelloLocal {
    @WebRemote
    public String sayHello(String name);
  }
          ]]>
        </programlisting>

        <para>
          That's all the server-side code we need to write.  Now for our web page - create a new page and
          import the following scripts:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/resource/remote.js">
    <!--
    // This space intentionally left blank
    //-->
  </script>

  <script type="text/javascript" src="seam/remoting/interface.js?helloAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
          ]]>
        </programlisting>

        <para>
          To make this a fully interactive user experience, let's add a button to our page:
        </para>

        <programlisting>
          <![CDATA[
  <button onclick="javascript:sayHello()">Say Hello</button>
          ]]>
        </programlisting>

        <para>
          We'll also need to add some more script to make our button actually do something when it's clicked:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript">
    //<![CDATA[

    function sayHello() {
      var name = prompt("What is your name?");
      Seam.Component.getInstance("helloAction").sayHello(name, sayHelloCallback);
    }

    function sayHelloCallback(result) {
      alert(result);
    }

    // ]]>]]&gt;<![CDATA[
  </script>
          ]]>
        </programlisting>

        <para>
          We're done!  Deploy your application and browse to your page.  Click the button, and enter
          a name when prompted.  A message box will display the hello message confirming that the call
          was successful.  If you want to save some time, you'll find the full source code for this
          Hello World example in Seam's <literal>/examples/remoting/helloworld</literal> directory.
        </para>
        
        <para>
          So what does the code of our script actually do?  Let's break it down into smaller pieces.  To start with,
          you can see from the Javascript code listing that we have implemented two methods - the first method is
          responsible for prompting the user for their name and then making a remote request.  Take a look at the
          following line:
        </para>
        
        <programlisting>
  Seam.Component.getInstance("helloAction").sayHello(name, sayHelloCallback);
        </programlisting>
        
        <para>
          The first section of this line, <literal>Seam.Component.getInstance("helloAction")</literal> returns a
          proxy, or "stub" for our <literal>helloAction</literal> component.  We can invoke the methods of our
          component against this stub, which is exactly what happens with the remainder of the line:
          <literal>sayHello(name, sayHelloCallback);</literal>.
        </para>
        
        <para>
          What this line of code in its completeness does, is invoke the <literal>sayHello</literal> method of our 
          component, passing in <literal>name</literal> as a parameter.  The second parameter, 
          <literal>sayHelloCallback</literal> isn't a parameter of our component's <literal>sayHello</literal> 
          method, instead it tells the Seam Remoting framework that once it receives the response to our request, 
          it should pass it to the <literal>sayHelloCallback</literal> Javascript method.  This callback parameter
          is entirely optional, so feel free to leave it out if you're calling a method with a <literal>void</literal>
          return type or if you don't care about the result.
        </para>
        
        <para>
          The <literal>sayHelloCallback</literal> method, once receiving the response to our remote request
          then pops up an alert message displaying the result of our method call.
        </para>

      </sect2>
      
      <sect2>
        <title>Seam.Component</title>
        
        <para>
          The <literal>Seam.Component</literal> Javascript object provides a number of client-side methods for working with 
          your Seam components.  The two main methods, <literal>newInstance()</literal> and <literal>getInstance()</literal>
          are documented in the following sections however their main difference is that <literal>newInstance()</literal>
          will always create a new instance of a component type, and <literal>getInstance()</literal> will return a
          singleton instance.
        </para>
        
        <sect3>
          <title>Seam.Component.newInstance()</title>
          <para>
            Use this method to create a new instance of an entity or Javabean component.  The object returned
            by this method will have the same getter/setter methods as its server-side counterpart, or 
            alternatively if you wish you can access its fields directly. 
            Take the following Seam entity component for example:
          </para>
          
          <programlisting>
  @Name("customer")
  @Entity
  public class Customer implements Serializable
  {
    private Integer customerId;
    private String firstName;
    private String lastName;
    
    @Column public Integer getCustomerId() { 
      return customerId; 
    }
    
    public void setCustomerId(Integer customerId} { 
      this.customerId = customerId; 
    }
    
    @Column public String getFirstName() { 
      return firstName; 
    }
    
    public void setFirstName(String firstName) {
      this.firstName = firstName; 
    }
    
    @Column public String getLastName() {
      return lastName;
    }
    
    public void setLastName(String lastName) {
      this.lastName = lastName;
    }
  }
          </programlisting>
          
          <para>
            To create a client-side Customer you would write the following code:
          </para>
          
          <programlisting>
  var customer = Seam.Component.newInstance("customer");
          </programlisting>
          
          <para>
            Then from here you can set the fields of the customer object:
          </para>
          
          <programlisting>
  customer.setFirstName("John");
  // Or you can set the fields directly
  customer.lastName = "Smith";
          </programlisting>                  

        </sect3>
      
        <sect3>
          <title>Seam.Component.getInstance()</title>
          
          <para>
            The <literal>getInstance()</literal> method is used to get a reference to a Seam session 
            bean component stub, which can then be used to remotely execute methods against your
            component.  This method returns a singleton for the specified component, so calling it twice
            in a row with the same component name will return the same instance of the component.
          </para>
          
          <para>
            To continue our example from before, if we have created a new <literal>customer</literal> and 
            we now wish to save it, we would pass it to the <literal>saveCustomer()</literal> method of our
            <literal>customerAction</literal> component:
          </para>          
          
          <programlisting>
  Seam.Component.getInstance("customerAction").saveCustomer(customer);          
          </programlisting>
        </sect3>
        
        <sect3>
          <title>Seam.Component.getComponentName()</title>
          
          <para>
            Passing an object into this method will return its component name if it is a component, or 
            <literal>null</literal> if it is not.
          </para>
          
          <programlisting>
  if (Seam.Component.getComponentName(instance) == "customer")
    alert("Customer");
  else if (Seam.Component.getComponentName(instance) == "staff")
    alert("Staff member");          
          </programlisting>
        </sect3>
      
      </sect2>
      
      <sect2>
        <title>Seam.Remoting</title>

        <para>
          Most of the client side functionality for Seam Remoting is contained within the <literal>Seam.Remoting</literal>
          object.  While you shouldn't need to directly call most of its methods, there are a couple of important ones
          worth mentioning.
        </para>          
        
        <sect3>
          <title>Seam.Remoting.createType()</title>
          
          <para>
            If your application contains or uses Javabean classes that aren't Seam components, you may need to create these
            types on the client side to pass as parameters into your component method.  Use the <literal>createType()</literal>
            method to create an instance of your type.  Pass in the fully qualified Java class name as a parameter:
          </para>
          
          <programlisting>
  var widget = Seam.Remoting.createType("com.acme.widgets.MyWidget");          
          </programlisting>
        </sect3>
        
        <sect3>
          <title>Seam.Remoting.getTypeName()</title>
          
          <para>
            This method is the equivalent of <literal>Seam.Component.getComponentName()</literal> but for non-component types.
            It will return the name of the type for an object instance, or <literal>null</literal> if the type is not
            known.  The name is the fully qualified name of the type's Java class.
          </para>
        </sect3>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Client Interfaces</title>
      
      <para>
        In the configuration section above, the interface, or "stub" for our component is imported into our
        page via <literal>seam/remoting/interface.js</literal>:
      </para>
        
      <programlisting>
        <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
      </programlisting>
      
      <para>
        By including this script in our page, the interface definitions for our component, plus any other
        components or types that are required to execute the methods of our component are generated and 
        made available for the remoting framework to use.
      </para>
      
      <para>
        There are two types of client stub that can be generated, "executable" stubs and "type" stubs. 
        Executable stubs are behavioural, and are used to execute methods against your session bean components, 
        while type stubs contain state and represent the types that can be passed in as parameters or returned 
        as a result.
      </para>
      
      <para>
        The type of client stub that is generated depends on the type of your Seam component. If the component is 
        a session bean, then an executable stub will be generated, otherwise if it's an entity or JavaBean, then 
        a type stub will be generated. There is one exception to this rule; if your component is a JavaBean (ie it
        is not a session bean nor an entity bean) and any of its methods are annotated with @WebRemote, then
        an executable stub will be generated for it instead of a type stub.  This allows you to use remoting to
        call methods of your JavaBean components in a non-EJB environment where you don't have access to session beans.
      </para>
      
    </sect1>
    
    <sect1>
      <title>The Context</title>
      
      <para>
        The Seam Remoting Context contains additional information which is sent and received as part of a remoting
        request/response cycle.  At this stage it only contains the conversation ID but may be expanded in the future.       
      </para>
      
      <sect2>
        <title>Setting and reading the Conversation ID</title>
      </sect2>
      
      <para>
        If you intend on using remote calls within the scope of a conversation then you need to be able to read or 
        set the conversation ID in the Seam Remoting Context.  To read the conversation ID after making a remote request
        call <literal>Seam.Remoting.getContext().getConversationId()</literal>.  To set the conversation ID before
        making a request, call <literal>Seam.Remoting.getContext().setConversationId()</literal>.
      </para>
      
      <para>
        If the conversation ID hasn't been explicitly set with <literal>Seam.Remoting.getContext().setConversationId()</literal>,
        then it will be automatically assigned the first valid conversation ID that is returned by any remoting call.
        If you are working with multiple conversations within your page, then you may need to explicitly set the conversation ID
        before each call.  If you are working with just a single conversation, then you don't need to do anything special.
      </para>
    </sect1>
    
    <sect1>
      <title>Batch Requests</title>
      
      <para>
        Seam Remoting allows multiple component calls to be executed within a single request. It is recommended that
        this feature is used wherever it is appropriate to reduce network traffic.
      </para>
      
      <para>
        The method <literal>Seam.Remoting.startBatch()</literal> will start a new batch, and any component calls 
        executed after starting a batch are queued, rather than being sent immediately.  When all the desired component 
        calls have been added to the batch, the <literal>Seam.Remoting.executeBatch()</literal> method will send a
        single request containing all of the queued calls to the server, where they will be executed in order.  After the
        calls have been executed, a single response containining all return values will be returned to the client and
        the callback functions (if provided) triggered in the same order as execution.
      </para>
      
      <para>
        If you start a new batch via the <literal>startBatch()</literal> method but then decide you don't want to 
        send it, the <literal>Seam.Remoting.cancelBatch()</literal> method will discard any calls that were queued 
        and exit the batch mode.
      </para>
      
      <para>
        To see an example of a batch being used, take a look at <literal>/examples/remoting/chatroom</literal>.
      </para>
    </sect1>
    
    <sect1>
      <title>Working with Data types</title>
      
      <sect2>
        <title>Primitives / Basic Types</title>
        
        <para>
          This section describes the support for basic data types.  On the server side these values
          are generally compatible with either their primitive type or their corresponding wrapper class.
        </para>
        
        <sect3>
          <title>String</title>
          
          <para>
            Simply use Javascript String objects when setting String parameter values.
          </para>
        </sect3>
        
        <sect3>
          <title>Number</title>
          
          <para>
            There is support for all number types supported by Java.  On the client side, number values
            are always serialized as their String representation and then on the server side they are 
            converted to the correct destination type.  Conversion into either a primitive or wrapper 
            type is supported for <literal>Byte</literal>, <literal>Double</literal>, 
            <literal>Float</literal>, <literal>Integer</literal>, <literal>Long</literal> and 
            <literal>Short</literal> types.            
          </para>          
        </sect3>
        
        <sect3>
          <title>Boolean</title>
          
          <para>
            Booleans are represented client side by Javascript Boolean values, and server side by
            a Java boolean.
          </para>          
        </sect3>
      </sect2>
      
      <sect2>
        <title>JavaBeans</title>
        
        <para>
          In general these will be either Seam entity or JavaBean components, or some other non-component class. Use
          the appropriate method (either <literal>Seam.Component.newInstance()</literal> for Seam components or 
          <literal>Seam.Remoting.createType()</literal> for everything else) to create a new instance of the object.          
        </para>
        
        <para>
          It is important to note that only objects that are created by either of these two methods should be used
          as parameter values, where the parameter is not one of the other valid types mentioned anywhere else in 
          this section.  In some situations you may have a component method where the exact parameter type cannot 
          be determined, such as:
        </para>
        
        <programlisting>
  @Name("myAction")
  public class MyAction implements MyActionLocal {
    public void doSomethingWithObject(Object obj) {
      // code
    }
  }        
        </programlisting>
        
        <para>
          In this case you might want to pass in an instance of your <literal>myWidget</literal> component, however the
          interface for <literal>myAction</literal> won't include <literal>myWidget</literal> as it is not 
          directly referenced by any of its methods.  To get around this, <literal>MyWidget</literal> needs to 
          be explicitly imported:
        </para>
        
        <programlisting>
          <![CDATA[        
  <script type="text/javascript" src="seam/remoting/interface.js?myAction&myWidget">
    <!--
    // This space intentionally left blank
    //-->
  </script>        
          ]]>
        </programlisting>
        
        <para>
          This will then allow a <literal>myWidget</literal> object to be created with 
          <literal>Seam.Component.newInstance("myWidget")</literal>, which can then be passed to 
          <literal>myAction.doSomethingWithObject()</literal>.
        </para>
        
      </sect2>
      
      <sect2>
        <title>Dates and Times</title>
        
        <para>
          Date values are serialized into a String representation that is accurate to the millisecond.
          On the client side, use a Javascript Date object to work with date values. On the server side,
          use any <literal>java.util.Date</literal> (or descendent, such as <literal>java.sql.Date</literal>
          or <literal>java.sql.Timestamp</literal> class.
        </para>        
      </sect2>
      
      <sect2>
        <title>Enums</title>
        
        <para>
          On the client side, enums are treated the same as Strings.  When setting the value for an enum parameter,
          simply use the String representation of the enum. Take the following component as an example:
        </para>
        
        <programlisting>
  @Name("paintAction")
  public class paintAction implements paintLocal {
    public enum Color {red, green, blue, yellow, orange, purple};

    public void paint(Color color) {
      // code
    }    
  }            
        </programlisting>
        
        <para>
          To call the <literal>paint()</literal> method with the color <literal>red</literal>, pass the parameter
          value as a String literal:          
        </para>
        
        <programlisting>
  Seam.Component.getInstance("paintAction").paint("red");
        </programlisting>
        
        <para>
          The inverse is also true - that is, if a component method returns an enum parameter (or contains an enum
          field anywhere in the returned object graph) then on the client-side it will be represented as a String.
        </para>
      </sect2>
      
      <sect2>
        <title>Collections</title>
        
        <sect3>
          <title>Bags</title>
          
          <para>
            Bags cover all collection types including arrays, collections, lists, sets, (but excluding Maps - see the 
            next section for those), 
            and are implemented client-side as a Javascript array. When calling a component method that accepts one of 
            these types as a parameter, your parameter should be a Javascript array.  If a component method
            returns one of these types, then the return value will also be a Javascript array.  The remoting
            framework is clever enough on the server side to convert the bag to an appropriate type for
            the component method call.
          </para>
        </sect3>
        
        <sect3>
          <title>Maps</title>
          
          <para>
            As there is no native support for Maps within Javascript, a simple Map implementation is provided with
            the Seam Remoting framework.  To create a Map which can be used as a parameter to a remote call,
            create a new <literal>Seam.Remoting.Map</literal> object:
          </para>
          
          <programlisting>
  var map = new Seam.Remoting.Map();          
          </programlisting>
          
          <para>
            This Javascript implementation provides basic methods for working with Maps:
            <literal>size()</literal>, <literal>isEmpty()</literal>, <literal>keySet()</literal>,
            <literal>values()</literal>, <literal>get(key)</literal>, <literal>put(key, value)</literal>,
            <literal>remove(key)</literal> and <literal>contains(key)</literal>.  Each of these methods are
            equivalent to their Java counterpart.  Where the method returns a collection, such as 
            <literal>keySet()</literal> and <literal>values()</literal>, a Javascript Array object will be 
            returned that contains the key or value objects (respectively).
          </para>
        </sect3>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Debugging</title>
      
      <para>
         To aid in tracking down bugs, it is possible to enable a debug mode which will display the
         contents of all the packets send back and forth between the client and server in a popup window.
         To enable debug mode, execute the <literal>setDebug()</literal> method:
      </para>
      
      <programlisting>
  Seam.Remoting.setDebug(true);      
      </programlisting>
      
      <para>
        To turn off debugging, call <literal>setDebug(false)</literal>.  If you want to write your own
        messages to the debug log, call <literal>Seam.Remoting.log(message)</literal>.
      </para>
    </sect1>
    
    <sect1>
      <title>The Loading Message</title>

      <para>
       The default loading message that appears in the top right corner of the screen can be
       modified, its rendering customised or even turned off completely.
      </para>      
      
      <sect2>
        <title>Changing the message</title>
        
        <para>
          To change the message from the default "Please Wait..." to something different, set the
          value of <literal>Seam.Remoting.loadingMessage</literal>:
        </para>
        
        <programlisting>
  Seam.Remoting.loadingMessage = "Loading...";        
        </programlisting>
      </sect2>
      
      <sect2>
        <title>Hiding the loading message</title>
        
        <para>
          To completely suppress the display of the loading message, override the implementation
          of <literal>displayLoadingMessage()</literal> and <literal>hideLoadingMessage()</literal> with
          functions that instead do nothing:
        </para>
        
        <programlisting>
  // don't display the loading indicator
  Seam.Remoting.displayLoadingMessage = function() {};
  Seam.Remoting.hideLoadingMessage = function() {};        
        </programlisting>
      </sect2>
      
      <sect2>
        <title>A Custom Loading Indicator</title>
        
        <para>
          It is also possible to override the loading indicator to display an animated icon, or anything
          else that you want.  To do this override the <literal>displayLoadingMessage()</literal> and
          <literal>hideLoadingMessage()</literal> messages with your own implementation:
        </para>
        
        <programlisting>

  Seam.Remoting.displayLoadingMessage = function() {
    // Write code here to display the indicator
  };
  
  Seam.Remoting.hideLoadingMessage = function() {
    // Write code here to hide the indicator
  };                
        </programlisting>
      </sect2>
    </sect1>
    
    <sect1>
      <title>JMS Messaging</title>
      
      <para>
        Seam Remoting provides experimental support for JMS Messaging.  This section describes the JMS support
        that is currently implemented, but please note that this may change in the future.  It is currently not
        recommended that this feature is used within a production environment.
      </para>
      
      <sect2>
        <title>Subscribing to a JMS Topic</title>
        
        <para>
          The following example demonstrates how to subscribe to a JMS Topic:
        </para>
        
        <programlisting>
        
  function subscriptionCallback(message)
  {
    if (message instanceof Seam.Remoting.TextMessage)
      alert("Received message: " + message.getText());
  }        
        
  Seam.Remoting.subscribe("topicName", subscriptionCallback);        
        
        </programlisting>
        
        <para>
          The <literal>Seam.Remoting.subscribe()</literal> method accepts two parameters, the first being the name
          of the JMS Topic to subscribe to, the second being the callback function to invoke when a message is
          received.
        </para>
        
        <para>
          There are two types of messages supported, Text messages and Object messages. If you need to test for the
          type of message that is passed to your callback function you can use the <literal>instanceof</literal>
          operator to test whether the message is a <literal>Seam.Remoting.TextMessage</literal> or
          <literal>Seam.Remoting.ObjectMessage</literal>.  A <literal>TextMessage</literal> contains the text value 
          in its <literal>text</literal> field (or alternatively call <literal>getText()</literal> on it), while an
          <literal>ObjectMessage</literal> contains its object value in its <literal>object</literal> field (or call
          its <literal>getObject()</literal> method).
        </para>
      </sect2>
      
      <sect2>
        <title>Unsubscribing from a Topic</title>
        
        <para>
          To unsubscribe from a topic, call <literal>Seam.Remoting.unsubscribe()</literal> and pass in the topic name:
        </para>
        
        <programlisting>
  Seam.Remoting.unsubscribe("topicName");        
        </programlisting>
      </sect2>
      
      <sect2>
        <title>Tuning the Polling Process</title>
        
        <para>
          There are two parameters which you can modify to control how polling occurs.  The first one is
          <literal>Seam.Remoting.pollInterval</literal>, which controls how long to wait between subsequent
          polls for new messages.  This parameter is expressed in seconds, and its default setting is 10.
        </para>
        
        <para>
          The second parameter is <literal>Seam.Remoting.pollTimeout</literal>, and is also expressed as seconds.
          It controls how long a request to the server should wait for a new message before timing out and sending
          an empty response.  Its default is 0 seconds, which means that when the server is polled, if there are no
          messages ready for delivery then an empty response will be immediately returned.          
        </para>
        
        <para>
          The following example demonstrates how to configure the polling to occur much more aggressively.  You should
          set these parameters to suitable values for your application:
        </para>
        
        <programlisting>
  // Only wait 1 second between receiving a poll response and sending the next poll request.
  Seam.Remoting.pollInterval = 1;
  
  // Wait up to 5 seconds on the server for new messages
  Seam.Remoting.pollTimeout = 5;   
        </programlisting>
      </sect2>
      
    </sect1>

</chapter>
