<chapter id="remoting">
    <title>Remoting</title>
    <para>
        Seam provides a convenient method of remotely accessing components from a web page, using
        AJAX (Asynchronous Javascript and XML). The framework for this functionality is provided 
        with almost no up-front development effort - your components only require simple annotating
        to become accessible via AJAX.  This chapter describes the steps required to build an 
        AJAX-enabled web page, then goes on to explain the features of the Seam Remoting framework in
        more detail.
    </para>

    <sect1>
        <title>Configuration</title>
        <para>
            To use remoting, the Seam Remoting servlet must first be configured in your
            <literal>web.xml</literal> file:
        </para>

        <programlisting>
          <![CDATA[
  <servlet>
    <servlet-name>Seam Remoting</servlet-name>
    <servlet-class>org.jboss.seam.remoting.SeamRemotingServlet</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>Seam Remoting</servlet-name>
    <url-pattern>/seam/remoting/*</url-pattern>
  </servlet-mapping>
        ]]>
        </programlisting>

        <para>
          The next step is to import the necessary Javascript into your web page.  There are a minimum
          of two scripts that must be imported.  The first one contains all the client-side framework
          code that enables remoting functionality:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/resource/remote.js">
    <!--
    // This space intentionally left blank
    //-->
  </script>
            ]]>
        </programlisting>

        <para>
          The second script contains the stubs and type definitions for the components you wish to call.
          It is generated dynamically based on the local interface of your components, and includes 
          type definitions for all of the classes that can be used to call the remotable methods of the interface.
          The name of the script reflects the name of your component. For example, if you have a stateless
          session bean annotated with <literal>@Name("customerAction")</literal>, then your script tag 
          should look like this:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
        </programlisting>
        
        <para>
          If you wish to access more than one component from the same page, then include them all as parameters of your script tag:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction&accountAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
        </programlisting>

    </sect1>

    <sect1>
      <title>The "Seam" object</title>

      <para>
        Client-side interaction with your components is all performed via the <literal>Seam</literal> 
        Javascript object. This object is defined in <literal>remote.js</literal>, and you'll be using it to
        make asynchronous calls against your component.  It is split into two areas of functionality; 
        <literal>Seam.Component</literal> contains methods for working with components and 
        <literal>Seam.Remoting</literal> contains methods for
        executing remote requests.  The easiest way to become familiar with this object is to start with a 
        simple example.
      </para>

      <sect2>
        <title>A Hello World example</title>

        <para>
          Let's step through a simple example to see how the <literal>Seam</literal> object works.
          First of all, let's create a new Seam component called <literal>helloAction</literal>.
        </para>

        <programlisting>
          <![CDATA[
  @Stateless
  @Name("helloAction")
  @Scope(SESSION)
  public class HelloAction implements HelloLocal {
    public String sayHello(String name) {
      return "Hello, " + name;
    }
  }
          ]]>
        </programlisting>

        <para>You also need to create a local interface for our new component - take special note of the 
        <literal>@WebRemote</literal> annotation, as it's required to make our method accessible via remoting:</para>

        <programlisting>
          <![CDATA[
  @Local
  public interface HelloLocal {
    @WebRemote
    public String sayHello(String name);
  }
          ]]>
        </programlisting>

        <para>
          That's all the server-side code we need to write.  Now for our web page - create a new page and
          import the following scripts:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/resource/remote.js">
    <!--
    // This space intentionally left blank
    //-->
  </script>

  <script type="text/javascript" src="seam/remoting/interface.js?helloAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
          ]]>
        </programlisting>

        <para>
          To make this a fully interactive user experience, let's add a button to our page:
        </para>

        <programlisting>
          <![CDATA[
  <button onclick="javascript:sayHello()">Say Hello</button>
          ]]>
        </programlisting>

        <para>
          We'll also need to add some more script to make our button actually do something when it's clicked:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript">
    //<![CDATA[

    function sayHello() {
      var name = prompt("What is your name?");
      Seam.Component.getInstance("helloAction").sayHello(name, sayHelloCallback);
    }

    function sayHelloCallback(result) {
      alert(result);
    }

    // ]]>]]&gt;<![CDATA[
  </script>
          ]]>
        </programlisting>

        <para>
          We're done!  Deploy your application and browse to your page.  Click the button, and enter
          a name when prompted.  A message box will display the hello message confirming that the call
          was successful.  If you want to save some time, you'll find the full source code for this
          Hello World example in Seam's <literal>/examples/remoting/helloworld</literal> directory.
        </para>
        
        <para>
          So what does the code of our script actually do?  Let's break it down into smaller pieces.  To start with,
          you can see from the Javascript code listing that we have implemented two methods - the first method is
          responsible for prompting the user for their name and then making a remote request.  Take a look at the
          following line:
        </para>
        
        <programlisting>
  Seam.Component.getInstance("helloAction").sayHello(name, sayHelloCallback);
        </programlisting>
        
        <para>
          The first section of this line, <literal>Seam.Component.getInstance("helloAction")</literal> returns a
          proxy, or "stub" for our <literal>helloAction</literal> component.  We can invoke the methods of our
          component against this stub, which is exactly what happens with the remainder of the line:
          <literal>sayHello(name, sayHelloCallback);</literal>.
        </para>
        
        <para>
          What this line of code in its completeness does, is invoke the <literal>sayHello</literal> method of our 
          component, passing in <literal>name</literal> as a parameter.  The second parameter, 
          <literal>sayHelloCallback</literal> isn't a parameter of our component's <literal>sayHello</literal> 
          method, instead it tells the Seam Remoting framework that once it receives the response to our request, 
          it should pass it to the <literal>sayHelloCallback</literal> Javascript method.  This callback parameter
          is entirely optional, so feel free to leave it out if you're calling a method with a <literal>void</literal>
          return type or if you don't care about the result.
        </para>
        
        <para>
          The <literal>sayHelloCallback</literal> method, once receiving the response to our remote request
          then pops up an alert message displaying the result of our method call.
        </para>

      </sect2>
      
      <sect2>
        <title>Seam.Component</title>
        
        <para>
          The <literal>Seam.Component</literal> Javascript object provides a number of client-side methods for working with 
          your Seam components.
        </para>
        
        <sect3>
          <title>Seam.Component.newInstance()</title>
          <para>
            Use this method to create a new instance of an entity or Javabean component.  The object returned
            by this method will have the same getter/setter methods as its server-side counterpart, or 
            alternatively if you wish you can access its fields directly. 
            Take the following Seam entity component for example:
          </para>
          
          <programlisting>
  @Name("customer")
  @Entity
  public class Customer implements Serializable
  {
    private Integer customerId;
    private String firstName;
    private String lastName;
    
    @Column public Integer getCustomerId() { 
      return customerId; 
    }
    
    public void setCustomerId(Integer customerId} { 
      this.customerId = customerId; 
    }
    
    @Column public String getFirstName() { 
      return firstName; 
    }
    
    public void setFirstName(String firstName) {
      this.firstName = firstName; 
    }
    
    @Column public String getLastName() {
      return lastName;
    }
    
    public void setLastName(String lastName) {
      this.lastName = lastName;
    }
  }
          </programlisting>
          
          <para>
            To create a client-side Customer you would write the following code:
          </para>
          
          <programlisting>
  var customer = Seam.Component.newInstance("customer");
          </programlisting>
          
          <para>
            Then from here you can set the fields of the customer object:
          </para>
          
          <programlisting>
  customer.setFirstName("John");
  // Or you can set the fields directly
  customer.lastName = "Smith";
          </programlisting>                  

        </sect3>
      
        <sect3>
          <title>Seam.Component.getInstance()</title>
          
          <para>
            The <literal>getInstance()</literal> method is used to get a reference to a Seam session bean component stub.
            
          </para>
          
          <para>
           To Do.
          </para>          
        </sect3>
      
      </sect2>
      
      <sect2>
        <title>Seam.Remoting</title>

        <para>
         To Do
        </para>          
      </sect2>
    </sect1>
    
    <sect1>
      <title>Client Interfaces</title>
      
      <para>
        In the configuration section above, the interface, or "stub" for our component is imported into our
        page via <literal>seam/remoting/interface.js</literal>:
      </para>
        
      <programlisting>
        <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
      </programlisting>
      
      <para>
        By including this script in our page, the interface definitions for our component, plus any other
        components or types that are required to execute the methods of our component are generated and 
        made available for the remoting framework to use.
      </para>
      
      <para>
        There are two types of client stub that can be generated, "executable" stubs and "type" stubs. 
        Executable stubs are behavioural, and are used to execute methods against your session bean components, 
        while type stubs contain state and represent the types that can be passed in as parameters or returned 
        as a result.
      </para>
      
      <para>
        The type of client stub that is generated depends on the type of your Seam component. If the component is 
        a session bean, then an executable stub will be generated, otherwise if it's an entity or JavaBean, then 
        a type stub will be generated. There is one exception to this rule; if your component is a JavaBean (ie it
        is not a session bean nor an entity bean) and any of its methods are annotated with @WebRemote, then
        an executable stub will be generated for it instead of a type stub.  This allows you to use remoting to
        call methods of your JavaBean components in a non-EJB environment where you don't have access to session beans.
      </para>
      
    </sect1>
    
    <sect1>
      <title>The Context</title>
      
      <para>
        The Seam Remoting Context contains additional information which is sent and received as part of a remoting
        request/response cycle.  At this stage it only contains the conversation ID but may be expanded in the future.       
      </para>
      
      <sect2>
        <title>Setting and reading the Conversation ID</title>
      </sect2>
      
      <para>
        If you intend on using remote calls within the scope of a conversation then you need to be able to read or 
        set the conversation ID in the Seam Remoting Context.  To read the conversation ID after making a remote request
        call <literal>Seam.Remoting.getContext().getConversationId()</literal>.  To set the conversation ID before
        making a request, call <literal>Seam.Remoting.getContext().setConversationId()</literal>.
      </para>
    </sect1>
    
    <sect1>
      <title>Batch Requests</title>
      
      <para>
        Seam Remoting allows multiple component calls to be executed within a single request. It is recommended that
        this feature is used wherever it is appropriate to reduce network traffic.
      </para>
      
      <para>
        The method <literal>Seam.Remoting.startBatch()</literal> will start a new batch, and any component calls 
        executed after starting a batch are queued, rather than being sent immediately.  When all the desired component 
        calls have been added to the batch, the <literal>Seam.Remoting.executeBatch()</literal> method will send a
        single request containing all of the queued calls to the server, where they will be executed in order.  After the
        calls have been executed, a single response containining all return values will be returned to the client and
        the callback functions (if provided) triggered in the same order as execution.
      </para>
      
      <para>
        If you start a new batch via the <literal>startBatch()</literal> method but then decide you don't want to 
        send it, the <literal>Seam.Remoting.cancelBatch()</literal> method will discard any calls that were queued 
        and exit the batch mode.
      </para>
      
      <para>
        To see an example of a batch being used, take a look at <literal>/examples/remoting/chatroom</literal>.
      </para>
    </sect1>
    
    <sect1>
      <title>Working with Data types</title>
      
      <sect2>
        <title>Primitives</title>
        
        <sect3>
          <title>String</title>
          
          <para>
            Simply use Javascript String objects when setting String parameter values.
          </para>
        </sect3>
        
        <sect3>
          <title>Number</title>
          
          <para>
           To Do.
          </para>          
        </sect3>
        
        <sect3>
          <title>Boolean</title>
          
          <para>
           To Do.
          </para>          
        </sect3>
      </sect2>
      
      <sect2>
        <title>JavaBeans</title>
        
        <para>
          In general these will be either Seam entity or JavaBean components, or some other non-component class. Use
          the appropriate method (either <literal>Seam.Component.newInstance()</literal> for Seam components or 
          <literal>Seam.Remoting.createType()</literal> for everything else) to create a new instance of the object.          
        </para>
        
        <para>
          It is important to note that only objects that are created by either of these two methods should be used
          as parameter values, where the parameter is not one of the other valid types mentioned anywhere else in 
          this section.  In some situations you may have a component method where the exact parameter type cannot 
          be determined, such as:
        </para>
        
        <programlisting>
  @Name("myAction")
  public class MyAction implements MyActionLocal {
    public void doSomethingWithObject(Object obj) {
      // code
    }
  }        
        </programlisting>
        
        <para>
          In this case you might want to pass in an instance of your <literal>myWidget</literal> component, however the
          interface for <literal>myAction</literal> won't include <literal>myWidget</literal> as it is not 
          directly referenced by any of its methods.  To get around this, <literal>MyWidget</literal> needs to 
          be explicitly imported:
        </para>
        
        <programlisting>
          <![CDATA[        
  <script type="text/javascript" src="seam/remoting/interface.js?myAction&myWidget">
    <!--
    // This space intentionally left blank
    //-->
  </script>        
          ]]>
        </programlisting>
        
        <para>
          This will then allow a <literal>myWidget</literal> object to be created with 
          <literal>Seam.Component.newInstance("myWidget")</literal>, which can then be passed to 
          <literal>myAction.doSomethingWithObject()</literal>.
        </para>
        
      </sect2>
      
      <sect2>
        <title>Dates and Times</title>
        
        <para>
         To Do.
        </para>        
      </sect2>
      
      <sect2>
        <title>Enums</title>
        
        <para>
          On the client-side, enums are treated the same as Strings.  When setting the value for an enum parameter,
          simply use the String representation of the enum. Take the following component as an example:
        </para>
        
        <programlisting>
  @Name("paintAction")
  public class paintAction implements paintLocal {
    public enum Color {red, green, blue, yellow, orange, purple};

    public void paint(Color color) {
      // code
    }    
  }            
        </programlisting>
        
        <para>
          To call the <literal>paint()</literal> method with the color <literal>red</literal>, pass the parameter
          value as a String literal:          
        </para>
        
        <programlisting>
  Seam.Component.getInstance("paintAction").paint("red");
        </programlisting>
        
        <para>
          The inverse is also true - that is, if a component method returns an enum parameter (or contains an enum
          field anywhere in the returned object graph) then on the client-side it will be represented as a String.
        </para>
      </sect2>
      
      <sect2>
        <title>Collections</title>
        
        <sect3>
          <title>Bags</title>
          
          <para>
            Bags cover all collection types including arrays, collections, lists, sets, (but excluding Maps - see the 
            next section for those), 
            and are implemented client-side as a Javascript array. When calling a component method that accepts one of 
            these types as a parameter, your parameter should be a Javascript array.  If a component method
            returns one of these types, then the return value will also be a Javascript array.  The remoting
            framework is clever enough on the server side to convert the bag to an appropriate type for
            the component method call.
          </para>
        </sect3>
        
        <sect3>
          <title>Maps</title>
          
          <para>
            As there is no native support for Maps within Javascript, a simple Map implementation is provided with
            the Seam Remoting framework.  To create a Map which can be used as a parameter to a remote call,
            create a new <literal>Seam.Remoting.Map</literal> object as follows:
          </para>
          
          <programlisting>
  var map = new Seam.Remoting.Map();          
          </programlisting>
          
          <para>
            This Javascript implementation provides basic methods for working with Maps:
            <literal>size()</literal>, <literal>isEmpty()</literal>, <literal>keySet()</literal>,
            <literal>values()</literal>, <literal>get(key)</literal>, <literal>put(key, value)</literal>,
            <literal>remove(key)</literal> and <literal>contains(key)</literal>.  Each of these methods are
            equivalent to their Java counterpart.  Where the method returns a collection, such as 
            <literal>keySet()</literal> and <literal>values()</literal>, a Javascript Array object will be 
            returned that contains the key or value objects (respectively).
          </para>
        </sect3>
      </sect2>
    </sect1>
    
    <sect1>
      <title>Debugging</title>
      
      <para>
       To Do.
      </para>
    </sect1>
    
    <sect1>
      <title>The Loading Message</title>

      <para>
       To Do.
      </para>      
    </sect1>
    
    <sect1>
      <title>JMS Messaging</title>
      
      <para>
        Seam Remoting provides experimental support for JMS Messaging.  This section describes the JMS support
        that is currently implemented, but please note that this may change in the future.  It is currently not
        recommended to use this feature within a production environment.
      </para>
      
      <para>
       To Do.
      </para>      
      
    </sect1>

</chapter>
