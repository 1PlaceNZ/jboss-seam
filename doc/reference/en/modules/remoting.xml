<chapter id="remoting">
    <title>Remoting</title>
    <para>
        Seam provides a convenient method of remotely accessing components from a web page, using
        AJAX (Asynchronous Javascript and XML). The framework for this functionality is provided 
        with almost no up-front development effort - your components only require simple annotating
        to become accessible via AJAX.  This chapter describes the steps required to build an 
        AJAX-enabled web page.
    </para>

    <sect1>
        <title>Configuration</title>
        <para>
            To use remoting, the Seam Remoting servlet must first be configured in your
            <literal>web.xml</literal> file:
        </para>

        <programlisting>
          <![CDATA[
  <servlet>
    <servlet-name>Seam Remoting</servlet-name>
    <servlet-class>org.jboss.seam.remoting.SeamRemotingServlet</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>Seam Remoting</servlet-name>
    <url-pattern>/seam/remoting/*</url-pattern>
  </servlet-mapping>
        ]]>
        </programlisting>

        <para>
          The next step is to import the necessary Javascript into your web page.  There are a minimum
          of two scripts that must be imported.  The first one contains all the client-side framework
          code that enables remoting functionality:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/resource/remote.js">
    <!--
    // This space intentionally left blank
    //-->
  </script>
            ]]>
        </programlisting>

        <para>
          The second script contains the stubs and type definitions for the components you wish to call.
          It is generated dynamically based on the local interface of your components, and includes 
          type definitions for all of the classes that can be used to call the remotable methods of the interface.
          The name of the script reflects the name of your component. For example, if you have a stateless
          session bean annotated with <literal>@Name("customerAction")</literal>, then your script tag 
          should look like this:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
        </programlisting>
        
        <para>
          If you wish to access more than one component from the same page, then include them all as parameters of your script tag:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction&accountAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
        </programlisting>

    </sect1>

    <sect1>
      <title>The "Seam" object</title>

      <para>
        Client-side interaction with your components is all performed via the <literal>Seam</literal> 
        Javascript object. This object is defined in <literal>remote.js</literal>, and you'll be using it to
        make asynchronous calls against your component.  It is split into two areas of functionality; 
        <literal>Seam.Component</literal> contains methods for working with components and 
        <literal>Seam.Remoting</literal> contains methods for
        executing remote requests.  The easiest way to become familiar with this object is to start with a 
        simple example.
      </para>

      <sect2>
        <title>A Hello World example</title>

        <para>
          Let's step through a simple example to see how the <literal>Seam</literal> object works.
          First of all, let's create a new Seam component called <literal>helloAction</literal>.
        </para>

        <programlisting>
          <![CDATA[
  @Stateless
  @Name("helloAction")
  @Scope(SESSION)
  @Interceptors(SeamInterceptor.class)
  public class HelloAction implements HelloLocal {
    public String sayHello(String name) {
      return "Hello, " + name;
    }
  }
          ]]>
        </programlisting>

        <para>You also need to create a local interface for our new component - take special note of the 
        <literal>@WebRemote</literal> annotation, as it's required to make our method accessible via remoting:</para>

        <programlisting>
          <![CDATA[
  @Local
  public interface HelloLocal {
    @WebRemote
    public String sayHello(String name);
  }
          ]]>
        </programlisting>

        <para>
          That's all the server-side code we need to write.  Now for our web page - create a new page and
          import the following scripts:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript" src="seam/remoting/resource/remote.js">
    <!--
    // This space intentionally left blank
    //-->
  </script>

  <script type="text/javascript" src="seam/remoting/interface.js?helloAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
          ]]>
        </programlisting>

        <para>
          To make this a fully interactive user experience, let's add a button to our page:
        </para>

        <programlisting>
          <![CDATA[
  <button onclick="javascript:sayHello()">Say Hello</button>
          ]]>
        </programlisting>

        <para>
          We'll also need to add some more script to make our button actually do something when it's clicked:
        </para>

        <programlisting>
          <![CDATA[
  <script type="text/javascript">
    //<![CDATA[

    function sayHello() {
      var name = prompt("What is your name?");
      Seam.Component.getInstance("helloAction").sayHello(name, sayHelloCallback);
    }

    function sayHelloCallback(result) {
      alert(result);
    }

    // ]]>]]&gt;<![CDATA[
  </script>
          ]]>
        </programlisting>

        <para>
          We're done!  Deploy your application and browse to your page.  Click the button, and enter
          a name when prompted.  A message box will display the hello message confirming that the call
          was successful.  If you want to save some time, you'll find the full source code for this
          Hello World example in Seam's <literal>/examples/remoting/helloworld</literal> directory.
        </para>
        
        <para>
          So what does the code of our script actually do?  Let's break it down into smaller pieces.  To start with,
          you can see from the Javascript code listing that we have implemented two methods - the first method is
          responsible for prompting the user for their name and then making a remote request.  Take a look at the
          following line:
        </para>
        
        <programlisting>
  Seam.Component.getInstance("helloAction").sayHello(name, sayHelloCallback);
        </programlisting>
        
        <para>
          The first section of this line, <literal>Seam.Component.getInstance("helloAction")</literal> returns a
          proxy, or "stub" for our <literal>helloAction</literal> component.  We can invoke the methods of our
          component against this stub, which is exactly what happens with the remainder of the line:
          <literal>sayHello(name, sayHelloCallback);</literal>.
        </para>
        
        <para>
          What this line of code in its completeness does, is invoke the <literal>sayHello</literal> method of our 
          component, passing in <literal>name</literal> as a parameter.  The second parameter, 
          <literal>sayHelloCallback</literal> isn't a parameter of our component's <literal>sayHello</literal> 
          method, instead it tells the Seam Remoting framework that once it receives the response to our request, 
          it should pass it to the <literal>sayHelloCallback</literal> Javascript method.  This callback parameter
          is entirely optional, so feel free to leave it out if you're calling a method with a <literal>void</literal>
          return type or if you don't care about the result.
        </para>
        
        <para>
          The <literal>sayHelloCallback</literal> method, once receiving the response to our remote request
          then pops up an alert message displaying the result of our method call.
        </para>

      </sect2>
    </sect1>
    
    <sect1>
      <title>Client Interfaces</title>
      
      <para>
        In the configuration section above, the interface, or "stub" for our component is imported into our
        page via <literal>seam/remoting/interface.js</literal>:
      </para>
        
      <programlisting>
        <![CDATA[
  <script type="text/javascript" src="seam/remoting/interface.js?customerAction">
    <!--
    // This space intentionally left blank
    //-->
  </script>
        ]]>
      </programlisting>
      
      <para>
        By including this script in our page, the interface definitions for our component, plus any other
        components or types that are required to execute the methods of our component are generated and 
        made available for the remoting framework to use.
      </para>
      
      <para>
        There are two types of client stub that can be generated, "executable" stubs and "type" stubs. 
        Executable stubs are behavioural, and are used to execute methods against your session bean components, 
        while type stubs contain state and represent the types that can be passed in as parameters or returned 
        as a result.
      </para>
      
      <para>
        The type of client stub that is generated depends on the type of your Seam component. If the component is 
        a session bean, then an executable stub will be generated, otherwise if it's an entity or JavaBean, then 
        a type stub will be generated. There is one exception to this rule; if your component is a JavaBean (ie it
        is not a session bean nor an entity bean) and any of its methods are annotated with @WebRemote, then
        an executable stub will be generated for it instead of a type stub.  This allows you to use remoting to
        call methods of your JavaBean components in a non-EJB environment where you don't have access to session beans.
      </para>
      
    </sect1>

</chapter>
