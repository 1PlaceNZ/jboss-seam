<chapter id="events">
    <title>Events, interceptors and exception handling</title>

    <para>
        Complementing the contextual component model, there are two further basic concepts
        that facilitate the extreme loose-coupling that is the distinctive feature of Seam 
        applications. The first is a strong event model where events may be mapped to event 
        listeners via JSF-like method binding expressions. The second is the pervasive use 
        of annotations and interceptors to apply cross-cutting concerns to components which 
        implement business logic.
    </para>

    <sect1>
        <title>Seam events</title>
        <para>
            The Seam component model was developed for use with <emphasis>event-driven 
            applications</emphasis>, specifically to enable the development of fine-grained, 
            loosely-coupled components in a fine-grained eventing model. Events in Seam come
            in several types, most of which we have already seen:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>JSF events</para>
            </listitem>
            <listitem>
                <para>jBPM transition events</para>
            </listitem>
            <listitem>
                <para>Seam page actions</para>
            </listitem>
            <listitem>
                <para>Seam component-driven events</para>
            </listitem>
            <listitem>
                <para>Seam contextual events</para>
            </listitem>
        </itemizedlist>
        
        <para>
            All of these various kinds of events are mapped to Seam components via JSF EL
            method binding expressions. For a JSF event, this is defined in the JSF template:
        </para>
        
        <programlisting><![CDATA[<h:commandButton value="Click me!" action="#{helloWorld.sayHello}"/>]]></programlisting>
        
        <para>
            For a jBPM transition event, it is specified in the jBPM process definition or
            pageflow definition:
        </para>
        
        <programlisting><![CDATA[<start-page name="hello" view-id="/hello.jsp">
    <transition to="hello">
        <action expression="#{helloWorld.sayHello}"/>
    </transition>
</start-page>]]></programlisting>

        <para>
            You can find out more information about JSF events and jBPM events elsewhere. 
            Lets concentrate for now upon the two additional kinds of events defined by Seam.
        </para>
        
        <sect2>
            <title>Page actions</title>

        <para>
            A Seam page action is an event that occurs just before we render a page. 
            We declare page actions in <literal>WEB-INF/pages.xml</literal>. We
            can define a page action for either a particular JSF view id:
        </para>

        <programlisting><![CDATA[<pages>
    <page view-id="/hello.jsp" action="#{helloWorld.sayHello}"/>
</pages>]]></programlisting>

        <para>
            Or we can use a wildcard to specify an action that applies to all 
            view ids that match the pattern:
        </para>

        <programlisting><![CDATA[<pages>
    <page view-id="/hello/*" action="#{helloWorld.sayHello}"/>
</pages>]]></programlisting>

        <para>
            If multiple wildcarded page actions match the current view-id, Seam
            will call all the actions, in order of least-specific to most-specific.
        </para>

        <para>
            The page action method can return a JSF outcome. If the outcome is
            non-null, Seam will delegate to the defined JSFadn Seam navigation rules 
            and a different view may end up being rendered.
        </para>
        
        <para>
            Furthermore, the view id mentioned in the <literal>&lt;page&gt;</literal>
            element need not correspond to a real JSP or Facelets page! So, we can
            reproduce the functionality of a traditional action-oriented framework
            like Struts or WebWork using page actions. For example:
        </para>
        
        <programlisting><![CDATA[TODO: translate struts action into page action]]></programlisting>
        
        <para>
            This is quite useful if you want to do complex things in response to non-faces
            requests (for example, HTTP GET requests).
        </para>
        
        <sect3>
            <title>Page parameters</title>
            
            <para>
                A JSF faces request (a form submission) encapsulates both an "action"
                (a method binding) and "parameters" (input value bindings). A page 
                action might also needs parameters!
            </para>
            
            <para>
                Since GET requests are bookmarkable, page parameters are passed as 
                human-readable request parameters. (Unlike JSF form inputs, which are
                anything but!) 
            </para>
            
            <para>
                Seam lets us provide a value binding that maps a named request parameter 
                to an attribute of a model object.
            </para>
            
        <programlisting><![CDATA[<pages>
    <page view-id="/hello.jsp" action="#{helloWorld.sayHello}">
        <param name="firstName" value="#{person.firstName}"/>
        <param name="lastName" value="#{person.lastName}"/>
    </page>
</pages>]]></programlisting>

            <para>
                The <literal>&lt;param&gt;</literal> declaration is bidirectional, just
                like a value binding for a JSF input:
            </para>
            
            <itemizedlist>
                <listitem>
                    <para>
                        When a non-faces (GET) request for the view id occurs, Seam sets 
                        the value of the named request parameter onto the model object, 
                        after performing appropriate type conversions.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Any <literal>&lt;s:link&gt;</literal> or <literal>&lt;s:button&gt;</literal> 
                        transparently includes the request parameter. The value of the parameter is 
                        determined by evaluating the value binding during the render phase (when the 
                        <literal>&lt;s:link&gt;</literal> is rendered).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Any navigation rule with a <literal>&lt;redirect/&gt;</literal> to
                        the view id transparently includes the request parameter. The value 
                        of the parameter is determined by evaluating the value binding at
                        the end of the invoke application phase.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The value is transparently propagated with any JSF form submission
                        for the page with the given view id. (This means that view parameters
                        behave like <literal>PAGE</literal>-scoped context variables for
                        faces requests.
                    </para>
                </listitem>
            </itemizedlist>
            
            <para>
                The essential idea behind all this is that <emphasis>however</emphasis>
                we get from any other page to <literal>/hello.jsp</literal> (or from 
                <literal>/hello.jsp</literal> back to <literal>/hello.jsp</literal>), 
                the value of the model attribute referred to in the value binding is
                "remembered", without the need for a conversation (or other server-side
                state).
            </para>
            
            <para>
                This all sounds pretty complex, and you're probably wondering if such an
                exotic construct is really worth the effort. Actually, the idea is very
                natural once you "get it". It is definitely worth taking the time to 
                understand this stuff. Page parameters are the most elegant way to 
                propagate state across a non-faces request. They are especially cool for 
                problems like search screens with bookmarkable results pages, where we 
                would like to be able to write our application code to handle both POST 
                and GET requests with the same code. Page parameters eliminate repetitive 
                listing of request parameters in the view definition and make redirects
                much easier to code.
            </para>
            
            <para>
                Note that you don't need an actual page action method binding to use
                a page parameter. The following is perfectly valid:
            </para>
            
            <programlisting><![CDATA[<pages>
    <page view-id="/hello.jsp">
        <param name="firstName" value="#{person.firstName}"/>
        <param name="lastName" value="#{person.lastName}"/>
    </page>
</pages>]]></programlisting>

            <para>
                You can even specify a JSF converter:
            </para>

            <programlisting><![CDATA[<pages>
    <page view-id="/calculator.jsp" action="#{calculator.calculate}">
        <param name="x" value="#{calculator.lhs}"/>
        <param name="y" value="#{calculator.rhs}"/>
        <param name="op" converterId="com.my.calculator.OperatorConverter" value="#{calculator.op}"/>
    </page>
</pages>]]></programlisting>

            <programlisting><![CDATA[<pages>
    <page view-id="/calculator.jsp" action="#{calculator.calculate}">
        <param name="x" value="#{calculator.lhs}"/>
        <param name="y" value="#{calculator.rhs}"/>
        <param name="op" converter="#{operatorConverter}" value="#{calculator.op}"/>
    </page>
</pages>]]></programlisting>

        </sect3>
        
        <sect3>
            <title>Navigation</title>
            
            <para>
                You can use standard JSF navigation rules defined in <literal>faces-config.xml</literal>
                in a Seam application. However, JSF navigation rules have a number of annoying
                limitations:
            </para>
            
            <itemizedlist>
                <listitem>
                    <para>
                        It is not possible to specify request parameters to be used when redirecting.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        It is not possible to begin or end conversations from a rule.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Rules work by evaluating the return value of the action method; it is not
                        possible to evaluate an arbitrary EL expression.
                    </para>
                </listitem>
            </itemizedlist>
            
            <para>
                A further problem is that "orchestration" logic gets scattered between <literal>pages.xml</literal>
                and <literal>faces-config.xml</literal>. It's better to unify this logic into <literal>pages.xml</literal>.
            </para>
            
            <para>
                This JSF navigation rule:
            </para>
            
            <programlisting><![CDATA[<navigation-rule>
    <from-view-id>/editDocument.xhtml</from-view-id>
    
    <navigation-case>
        <from-action>#{documentEditor.update}</from-action>
        <from-outcome>success</from-outcome>
        <to-view-id>/viewDocument.xhtml</to-view-id>
        <redirect/>
    </navigation-case>
    
</navigation-rule>]]></programlisting>
        
            <para>
                Can be rewritten as follows:
            </para>
            
            <programlisting><![CDATA[<page view-id="/editDocument.xhtml">
    
    <navigation from-action="#{documentEditor.update}">
        <rule if-outcome="success">
            <redirect view-id="/viewDocument.xhtml"/>
        </rule>
    </navigation>
    
</page>]]></programlisting>
        
            <para>
                But it would be even nicer if we didn't have to pollute our <literal>DocumentEditor</literal> 
                component with string-valued return values (the JSF outcomes). So Seam lets us write:
            </para>
        
            <programlisting><![CDATA[<page view-id="/editDocument.xhtml">
    
    <navigation from-action="#{documentEditor.update}" 
                   evaluate="#{documentEditor.errors.size}">
        <rule if-outcome="0">
            <redirect view-id="/viewDocument.xhtml"/>
        </rule>
    </navigation>
    
</page>]]></programlisting>

            <para>
                Or even:
            </para>
        
            <programlisting><![CDATA[<page view-id="/editDocument.xhtml">
    
    <navigation from-action="#{documentEditor.update}">
        <rule if="#{documentEditor.errors.empty}">
            <redirect view-id="/viewDocument.xhtml"/>
        </rule>
    </navigation>
    
</page>]]></programlisting>

            <para>
                The first form evaluates a value binding to determine the outcome value
                to be used by the subsequent rules.
                The second approach ignores the outcome and evaluates a value binding
                for each possible rule.
            </para>
            
            <para>
                Of course, when an update succeeds, we probably want to end the current
                conversation. We can do that like this:
            </para>

            <programlisting><![CDATA[<page view-id="/editDocument.xhtml">
    
    <navigation from-action="#{documentEditor.update}">
        <rule if="#{documentEditor.errors.empty}">
            <end-conversation/>
            <redirect view-id="/viewDocument.xhtml"/>
        </rule>
    </navigation>
    
</page>]]></programlisting>

            <para>
                But ending the conversation loses any state associated with the conversation,
                including the document we are currently interested in! One solution would be
                to use an immediate render instead of a redirect:
            </para>

            <programlisting><![CDATA[<page view-id="/editDocument.xhtml">
    
    <navigation from-action="#{documentEditor.update}">
        <rule if="#{documentEditor.errors.empty}">
            <end-conversation/>
            <render view-id="/viewDocument.xhtml"/>
        </rule>
    </navigation>
    
</page>]]></programlisting>

            <para>
                But the correct solution is to pass the document id as a request parameter:
            </para>

            <programlisting><![CDATA[<page view-id="/editDocument.xhtml">
    
    <navigation from-action="#{documentEditor.update}">
        <rule if="#{documentEditor.errors.empty}">
            <end-conversation/>
            <redirect view-id="/viewDocument.xhtml">
                <param name="documentId" value="#{documentEditor.documentId}"/>
            </redirect>
        </rule>
    </navigation>
    
</page>]]></programlisting>

            <para>
                Null outcomes are a special case in JSF. The null outcome is interpreted to
                mean "redisplay the page". The following navigation rule matches any non-null
                outcome, but <emphasis>not</emphasis> the null outcome:
            </para>
            
            <programlisting><![CDATA[<page view-id="/editDocument.xhtml">
    
    <navigation from-action="#{documentEditor.update}">
        <rule>
            <render view-id="/viewDocument.xhtml"/>
        </rule>
    </navigation>
    
</page>]]></programlisting>

            <para>
                If you want to perform navigation when a null outcome occurs, use the
                following form instead:
            </para>
            
            <programlisting><![CDATA[<page view-id="/editDocument.xhtml">
    
    <navigation from-action="#{documentEditor.update}">
        <render view-id="/viewDocument.xhtml"/>
    </navigation>
    
</page>]]></programlisting>

        </sect3>

        <sect3>
            <title>Fine-grained files for definition of navigation, page actions and parameters</title>
            
            <para>
                If you have a lot of different page actions and page parameters,
                or even just a lot of navigation rules,
                you will almost certainly want to split the declarations up over
                multiple files. You can define actions and parameters for a page
                with the view id <literal>/calc/calculator.jsp</literal> in a 
                resource named <literal>calc/calculator.page.xml</literal>. The
                root element in this case is the <literal>&lt;page&gt;</literal>
                element, and the view id is implied:
            </para>
            
            <programlisting><![CDATA[<page action="#{calculator.calculate}">
    <param name="x" value="#{calculator.lhs}"/>
    <param name="y" value="#{calculator.rhs}"/>
    <param name="op" converter="#{operatorConverter}" value="#{calculator.op}"/>
</page>]]></programlisting>

        </sect3>
        
        </sect2>
        
        <sect2>
            <title>Component-driven events</title>
            
            <para>
                Seam components can interact by simply calling each others methods.
                Stateful components may even implement the observer/observable pattern.
                But to enable components to interact in a more loosely-coupled fashion
                than is possible when the components call each others methods directly,
                Seam provides <emphasis>component-driven events</emphasis>.
            </para>
            
            <para>
                We specify event listeners (observers) in <literal>components.xml</literal>.
            </para>
            
        <programlisting><![CDATA[<components>
    <event type="hello">
        <action expression="#{helloListener.sayHelloBack}"/>
        <action expression="#{logger.logHello}"/>
    </event>
</components>]]></programlisting>

            <para>
                Where the <emphasis>event type</emphasis> is just an arbitrary string.
            </para>
            
            <para>
                When an event occurs, the actions registered for that event will be called
                in the order they appear in <literal>components.xml</literal>. How does a
                component raise an event? Seam provides a built-in component for this.
            </para>
            
            <programlisting><![CDATA[@Name("helloWorld")
public class HelloWorld {
    public void sayHello() {
        FacesMessages.instance().add("Hello World!");
        Events.instance().raiseEvent("hello");
    }
}]]></programlisting>

            <para>
                Or you can use an annotation.
            </para>

            <programlisting><![CDATA[@Name("helloWorld")
public class HelloWorld {
    @RaiseEvent("hello")
    public void sayHello() {
        FacesMessages.instance().add("Hello World!");
    }
}]]></programlisting>

            <para>
                Notice that this event producer has no dependency upon event consumers.
                The event listener may now be implemented with absolutely no dependency
                upon the producer:
            </para>

            <programlisting><![CDATA[@Name("helloListener")
public class HelloListener {
    public void sayHelloBack() {
        FacesMessages.instance().add("Hello to you too!");
    }
}]]></programlisting>

            <para>
                The method binding defined in <literal>components.xml</literal> above 
                takes care of mapping the event to the consumer.
                If you don't like futzing about in the <literal>components.xml</literal> 
                file, you can use an annotation instead:
            </para>

            <programlisting><![CDATA[@Name("helloListener")
public class HelloListener {
    @Observer("hello")
    public void sayHelloBack() {
        FacesMessages.instance().add("Hello to you too!");
    }
}]]></programlisting>

            <para>
                You might wonder why I've not mentioned anything about event objects in
                this discussion. In Seam, there is no need for an event object to propagate
                state between event producer and listener. State is held in the Seam
                contexts, and is shared between components. However, if you really want
                to pass an event object, you can:
            </para>
            
            <programlisting><![CDATA[@Name("helloWorld")
public class HelloWorld {
    private String name;
    public void sayHello() {
        FacesMessages.instance().add("Hello World, my name is #0.", name);
        Events.instance().raiseEvent("hello", name);
    }
}]]></programlisting>

            <programlisting><![CDATA[@Name("helloListener")
public class HelloListener {
    @Observer("hello")
    public void sayHelloBack(String name) {
        FacesMessages.instance().add("Hello #0!", name);
    }
}]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Contextual events</title>
            <para>
                Seam defines a number of built-in events that the application can use to
                perform special kinds of framework integration. The events are:
            </para>
            
            <itemizedlist>
            <listitem><para><literal>org.jboss.seam.validationFailed</literal> &mdash; called when JSF validation fails</para></listitem>
            <listitem><para><literal>org.jboss.seam.noConversation</literal> &mdash; called when there is no long running conversation and a long running conversation is required</para></listitem>
            <listitem><para><literal>org.jboss.seam.preSetVariable.&lt;name&gt;</literal> &mdash; called when the context variable &lt;name&gt; is set</para></listitem>
            <listitem><para><literal>org.jboss.seam.postSetVariable.&lt;name&gt;</literal> &mdash; called when the context variable &lt;name&gt; is set</para></listitem>
            <listitem><para><literal>org.jboss.seam.preRemoveVariable.&lt;name&gt;</literal> &mdash; called when the context variable &lt;name&gt; is unset</para></listitem>
            <listitem><para><literal>org.jboss.seam.postRemoveVariable.&lt;name&gt;</literal> &mdash; called when the context variable &lt;name&gt; is unset</para></listitem>
            <listitem><para><literal>org.jboss.seam.preDestroyContext.&lt;SCOPE&gt;</literal> &mdash; called before the &lt;SCOPE&gt; context is destroyed</para></listitem>
            <listitem><para><literal>org.jboss.seam.postDestroyContext.&lt;SCOPE&gt;</literal> &mdash; called after the &lt;SCOPE&gt; context is destroyed</para></listitem>
            <listitem><para><literal>org.jboss.seam.beginConversation </literal>&mdash; called whenever a long-running conversation begins</para></listitem>
            <listitem><para><literal>org.jboss.seam.endConversation </literal>&mdash; called whenever a long-running conversation ends</para></listitem>
            <listitem><para><literal>org.jboss.seam.beginPageflow.&lt;name&gt; </literal>&mdash; called when the pageflow &lt;name&gt; begins</para></listitem>
            <listitem><para><literal>org.jboss.seam.endPageflow.&lt;name&gt; </literal>&mdash; called when the pageflow &lt;name&gt; ends</para></listitem>
            <listitem><para><literal>org.jboss.seam.createProcess.&lt;name&gt; </literal>&mdash; called when the process &lt;name&gt; is created</para></listitem>
            <listitem><para><literal>org.jboss.seam.endProcess.&lt;name&gt; </literal>&mdash; called when the process &lt;name&gt; ends</para></listitem>
            <listitem><para><literal>org.jboss.seam.initProcess.&lt;name&gt; </literal>&mdash; called when the process &lt;name&gt; is associated with the conversation</para></listitem>
            <listitem><para><literal>org.jboss.seam.initTask.&lt;name&gt; </literal>&mdash; called when the task &lt;name&gt; is associated with the conversation</para></listitem>
            <listitem><para><literal>org.jboss.seam.startTask.&lt;name&gt; </literal>&mdash; called when the task &lt;name&gt; is started</para></listitem>
            <listitem><para><literal>org.jboss.seam.endTask.&lt;name&gt; </literal>&mdash; called when the task &lt;name&gt; is ended</para></listitem>
            <listitem><para><literal>org.jboss.seam.postCreate.&lt;name&gt; </literal>&mdash; called when the component &lt;name&gt; is created</para></listitem>
            <listitem><para><literal>org.jboss.seam.preDestroy.&lt;name&gt; </literal>&mdash; called when the component &lt;name&gt; is destroyed</para></listitem>
            <listitem><para><literal>org.jboss.seam.beforePhase </literal>&mdash; called before the start of a JSF phase</para></listitem>
            <listitem><para><literal>org.jboss.seam.afterPhase </literal>&mdash; called after the end of a JSF phase</para></listitem>
            <listitem><para><literal>org.jboss.seam.postAuthenticate.&lt;name&gt; </literal>&mdash; called after a user is authenticated</para></listitem>
            <listitem><para><literal>org.jboss.seam.preAuthenticate.&lt;name&gt; </literal>&mdash; called before attempting to authenticate a user</para></listitem>
            <listitem><para><literal>org.jboss.seam.notLoggedIn</literal> &mdash; called there is no authenticated user and authentication is required</para></listitem>
            <listitem><para><literal>org.jboss.seam.rememberMe</literal> &mdash; occurs when Seam security detects the username in a cookie</para></listitem>
            </itemizedlist>
             
             <para>
                 Seam components may observe any of these events in just the same way they
                 observe any other component-driven events.
             </para>
        </sect2>
        
    </sect1>
    
    <sect1>
      <title>Seam interceptors</title>
      
      <para>
        EJB 3.0 introduced a standard interceptor model for session bean components. To add an
        interceptor to a bean, you need to write a class with a method annotated 
        <literal>@AroundInvoke</literal> and annotate the bean with an
        <literal>@Interceptors</literal> annotation that specifies the name of the interceptor
        class. For example, the following interceptor checks that the user is logged in before
        allowing invoking an action listener method:
      </para>
      
      <programlisting><![CDATA[public class LoggedInInterceptor {

   @AroundInvoke
   public Object checkLoggedIn(InvocationContext invocation) throws Exception {
   
      boolean isLoggedIn = Contexts.getSessionContext().get("loggedIn")!=null;
      if (isLoggedIn) {
         //the user is already logged in
         return invocation.proceed();
      }
      else {
         //the user is not logged in, fwd to login page
         return "login";
      }
   }

}]]></programlisting>

    <para>
        To apply this interceptor to a session bean which acts as an action listener, we must
        annotate the session bean <literal>@Interceptors(LoggedInInterceptor.class)</literal>.
        This is a somewhat ugly annotation. Seam builds upon the interceptor framework in
        EJB3 by allowing you to use <literal>@Interceptors</literal> as a meta-annotation. In
        our example, we would create an <literal>@LoggedIn</literal> annotation, as follows:
    </para>
      
      <programlisting><![CDATA[@Target(TYPE)
@Retention(RUNTIME)
@Interceptors(LoggedInInterceptor.class)
public @interface LoggedIn {}]]></programlisting>

        <para>
            We can now simply annotate our action listener bean with <literal>@LoggedIn</literal>
            to apply the interceptor.
        </para>
        
        <programlisting><![CDATA[@Stateless
@Name("changePasswordAction")
@LoggedIn
@Interceptors(SeamInterceptor.class)
public class ChangePasswordAction implements ChangePassword { 
    
    ...
    
    public String changePassword() { ... }
    
}]]></programlisting>

        <para>
            If interceptor ordering is important (it usually is), you can add
            <literal>@Interceptor</literal> annotations to your interceptor 
            classes to specify a partial order of interceptors.
        </para>
        
<programlisting><![CDATA[@Interceptor(around={BijectionInterceptor.class,
                     ValidationInterceptor.class,
                     ConversationInterceptor.class},
             within=RemoveInterceptor.class)
public class LoggedInInterceptor
{
    ...
}]]></programlisting>

        <para>
            You can even have a "client-side" interceptor, that runs around any of the built-in
            functionality of EJB3:
        </para>

<programlisting><![CDATA[@Interceptor(type=CLIENT)
public class LoggedInInterceptor
{
    ...
}]]></programlisting>

        <para>
            EJB interceptors are stateful, with a lifecycle that is the same as the component
            they intercept. For interceptors which do not need to maintain state, Seam lets
            you get a performance optimization by specifying 
            <literal>@Interceptor(stateless=true)</literal>.
        </para>

        <para>
            Much of the functionality of Seam is implemented as a set of built-in Seam interceptors,
            including the interceptors named in the previous example. You don't have to explicitly 
            specify these interceptors by annotating your components; they exist for all interceptable 
            Seam components.
        </para>
        
        <para>
            You can even use Seam interceptors with JavaBean components, not just EJB3 beans!
        </para>
        
        <para>
            EJB defines interception not only for business methods (using <literal>@AroundInvoke</literal>),
            but also for the lifecycle methods <literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>,
            <literal>@PrePassivate</literal> and <literal>@PostActive</literal>. Seam supports all these
            lifecycle methods on both component and interceptor not only for EJB3 beans, but also for
            JavaBean components (except <literal>@PreDestroy</literal> which is not meaningful for JavaBean
            components).
        </para>

    </sect1>
      
    <sect1>
        <title>Managing exceptions</title>
        
        <para>
            JSF is surprisingly limited when it comes to exception handling. As a partial 
            workaround for this problem, Seam lets you define how a particular class of 
            exception is to be treated by annotating the exception class, or declaring
            the exception class in an XML file. This facility is meant to be combined with 
            the EJB 3.0-standard <literal>@ApplicationException</literal> annotation which 
            specifies whether the exception should cause a transaction rollback.
        </para>
        
        <sect2>
            <title>Exceptions and transactions</title>
            
            <para>
                EJB specifies well-defined rules that let us control whether an exception 
                immediately marks the current transaction for rollback when it is thrown by 
                a business method of the bean: <emphasis>system exceptions</emphasis> always 
                cause a transaction rollback, <emphasis>application exceptions</emphasis> do 
                not cause a rollback by default, but they do if 
                <literal>@ApplicationException(rollback=true)</literal>
                is specified. (An application exception is any checked exception, or any
                unchecked exception annotated <literal>@ApplicationException</literal>.
                A system exception is any unchecked exception without an 
                <literal>@ApplicationException</literal> annotation.)
            </para>
            
            <para>
                Note that there is a difference between marking a transaction for rollback,
                and actually rolling it back. The exception rules say that the transaction
                should be marked rollback only, but it may still be active after the 
                exception is thrown.
            </para>
        
            <para>
                Seam applies the EJB 3.0 exception rollback rules also to Seam JavaBean 
                components.
            </para>
        
            <para>
                But these rules only apply in the Seam component layer. What about an exception 
                that is uncaught and propagates out of the Seam component layer, and out of the JSF 
                layer? Well, it is always wrong to leave a dangling transaction open, so Seam
                rolls back any active transaction when an exception occurs and is uncaught
                in the Seam component layer.
            </para>
        </sect2>
        
        <sect2>
            <title>Enabling Seam exception handling</title>
        
        <para>
            To enable Seam's exception handling, we need to make sure we have the master servlet 
            filter declared in <literal>web.xml</literal>:
        </para>
        
        <programlisting><![CDATA[<filter>
    <filter-name>Seam Filter</filter-name>
    <filter-class>org.jboss.seam.servlet.SeamFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>Seam Filter</filter-name>
    <url-pattern>*.seam</url-pattern>
</filter-mapping>]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Using annotations for exception handling</title>
            
        <para>
            The following exception results in a HTTP 404 error whenever it propagates out of the
            Seam component layer. It does not roll back the current transaction immediately when 
            thrown, but the transaction will be rolled back if it the exception is not caught by
            another Seam component.
        </para>
        
        <programlisting><![CDATA[@HttpError(errorCode=404)
public class ApplicationException extends Exception { ... }]]></programlisting>

        <para>
            This exception results in a browser redirect whenever it propagates out of the
            Seam component layer. It also ends the current conversation. It causes an immediate 
            rollback of the current transaction.
        </para>
        
        <programlisting><![CDATA[@Redirect(viewId="/failure.xhtml", end=true)
@ApplicationException(rollback=true)
public class UnrecoverableApplicationException extends RuntimeException { ... }]]></programlisting>

        <para>
            Note that <literal>@Redirect</literal> does not work for exceptions
            which occur during the render phase of the JSF lifecycle.
        </para>

        <para>
            This exception results in a redirect, along with a message to the user, when it 
            propagates out of the Seam component layer. It also immediately rolls back the 
            current transaction.
        </para>
        
        <programlisting><![CDATA[@Redirect(viewId="/error.xhtml", message="Unexpected error")
public class SystemException extends RuntimeException { ... }]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Using XML for exception handling</title>

        <para>
            Since we can't add annotations to all the exception classes we are interested in,
            Seam also lets us specify this functionality in <literal>pages.xml</literal>.
        </para>
        
        <programlisting><![CDATA[<pages>
   
   <exception class="javax.persistence.EntityNotFoundException">
      <http-error error-code="404"/>
   </exception>
   
   <exception class="javax.persistence.PersistenceException">
      <end-conversation/>
      <redirect view-id="/error.xhtml">
          <message>Database access failed</message>
      </redirect>
   </exception>
   
   <exception>
      <end-conversation/>
      <redirect view-id="/error.xhtml">
          <message>Unexpected failure</message>
      </redirect>
   </exception>
   
</pages>]]></programlisting>

        <para>
            The last <literal>&lt;exception&gt;</literal> declaration does not specify a class,
            and is a catch-all for any exception for which handling is not otherwise specified
            via annotations or in <literal>pages.xml</literal>.
        </para>
        
        </sect2>

    </sect1>
    
</chapter>
