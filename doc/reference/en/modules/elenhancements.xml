<chapter id="elenhancements">
  <title>Expression language enhancements</title>

  <para>
    The standard Unified Expression Language (EL) assumes that any parameters to a method expression will be 
    provided by Java code. This means that a method with parameters cannot be used as a JSF method binding.
    Seam provides an enhancement to the EL that allows parameters to be included in a method expression 
    itself. This applies to <emphasis>any</emphasis> Seam method expression, including any JSF method binding, 
    for example:
  </para>

  <programlisting><![CDATA[<h:commandButton action="#{hotelBooking.bookHotel(hotel)}" value="Book Hotel"/>]]></programlisting>

  <section>
    <title>Usage</title>

    <para>
      Parameters are surrounded by parentheses, and separated by commas:
    </para>

    <programlisting><![CDATA[<h:commandButton action="#{hotelBooking.bookHotel(hotel, user)}" value="Book Hotel"/>]]></programlisting>

    <para>
      The parameters <literal>hotel</literal> and <literal>user</literal> will be evaluated as 
      value expressions and passed to the <literal>bookHotel()</literal> method of the component. 
      This gives you an alternative to the use of <literal>@In</literal>.
    </para>
    
    <para>
      Any value expression may be used as a parameter:
    </para>

    <programlisting><![CDATA[<h:commandButton action="#{hotelBooking.bookHotel(hotel.id, user.username)}" 
                 value="Book Hotel"/>]]></programlisting>

    <para>
       <emphasis>Note:</emphasis> You can not pass objects as arguments! All that is passed is names, for example,
       <literal>hotel.id</literal> and <literal>user.username</literal>. If you check the rendered code of the
       previous example, you will see that the command button contains these names. These name arguments will be
       submitted to the server when you press the button, and Seam will look up and resolve these names (in any
       available context) before the action method is called. If the arguments can not be resolved at that time
       (because <literal>hotel</literal> and <literal>user</literal> variables can not be found in any available
       context) the action method will be called with <literal>null</literal> arguments!
    </para>

    <para>
      You may however pass literal strings using single or double quotes:
    </para>

    <programlisting><![CDATA[<h:commandLink action=‚Äù#{printer.println( ‚ÄòHello world!‚Äô )}‚Äù value=‚ÄùHello‚Äù/>]]></programlisting>
    <programlisting><![CDATA[<h:commandLink action=‚Äô#{printer.println( ‚ÄúHello again‚Äù )}‚Äô value=‚ÄôHello‚Äô/>]]></programlisting>

    <para>
      You might even want to use this notation for all your action methods, even when you don‚Äôt 
      have parameters to pass. This improves readability by making it clear that the expression is 
      a method expression and not a value expression:
    </para>
    
    <programlisting><![CDATA[<s:link value="Cancel" action="#{hotelBooking.cancel()}"/>]]></programlisting>
    
  </section>
  
  <section>
    <title>Limitations</title>

    <para>
      Please be aware of the following limitations:
    </para>

    <section>
      <title>Incompatibility with JSP 2.1</title>
      <para>
        This extension is not currently compatible with JSP 2.1. So if you want to use this extension 
        with JSF 1.2, you will need to use Facelets. The extension works correctly with JSP 2.0.
      </para>
    </section>

    <section>
      <title>Calling a <literal>MethodExpression</literal> from Java code</title>
      <para>
        Normally, when a <literal>MethodExpression</literal> or <literal>MethodBinding</literal> is created,
        the parameter types are passed in by JSF. In the case of a method binding, JSF assumes that there 
        are no parameters to pass. With this extension, we can‚Äôt know the parameter types until after the 
        expression has been evaluated. This has two minor consequences:
      </para>
      
      <itemizedlist>
        <listitem>
          <para>
            When you invoke a <literal>MethodExpression</literal> in Java code, parameters you pass may 
            be ignored. Parameters defined in the expression will take precedence.
          </para>
        </listitem>
        <listitem>
          <para>
            Ordinarily, it is safe to call <literal>methodExpression.getMethodInfo().getParamTypes()</literal>
            at any time. For an expression with parameters, you must first invoke the 
            <literal>MethodExpression</literal> before calling <literal>getParamTypes()</literal>.
          </para>
        </listitem>
      </itemizedlist>
      
      <para>
        Both of these cases are exceedingly rare and only apply when you want to invoke the 
        <literal>MethodExpression</literal> by hand in Java code.
      </para>
      
    </section>
    
  </section>

</chapter>