<chapter id="concepts">
    <title>Seam concepts</title>
    <para>
        The two core concepts in Seam are the notion of a <emphasis>context</emphasis> and the
        notion of a <emphasis>component</emphasis>. Components are stateful objects, usually
        EJBs, and an instance of a component is associated with a context, and given a name
        in that context. <emphasis>Bijection</emphasis> provides a mechanism for aliasing
        internal component names (instance variables) to contextual names, allowing component
        trees to be dynamically assembled, and reassembled by Seam.
    </para>
    <para>
        Let's start by describing the contexts built in to Seam.
    </para>

    <sect1>
    	<title>Seam contexts</title>
    	<para>
            Seam contexts are created and destroyed by the framework. The application does not 
            control context demarcation via explicit Java API calls. Context are usually implicit. 
            In some cases, however, contexts are demarcated via annotations.
    	</para>
        <para>
            The basic Seam contexts are:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>
                    Stateless context
                </para>
            </listitem>
            <listitem>
                <para>
                    Event (or request) context
                </para>
            </listitem>
            <listitem>
                <para>
                    Conversation context
                </para>
            </listitem>
            <listitem>
                <para>
                    Session context
                </para>
            </listitem>
            <listitem>
                <para>
                    Portlet context
                </para>
            </listitem>
            <listitem>
                <para>
                    Business process context
                </para>
            </listitem>
            <listitem>
                <para>
                    Application context
                </para>
            </listitem>
        </itemizedlist>

        <para>
            You will recognize some of these contexts from servlet and related specifications. However, 
            two of them might be new to you: <emphasis>conversation context</emphasis>, and 
            <emphasis>business process context</emphasis>. One reason state management in web applications 
            is so fragile and error-prone is that the three built-in contexts (request, session and application) 
            are not especially meaningful from the point of view of the business logic. A user login session, 
            for example, is a fairly arbitrary construct in terms of the actual application work flow. Therefore, 
            most Seam components are scoped to the conversation or business process contexts, since they are 
            the contexts which are most meaningful in terms of the application.
        </para>
        
        <para>
            Let's look at each context in turn.
        </para>

        <sect2>
            <title>Stateless context</title>
            <para>
                Components which are truly stateless (stateless session beans, primarily) always live in the 
                stateless context (this is really a non-context). Stateless components are not very interesting, 
                and are arguably not very object-oriented. Nevertheless, they are important and often useful.
            </para>
        </sect2>

        <sect2>
            <title>Event context</title>
            <para>
                The event context is the "narrowest" stateful context, and is a generalization of the notion of 
                the web request context to cover other kinds of events. Nevertheless, the event context associated 
                with the lifecycle of a JSF request is the most important example of an event context, and the one 
                you will work with most often. Components associated with the event context are destroyed at the 
                end of the request, but their state is available and well-defined for at least the lifecycle of 
                the request.
            </para>
        </sect2>
        
        <sect2>
            <title>Conversation context</title>
            <para>
                The conversation context is a truly central concept in Seam. A <emphasis>conversation</emphasis> 
                is a unit of work from the point of view of the user. It might span serveral interactions with 
                the user, several requests, and several database transactions. But to the user, a conversation 
                solves a single problem. For example, "book hotel", "approve contract", "create order" are all 
                conversations. You might like to think of a conversation implementing a single "use case", but 
                the relationship is not necessarily quite exact. 
            </para>
            <para>
                 A conversation holds state associated with "what the user is doing now, in this window". A single 
                 user may have multiple conversations in progress at any point in time, usually in multiple windows. 
                 The conversation context allows us to ensure that state from the different conversations does not 
                 collide and cause bugs.
            </para>
            <para>
                 It might take you some time to get used to thinking of applications in terms of conversations. But 
                 once you get used to it, we think you'll love the notion, and never be able to not think in terms 
                 of conversations again!
            </para>
            <para>
                 Some conversations last for just a single request. Conversations that span multiple requests must 
                 be demarcated using annotations provided by Seam.
            </para>
            <para>
                 Some conversations are also <emphasis>tasks</emphasis>. A task is a conversation that is significant 
                 in terms of a long-running business process, and has the potential to trigger a business process state 
                 transition when it is successfully completed. Seam provides a special set of annotations for task 
                 demarcation.
            </para>
            <para>
                 Seam implements configurable <emphasis>conversation timeout</emphasis>, automatically destroying 
                 inactive conversations, and thus ensuring that the state held by a single user login session does not 
                 grow without bound if the user abandons conversations.
            </para>
        </sect2>

        <sect2>
            <title>Session context</title>
            <para>
                A session context holds state associated with the user login session. While there are some cases where it 
                is useful to share state between several conversations, we generally frown on the use of session context 
                for holding components other than global information about the logged in user.
            </para>
        </sect2>
        
        <sect2>
            <title>Portlet context</title>
            <para>
                NYI: A future release of Seam will provide a context associated with the portlet instance for applications 
                running inside a JSR-168 compliant portal engine such as JBoss Portal.
            </para>
        </sect2>
        
        <sect2>
            <title>Business process context</title>
            <para>
                The business process context holds state associated with the long running business process. This state is 
                managed and made persistent by the BPM engine (JBoss jBPM). The business process spans multiple interactions 
                with multiple users, so this state is shared between multiple users, but in a well-defined manner. The 
                current task determines the current business process instance, and the lifecycle of the business process is 
                defined externally using a <emphasis>process definition language</emphasis>, so there are no special 
                annotations for business process demarcation.                
            </para>
        </sect2>

        <sect2>
            <title>Application context</title>
            <para>
                The application context is the familiar servlet context from the servlet spec. Application context is mainly 
                useful for holding static information such as configuration data, reference data or metamodels. For example, 
                Seam stores its own configuration and metamodel in the application context.
            </para>
        </sect2>

        <sect2>
            <title>Hierarchical conversation contexts</title>
            <para>
                NYI: Seam does not currently support hierarchical conversations (conversations within "wider" conversations). 
                This will be provided in a future release.
            </para>
        </sect2>

        <sect2>
            <title>Accessing contexts programmatically</title>
            <para>
                Within a context, component instances are identified by name (this is usually, but not always, the same as 
                the component name). You may access a named component instance in a particular scope via the Contexts class, 
                which provides access to several thread-bound instances of the Context interface:
            </para>
            
            <programlisting><![CDATA[User user = (User) Contexts.getSessionContext().get("user");]]></programlisting>
            
            <para>
                You may also set or change the value associated with a name:
            </para>
            
            <programlisting><![CDATA[Contexts.getSessionContext().set("user", user);]]></programlisting>
            
            <para>
                Usually, however, we obtain components from a context via injection, and put component instances into a 
                context via outjection.
            </para>
        </sect2>
    
        <sect2>
            <title>Context search priority</title>
            <para>
                Sometimes, as above, component instances are located within a particular known scope. Other times, all 
                scopes are searched, in <emphasis>priority order</emphasis>. The order is as follows:           
            </para>
            
            <itemizedlist>
                <listitem>
                    <para>
                        Event context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Conversation context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Session context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Business process context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Application context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Stateless context
                    </para>
                </listitem>
            </itemizedlist>
        
            <para>
                You can perform a priority search by calling <literal>Contexts.lookupInAllContexts()</literal>. 
                Whenever you access a component by name from a JSF page, a priority search occurs.
            </para>

        </sect2>

    </sect1>
    
    <sect1>
        <title>Seam components</title>
        <para>
            Seam components are POJOs (Plain Old Java Objects). In particular, they are JavaBeans or EJB 3.0 
            enterprise beans. While Seam does not require that components be EJBs and can even be used without 
            an EJB 3.0 compliant container, Seam was designed with EJB 3.0 in mind and includes deep integration 
            with EJB 3.0. Seam supports the following <emphasis>component types</emphasis>.
        </para>
        
        <itemizedlist>
            <listitem>
                <para>
                    EJB 3.0 stateless session beans
                </para>
            </listitem>
            <listitem>
                <para>
                    EJB 3.0 stateful session beans
                </para>
            </listitem>
            <listitem>
                <para>
                    EJB 3.0 entity beans
                </para>
            </listitem>
            <listitem>
                <para>
                    JavaBeans
                </para>
            </listitem>
        </itemizedlist>
        
        <sect2>
            <title>Stateless session beans</title>
            <para>
                Stateless session bean components are not able to hold state across multiple invocations.
                Therefore, they usually work by operating upon the state of other components in the various
                Seam contexts. They may be used as JSF action listeners, but cannot provide properties to
                JSF components for display.
            </para>
            <para>
                Stateless session beans always live in the stateless context.
            </para>
            <para>
                Stateless session beans are the least interesting kind of Seam component.
            </para>
        </sect2>
        
        <sect2>
            <title>Stateful session beans</title>
            <para>
                Stateful session bean components are able to hold state not only across multiple invocations
                of the bean, but also across multiple requests. Application state that does not belong in
                the database should usually be held by stateful session beans. This is a major difference
                between Seam and many other web application frameworks. Instead of sticking information
                about the current conversation directly in the <literal>HttpSession</literal>, you should 
                keep it in instance variables of a stateful session bean that is bound to the conversation
                context. This allows Seam to manage the lifecycle of this state for you, and ensure that
                there are no collisions between state relating to different concurrent conversations.
            </para>
            <para>
                Stateful session beans are often used as JSF action listener, and as backing beans that 
                provide properties to JSF components for display or form submission.
            </para>
            <para>
                By default, stateful session beans are bound to the conversation context.
            </para>
        </sect2>

        <sect2>
            <title>Entity beans</title>
            <para>
                Entity beans may be bound to a context and function as a seam component. Because
                entities have a persistent identity in addition to their contextual identity, entity
                instances are usually bound explicitly in Java code, rather than being instantiated
                implicitly by Seam.
            </para>
            <para>
                Entity bean components do not support bijection or context demarcation. Nor does 
                invocation of an entity bean trigger validation.
            </para>
            <para>
                Entity beans are not usually used as JSF action listener, but do often function as backing 
                beans that provide properties to JSF components for display or form submission. In 
                particular, it is common to use an entity as a backing bean, together with a stateless
                session bean action listener to implement create/update/delete type functionality.
            </para>
            <para>
                By default, entity beans are bound to the conversation context.
            </para>
        </sect2>

        <sect2>
            <title>JavaBeans</title>
            <para>
                Javabeans may be used just like a stateless or stateful session bean. However, they do
                not provide the functionality of a session bean (declarative transaction demarcation, 
                declarative security, automatic clustered state replication, EJB 3.0 persistence, 
                timeout methods, etc).
            </para>
            <para>
                In a later chapter, we show you how to use Seam and Hibernate without an EJB 
                container. In this use case, components are JavaBeans instead of session beans.
            </para>
            <para>
                By default, JavaBeans are bound to the conversation context.
            </para>
        </sect2>
        
        <sect2>
            <title>Interception</title>
            <para>
                In order to perform its magic (bijection, context demarcation, validation,
                etc), Seam must intercept component invocations. For JavaBeans, Seam is in full 
                control of instantiation of the component, and no special configuration is needed.
                For entity beans, interception is not required since bijection and context
                demarcation are not defined. For session beans, we must register an EJB 
                interceptor for the session bean component. The current draft of the EJB spec
                provides only one way to do this, using an annotation (the next revision of
                EJB 3.0 will fix this problem). So, for now, all session beans must be
                annotated as follows, if they are to be used as Seam components:
            </para>

            <programlisting><![CDATA[@Stateless
@Interceptor(SeamInterceptor.class)
public class LoginAction implements Login { 
    ... 
}]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Component names</title>
            <para>
                Almost all seam components need a name. We assign a name to a component using the 
                <literal>@Name</literal> annotation:
            </para>
            
            <programlisting><![CDATA[@Name("loginAction")
@Stateless
@Interceptor(SeamInterceptor.class)
public class LoginAction implements Login { 
    ... 
}]]></programlisting>

            <para>
                This name is the <emphasis>seam component name</emphasis> and is not related to any 
                other name defined by the EJB specification. However, seam component names work 
                just like JSF managed bean names and you can think of the two concepts as identical.
            </para>
            
            <para>
                Just like in JSF, a seam component instance is usually bound to its context using 
                the component name. So, for example, we would access the <literal>LoginAction</literal> 
                using <literal>Contexts.getStatelessContext().get("login")</literal>. Whenever Seam
                itself instantiates a component, it binds the instance to the component name. However, 
                it is possible for the application to bind a component to some other name 
                programmatically. Again, this works just like JSF managed beans.
            </para>
            
            <para>
                For very large applications, and for built-in seam components, qualified names are
                often used.
            </para>
            
            <programlisting><![CDATA[@Name("com.jboss.myapp.loginAction")
@Stateless
@Interceptor(SeamInterceptor.class)
public class LoginAction implements Login { 
    ... 
}]]></programlisting>

            <para>
                Unfortunately, JSF's expression language interprets a period as a property dereference.
                So, inside a JSF expression, we use <literal>$</literal> to indicate a qualified
                component name:
            </para>
            
            <programlisting><![CDATA[<h:commandButton type="submit" value="Login" action="#{com$jboss$myapp$loginAction.login}"/>]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Defining the component scope</title>
            <para>
                We can override the default scope (context) of a component using the <literal>@Scope</literal>
                annotation. This lets us define what context a component instance is bound to, when it is
                instantiated by Seam.
            </para>

            <programlisting><![CDATA[@Name("user")
@Entity
@Scope(SESSION)
public class User { 
    ... 
}]]></programlisting>

            <para>
                <literal>org.jboss.seam.ScopeType</literal> defines an enumeration of possible scopes.
            </para>

        </sect2>
        
        <sect2>
            <title>Built-in components</title>
            <para>
                Like many good frameworks, Seam eats its own dogfood and is implemented mostly as
                a set of built-in Seam interceptors (see later) and Seam components. This makes it
                easy for applications to customize the basic functionality of Seam by replacing the
                built-in implementations with custom implementations, or interact with built-in 
                components at runtime. The built-in components are defined in the Seam namespace 
                <literal>org.jboss.seam.core</literal> and the Java package of the same name.
            </para>
        </sect2>

        <sect2>
            <title>Configuring components</title>
            <para>
                Seam components may be provided with configuration data either via servlet init
                params, or via a properties file named <literal>seam.properties</literal> in the 
                root of the classpath. The Seam component must expose a JavaBeans-style property
                setter methods for the configurable attributes.
            </para>
            <para>
                If a seam component named <literal>"com.jboss.myapp.settings"</literal> has a setter
                method named <literal>setLocale()</literal>, we can provide a property named
                <literal>com.jboss.myapp.settings.locale</literal> in the <literal>seam.properties</literal>
                file or as a servlet init param, and Seam will set the value of the 
                <literal>locale</literal> attribute whenever it instantiates the component.
            </para>
            <para>
                The same mechanism is used to configure Seam itself. For example, to set the conversation
                timeout, we provide a value for <literal>org.jboss.seam.core.manager.conversationTimeout</literal>
                in <literal>web.xml</literal> or <literal>seam.properties</literal>. (There is a built-in
                Seam component named <literal>"org.jboss.seam.core.manager"</literal> with a setter method 
                named <literal>setConversationTimeout()</literal>.)
            </para>
        </sect2>

    </sect1>
    
</chapter>