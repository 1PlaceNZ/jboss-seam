<chapter id="concepts">
    <title>The contextual component model</title>
    <para>
        The two core concepts in Seam are the notion of a <emphasis>context</emphasis> and the
        notion of a <emphasis>component</emphasis>. Components are stateful objects, usually
        EJBs, and an instance of a component is associated with a context, and given a name
        in that context. <emphasis>Bijection</emphasis> provides a mechanism for aliasing
        internal component names (instance variables) to contextual names, allowing component
        trees to be dynamically assembled, and reassembled by Seam.
    </para>
    <para>
        Let's start by describing the contexts built in to Seam.
    </para>

    <sect1>
    	<title>Seam contexts</title>
    	<para>
            Seam contexts are created and destroyed by the framework. The application does not 
            control context demarcation via explicit Java API calls. Context are usually implicit. 
            In some cases, however, contexts are demarcated via annotations.
    	</para>
        <para>
            The basic Seam contexts are:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>
                    Stateless context
                </para>
            </listitem>
            <listitem>
                <para>
                    Event (or request) context
                </para>
            </listitem>
            <listitem>
                <para>
                    Page context
                </para>
            </listitem>
            <listitem>
                <para>
                    Conversation context
                </para>
            </listitem>
            <listitem>
                <para>
                    Session context
                </para>
            </listitem>
            <listitem>
                <para>
                    Business process context
                </para>
            </listitem>
            <listitem>
                <para>
                    Application context
                </para>
            </listitem>
        </itemizedlist>

        <para>
            You will recognize some of these contexts from servlet and related specifications. However, 
            two of them might be new to you: <emphasis>conversation context</emphasis>, and 
            <emphasis>business process context</emphasis>. One reason state management in web applications 
            is so fragile and error-prone is that the three built-in contexts (request, session and application) 
            are not especially meaningful from the point of view of the business logic. A user login session, 
            for example, is a fairly arbitrary construct in terms of the actual application work flow. Therefore, 
            most Seam components are scoped to the conversation or business process contexts, since they are 
            the contexts which are most meaningful in terms of the application.
        </para>
        
        <para>
            Let's look at each context in turn.
        </para>

        <sect2>
            <title>Stateless context</title>
            <para>
                Components which are truly stateless (stateless session beans, primarily) always live in the 
                stateless context (this is really a non-context). Stateless components are not very interesting, 
                and are arguably not very object-oriented. Nevertheless, they are important and often useful.
            </para>
        </sect2>

        <sect2>
            <title>Event context</title>
            <para>
                The event context is the "narrowest" stateful context, and is a generalization of the notion of 
                the web request context to cover other kinds of events. Nevertheless, the event context associated 
                with the lifecycle of a JSF request is the most important example of an event context, and the one 
                you will work with most often. Components associated with the event context are destroyed at the 
                end of the request, but their state is available and well-defined for at least the lifecycle of 
                the request.
            </para>
            <para>
                When you invoke a Seam component via RMI, or Seam Remoting, the event context is created and
                distroyed just for the invocation.
            </para>
        </sect2>
        
        <sect2>
            <title>Page context</title>
            <para>
                The page context allows you to associate state with a particular instance of a rendered page.
                You can initialize state in your event listener, or while actually rendering the page, and
                then have access to it from any event that originates from that page. This is especially
                useful for functionality like clickable lists, where the list is backed by changing data
                on the server side. The state is actually serialized to the client, so this construct is 
                extremely robust with respect to multi-window operation and the back button.
            </para>
        </sect2>
        
        <sect2>
            <title>Conversation context</title>
            <para>
                The conversation context is a truly central concept in Seam. A <emphasis>conversation</emphasis> 
                is a unit of work from the point of view of the user. It might span several interactions with 
                the user, several requests, and several database transactions. But to the user, a conversation 
                solves a single problem. For example, "book hotel", "approve contract", "create order" are all 
                conversations. You might like to think of a conversation implementing a single "use case", but 
                the relationship is not necessarily quite exact. 
            </para>
            <para>
                 A conversation holds state associated with "what the user is doing now, in this window". A single 
                 user may have multiple conversations in progress at any point in time, usually in multiple windows. 
                 The conversation context allows us to ensure that state from the different conversations does not 
                 collide and cause bugs.
            </para>
            <para>
                 It might take you some time to get used to thinking of applications in terms of conversations. But 
                 once you get used to it, we think you'll love the notion, and never be able to not think in terms 
                 of conversations again!
            </para>
            <para>
                 Some conversations last for just a single request. Conversations that span multiple requests must 
                 be demarcated using annotations provided by Seam.
            </para>
            <para>
                 Some conversations are also <emphasis>tasks</emphasis>. A task is a conversation that is significant 
                 in terms of a long-running business process, and has the potential to trigger a business process state
                 transition when it is successfully completed. Seam provides a special set of annotations for task 
                 demarcation.
            </para>
            <para>
                 Conversations may be <emphasis>nested</emphasis>, with one conversation taking place "inside" a 
                 wider conversation. This is an advanced feature.
            </para>
            <para>
                 Usually, conversation state is actually held by Seam in the servlet session between requests.
                 Seam implements configurable <emphasis>conversation timeout</emphasis>, automatically destroying 
                 inactive conversations, and thus ensuring that the state held by a single user login session does not 
                 grow without bound if the user abandons conversations.
            </para>
            <para>
                 Alternatively, Seam may be configured to keep conversational state in the client browser.
            </para>
        </sect2>

        <sect2>
            <title>Session context</title>
            <para>
                A session context holds state associated with the user login session. While there are some cases where it 
                is useful to share state between several conversations, we generally frown on the use of session context 
                for holding components other than global information about the logged in user.
            </para>
            <para>
                In a JSR-168 portal environment, the session context represents the portlet session.
            </para>
        </sect2>
        
        <sect2>
            <title>Business process context</title>
            <para>
                The business process context holds state associated with the long running business process. This state is 
                managed and made persistent by the BPM engine (JBoss jBPM). The business process spans multiple interactions 
                with multiple users, so this state is shared between multiple users, but in a well-defined manner. The 
                current task determines the current business process instance, and the lifecycle of the business process is 
                defined externally using a <emphasis>process definition language</emphasis>, so there are no special 
                annotations for business process demarcation.                
            </para>
        </sect2>

        <sect2>
            <title>Application context</title>
            <para>
                The application context is the familiar servlet context from the servlet spec. Application context is mainly 
                useful for holding static information such as configuration data, reference data or metamodels. For example, 
                Seam stores its own configuration and metamodel in the application context.
            </para>
        </sect2>

        <sect2>
            <title>Context variables</title>
            <para>
                A context defines a namespace, a set of <emphasis>context variables</emphasis>. These work much the
                same as session or request attributes in the servlet spec. You may bind any value you like to
                a context variable, but usually we bind Seam component instances to context variables.
            </para>
            
            <para>
                So, within a context, a component instance is identified by the context variable name (this is usually, 
                but not always, the same as the component name). You may programatically access a named component 
                instance in a particular scope via the <literal>Contexts</literal> class, which provides access to 
                several thread-bound instances of the <literal>Context</literal> interface:
            </para>
            
            <programlisting><![CDATA[User user = (User) Contexts.getSessionContext().get("user");]]></programlisting>
            
            <para>
                You may also set or change the value associated with a name:
            </para>
            
            <programlisting><![CDATA[Contexts.getSessionContext().set("user", user);]]></programlisting>
            
            <para>
                Usually, however, we obtain components from a context via injection, and put component instances into a 
                context via outjection.
            </para>
        </sect2>
    
        <sect2>
            <title>Context search priority</title>
            <para>
                Sometimes, as above, component instances are obtained from a particular known scope. Other times, all 
                stateful scopes are searched, in <emphasis>priority order</emphasis>. The order is as follows:           
            </para>
            
            <itemizedlist>
                <listitem>
                    <para>
                        Event context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Page context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Conversation context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Session context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Business process context
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Application context
                    </para>
                </listitem>
            </itemizedlist>
        
            <para>
                You can perform a priority search by calling <literal>Contexts.lookupInStatefulContexts()</literal>. 
                Whenever you access a component by name from a JSF page, a priority search occurs.
            </para>

        </sect2>

    </sect1>
    
    <sect1>
        <title>Seam components</title>
        <para>
            Seam components are POJOs (Plain Old Java Objects). In particular, they are JavaBeans or EJB 3.0 
            enterprise beans. While Seam does not require that components be EJBs and can even be used without 
            an EJB 3.0 compliant container, Seam was designed with EJB 3.0 in mind and includes deep integration 
            with EJB 3.0. Seam supports the following <emphasis>component types</emphasis>.
        </para>
        
        <itemizedlist>
            <listitem>
                <para>
                    EJB 3.0 stateless session beans
                </para>
            </listitem>
            <listitem>
                <para>
                    EJB 3.0 stateful session beans
                </para>
            </listitem>
            <listitem>
                <para>
                    EJB 3.0 entity beans
                </para>
            </listitem>
            <listitem>
                <para>
                    JavaBeans
                </para>
            </listitem>
        </itemizedlist>
        
        <sect2>
            <title>Stateless session beans</title>
            <para>
                Stateless session bean components are not able to hold state across multiple invocations.
                Therefore, they usually work by operating upon the state of other components in the various
                Seam contexts. They may be used as JSF action listeners, but cannot provide properties to
                JSF components for display.
            </para>
            <para>
                Stateless session beans always live in the stateless context.
            </para>
            <para>
                Stateless session beans are the least interesting kind of Seam component.
            </para>
        </sect2>
        
        <sect2>
            <title>Stateful session beans</title>
            <para>
                Stateful session bean components are able to hold state not only across multiple invocations
                of the bean, but also across multiple requests. Application state that does not belong in
                the database should usually be held by stateful session beans. This is a major difference
                between Seam and many other web application frameworks. Instead of sticking information
                about the current conversation directly in the <literal>HttpSession</literal>, you should 
                keep it in instance variables of a stateful session bean that is bound to the conversation
                context. This allows Seam to manage the lifecycle of this state for you, and ensure that
                there are no collisions between state relating to different concurrent conversations.
            </para>
            <para>
                Stateful session beans are often used as JSF action listener, and as backing beans that 
                provide properties to JSF components for display or form submission.
            </para>
            <para>
                By default, stateful session beans are bound to the conversation context. They may never
                be bound to the page or stateless contexts.
            </para>
        </sect2>

        <sect2>
            <title>Entity beans</title>
            <para>
                Entity beans may be bound to a context variable and function as a seam component. Because
                entities have a persistent identity in addition to their contextual identity, entity
                instances are usually bound explicitly in Java code, rather than being instantiated
                implicitly by Seam.
            </para>
            <para>
                Entity bean components do not support bijection or context demarcation. Nor does 
                invocation of an entity bean trigger validation.
            </para>
            <para>
                Entity beans are not usually used as JSF action listeners, but do often function as backing 
                beans that provide properties to JSF components for display or form submission. In 
                particular, it is common to use an entity as a backing bean, together with a stateless
                session bean action listener to implement create/update/delete type functionality.
            </para>
            <para>
                By default, entity beans are bound to the conversation context. They may never be bound to 
                the stateless context.
            </para>
        </sect2>

        <sect2>
            <title>JavaBeans</title>
            <para>
                Javabeans may be used just like a stateless or stateful session bean. However, they do
                not provide the functionality of a session bean (declarative transaction demarcation, 
                declarative security, automatic clustered state replication, EJB 3.0 persistence, 
                timeout methods, etc).
            </para>
            <para>
                In a later chapter, we show you how to use Seam and Hibernate without an EJB 
                container. In this use case, components are JavaBeans instead of session beans.
            </para>
            <para>
                By default, JavaBeans are bound to the conversation context.
            </para>
        </sect2>
        
        <sect2>
            <title>Interception</title>
            <para>
                In order to perform its magic (bijection, context demarcation, validation,
                etc), Seam must intercept component invocations. For JavaBeans, Seam is in full 
                control of instantiation of the component, and no special configuration is needed.
                For entity beans, interception is not required since bijection and context
                demarcation are not defined. For session beans, we must register an EJB 
                interceptor for the session bean component. We could use an annotation, as follows:
            </para>

            <programlisting><![CDATA[@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    ... 
}]]></programlisting>

            <para>
                But a much better way is to define the interceptor in <literal>ejb-jar.xml</literal>.
            </para>

        </sect2>
        
        <sect2>
            <title>Component names</title>
            <para>
                Almost all seam components need a name. We assign a name to a component using the 
                <literal>@Name</literal> annotation:
            </para>
            
            <programlisting><![CDATA[@Name("loginAction")
@Stateless
public class LoginAction implements Login { 
    ... 
}]]></programlisting>

            <para>
                This name is the <emphasis>seam component name</emphasis> and is not related to any 
                other name defined by the EJB specification. However, seam component names work 
                just like JSF managed bean names and you can think of the two concepts as identical.
            </para>
            
            <para>
                Just like in JSF, a seam component instance is usually bound to a context variable 
                with the same name as the component name. So, for example, we would access the 
                <literal>LoginAction</literal> using 
                <literal>Contexts.getStatelessContext().get("loginAction")</literal>. In particular,
                whenever Seam itself instantiates a component, it binds the new instance to a variable
                with the component name. However, again like JSF, it is possible for the application 
                to bind a component to some other context variable by programmatic API call. This is
                only useful if a particular component serves more than one role in the system. For
                example, the currently logged in <literal>User</literal> might be bound to the
                <literal>currentUser</literal> session context variable, while a <literal>User</literal>
                that is the subject of some administration functionality might be bound to the
                <literal>user</literal> conversation context variable.
            </para>
            
            <para>
                For very large applications, and for built-in seam components, qualified names are
                often used.
            </para>
            
            <programlisting><![CDATA[@Name("com.jboss.myapp.loginAction")
@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    ... 
}]]></programlisting>

            <para>
                Unfortunately, JSF's expression language interprets a period as a property dereference.
                So, inside a JSF expression, we use <literal>$</literal> to indicate a qualified
                component name:
            </para>
            
            <programlisting><![CDATA[<h:commandButton type="submit" value="Login"
                 action="#{com$jboss$myapp$loginAction.login}"/>]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Defining the component scope</title>
            <para>
                We can override the default scope (context) of a component using the <literal>@Scope</literal>
                annotation. This lets us define what context a component instance is bound to, when it is
                instantiated by Seam.
            </para>

            <programlisting><![CDATA[@Name("user")
@Entity
@Scope(SESSION)
public class User { 
    ... 
}]]></programlisting>

            <para>
                <literal>org.jboss.seam.ScopeType</literal> defines an enumeration of possible scopes.
            </para>

        </sect2>
        
        <sect2>
            <title>Components with multiple roles</title>
            <para>
                Some Seam component classes can fulfill more than one role in the system. For example,
                we often have a <literal>User</literal> class which is usually used as a session-scoped 
                component representing the current user but is used in user administration screens as a 
                conversation-scoped component. The <literal>@Role</literal> annotation lets us define
                an additional named role for a component, with a different scope&mdash;it lets us bind
                the same component class to different context variables. (Any Seam component 
                <emphasis>instance</emphasis> may be bound to multiple context variables, but this
                lets us do it at the class level, and take advantage of auto-instantiation.)
            </para>
            
            <programlisting><![CDATA[@Name("user")
@Entity
@Scope(CONVERSATION)
@Role(name="currentUser", scope=SESSION)
public class User { 
    ... 
}]]></programlisting>

            <para>
                The <literal>@Roles</literal> annotation lets us specify as many additional roles
                as we like.
            </para>

            <programlisting><![CDATA[@Name("user")
@Entity
@Scope(CONVERSATION)
@Roles({@Role(name="currentUser", scope=SESSION)
   @Role(name="tempUser", scope=EVENT)})
public class User { 
    ... 
}]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Built-in components</title>
            <para>
                Like many good frameworks, Seam eats its own dogfood and is implemented mostly as
                a set of built-in Seam interceptors (see later) and Seam components. This makes it
                easy for applications to interact with built-in components at runtime or even 
                customize the basic functionality of Seam by replacing the built-in components with 
                custom implementations. The built-in components are defined in the Seam namespace 
                <literal>org.jboss.seam.core</literal> and the Java package of the same name.
            </para>
            <para>
                Seam was designed to integrate tightly in a Java EE 5 environment. However, 
                we understand that there are many projects which are not running in a full EE
                environment, and at the time of writing, Java EE 5 is not yet final. We also
                realize the critical importance of easy unit and integration testing using 
                frameworks such as TestNG and JUnit. So, we've made it easy to run Seam in Java SE
                environments by allowing you to boostrap certain critical infrastructure normally
                only found in EE environments by installing built-in Seam components.
            </para>
            <para>
                For example, you can run your EJB3 components in Tomcat or an integration test suite 
                just by installing the built-in component <literal>org.jboss.seam.core.ejb</literal>,
                which automatically bootstraps the JBoss Embeddable EJB3 container and deploys your
                EJB components.
            </para>
            <para>
                Or, if you're not quite ready for the Brave New World of EJB 3.0, you can write
                a Seam application that uses only JavaBean components, together with Hibernate3
                for persistence, by installing the built-in component 
                <literal>org.jboss.seam.core.hibernate</literal>. When using Hibernate outside of a 
                J2EE environment, you will also probably need a JTA transaction manager and JNDI 
                server, which are available via the built-in component
                <literal>org.jboss.seam.core.microcontainer</literal>. 
                This lets you use the bulletproof JTA/JCA pooling datasource from JBoss application 
                server in an SE environment like Tomcat!
            </para>
        </sect2>

        <sect2>
            <title>Configuring components</title>
            <para>
                Seam components may be provided with configuration data either via servlet context
                parameters, or via a properties file named <literal>seam.properties</literal> in the 
                root of the classpath.
            </para>
            <para>
                The configurable Seam component must expose a JavaBeans-style property
                setter methods for the configurable attributes. If a seam component named
                <literal>com.jboss.myapp.settings</literal> has a setter method named 
                <literal>setLocale()</literal>, we can provide a property named
                <literal>com.jboss.myapp.settings.locale</literal> in the <literal>seam.properties</literal>
                file or as a servlet context parameter, and Seam will set the value of the 
                <literal>locale</literal> attribute whenever it instantiates the component.
            </para>
            <para>
                Note that it is not possible to configure stateless session beans or entity beans.
            </para>
            <para>
                The same mechanism is used to configure Seam itself. For example, to set the conversation
                timeout, we provide a value for <literal>org.jboss.seam.core.manager.conversationTimeout</literal>
                in <literal>web.xml</literal> or <literal>seam.properties</literal>. (There is a built-in
                Seam component named <literal>org.jboss.seam.core.manager</literal> with a setter method 
                named <literal>setConversationTimeout()</literal>.)
            </para>
        </sect2>

    </sect1>
    
    <sect1>
        <title>Bijection</title>
        <para>
            <emphasis>Dependency injection</emphasis> or <emphasis>inversion of control</emphasis> is by now
            a familiar concept to most Java developers. Dependency injection allows a component to obtain a
            reference to another component by having the container "inject" the other component to a setter
            method or instance variable. In all dependency injection implementations that we have seen, 
            injection occurs when the component is constructed, and the reference does not subsequently 
            change for the lifetime of the component instance. For stateless components, this is reasonable.
            From the point of view of a client, all instances of a particular stateless component are 
            interchangeable. On the other hand, Seam emphasizes the use of stateful components. So traditional
            dependency injection is no longer a very useful construct. Seam introduces the notion of
            <emphasis>bijection</emphasis> as a generalization of injection. In contrast to injection,
            bijection is:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <emphasis>contextual</emphasis> - bijection is used to assemble stateful components
                    from various different contexts (a component from a "wider" context may even have
                    a reference to a component from a "narrower" context)
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>bidirectional</emphasis> - values are injected from context variables into
                    attributes of the component being invoked, and also <emphasis>outjected</emphasis>
                    from the component attributes back out to the context, allowing the component being
                    invoked to manipulate the values of contextual variables simply by setting its own
                    instance variables
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>dynamic</emphasis> - since the value of contextual variables changes over 
                    time, and since Seam components are stateful, bijection takes place every time a
                    component is invoked
                </para>
            </listitem>
        </itemizedlist>

        <para>
            In essence, bijection lets you alias a context variable to a component instance variable,
            by specifying that the value of the instance variable is injected, outjected, or both. Of course,
            we use annotations to enable bijection.
        </para>
        
        <para>
            The <literal>@In</literal> annotation specifies that a value should be injected, either into 
            an instance variable:
        </para>
        
        <programlisting><![CDATA[@Name("loginAction")
@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    @In User user;
    ... 
}]]></programlisting>

        <para>
            or into a setter method:
        </para>
        
            <programlisting><![CDATA[@Name("loginAction")
@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    User user;
    
    @In
    public void setUser(User user) {
        this.user=user;
    }
    
    ... 
}]]></programlisting>

       
        <para>
            By default, Seam will do a priority search of all contexts, using the name of the property
            or instance variable that is being injected. You may wish to specify the context variable
            name explicitly, using, for example, <literal>@In("currentUser")</literal>.
        </para>

        <para>
            If you want Seam to create an instance of the component when there is no existing component
            instance bound to the named context variable, you should specify <literal>@In(create=true)</literal>. 
            If the value is optional (it can be null), specify <literal>@In(required=false)</literal>. 
        </para>
        
        <para>
            You can even inject the value of an expression:
        </para>
        
        <programlisting><![CDATA[@Name("loginAction")
@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    @In("#{user.username}") String username;
    ... 
}]]></programlisting>

        <para>
            (There is much more information about component lifecycle and injection in the next chapter.)
        </para>
        
        <para>
            The <literal>@Out</literal> annotation specifies that an attribute should be outjected,
            either from an instance variable:
        </para>

        <programlisting><![CDATA[@Name("loginAction")
@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    @Out User user;
    ... 
}]]></programlisting>

        <para>
            or from a getter method:
        </para>
        
            <programlisting><![CDATA[@Name("loginAction")
@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    User user;
    
    @Out
    public User getUser() {
        return user;
    }
    
    ... 
}]]></programlisting>

        <para>
            An attribute may be both injected and outjected:
        </para>

        <programlisting><![CDATA[@Name("loginAction")
@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    @In @Out User user;
    ... 
}]]></programlisting>

        <para>
            or:
        </para>
        
        <programlisting><![CDATA[@Name("loginAction")
@Stateless
@Interceptors(SeamInterceptor.class)
public class LoginAction implements Login { 
    User user;
    
    @In
    public void setUser(User user) {
        this.user=user;
    }
    
    @Out
    public User getUser() {
        return user;
    }
    
    ... 
}]]></programlisting>

    </sect1>
    
    <sect1>
    	<title>Seam interceptors</title>
    	<para>
    		EJB 3.0 introduced a standard interceptor model for session bean components. To add an
    		interceptor to a bean, you need to write a class with a method annotated 
    		<literal>@AroundInvoke</literal> and annotate the bean with an
    		<literal>@Interceptors</literal> annotation that specifies the name of the interceptor
    		class. For example, the following interceptor checks that the user is logged in before
    		allowing invoking an action listener method:
    	</para>
    	
    	<programlisting><![CDATA[public class LoggedInInterceptor {

   @AroundInvoke
   public Object checkLoggedIn(InvocationContext invocation) throws Exception {
   
      boolean isLoggedIn = Contexts.getSessionContext().get("loggedIn")!=null;
      if (isLoggedIn) {
         //the user is already logged in
         return invocation.proceed();
      }
      else {
         //the user is not logged in, fwd to login page
         return "login";
      }
   }

}]]></programlisting>

		<para>
		    To apply this interceptor to a session bean which acts as an action listener, we must
		    annotate the session bean <literal>@Interceptors(LoggedInInterceptor.class)</literal>.
		    This is a somewhat ugly annotation. Seam builds upon the interceptor framework in
		    EJB3 by allowing you to use <literal>@Interceptors</literal> as a meta-annotation. In
		    our example, we would create an <literal>@LoggedIn</literal> annotation, as follows:
		</para>
    	
    	<programlisting><![CDATA[@Target(TYPE)
@Retention(RUNTIME)
@Interceptors(LoggedInInterceptor.class)
public @interface LoggedIn {}]]></programlisting>

        <para>
            We can now simply annotate our action listener bean with <literal>@LoggedIn</literal>
            to apply the interceptor.
        </para>
        
        <programlisting><![CDATA[@Stateless
@Name("changePasswordAction")
@LoggedIn
@Interceptors(SeamInterceptor.class)
public class ChangePasswordAction implements ChangePassword { 
    
    ...
    
    public String changePassword() { ... }
    
}]]></programlisting>

        <para>
            If interceptor ordering is important (it usually is), you can add 
            <literal>@Within</literal> and <literal>@Around</literal> annotations to your
            interceptor classes to specify a partial order of interceptors.
        </para>
        
<programlisting><![CDATA[@Around({BijectionInterceptor.class,
         ValidationInterceptor.class,
         ConversationInterceptor.class})
@Within(RemoveInterceptor.class)
public class LoggedInInterceptor
{
    ...
}]]></programlisting>

        <para>
            Much of the functionality of Seam is implemented as a set of built-in Seam interceptors,
            including the interceptors named in the previous example. You don't have to explicitly specify 
            these interceptors by annotating your components; they exist for all interceptable Seam components.
        </para>
        
        <para>
            You can even use Seam interceptors with JavaBean components, not just EJB3 beans!
        </para>

    </sect1>
    
</chapter>