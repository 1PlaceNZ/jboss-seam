<chapter id="security">
  <title>Security</title>

  <para>
    The Seam Security API is an optional Seam module that provides authentication and authorization features
    for securing both domain and page resources within your Seam project.  It supports multiple levels of security
    <emphasis>granularity</emphasis>, making it capable of performing either simple role-based security checks,
    or at the other end of the scale complex rule-based permission checks on domain objects using JBoss Rules.
  </para>
  
  <sect1>
    <title>Authentication</title>
    
    <para>
      The authentication features provided by Seam Security are built upon JAAS (Java Authentication and Authorization Service), 
      and as such provide a robust and highly configurable API for handling user authentication.  However, for less complex 
      authentication requirements Seam offers a much more simplified method of authentication that hides the complexity of JAAS.  
    </para>
    
    <sect2>
      <title>Configuration</title>
    
      <para>
        The simplified authentication method uses a built-in JAAS login module, <literal>SeamLoginModule</literal>, which
        delegates authentication to one of your own Seam components.  This login module is already configured inside Seam as 
        part of a default application policy and as such does not require any additional configuration files.  It allows you to 
        write an authentication method using the entity classes that are provided by your own application.  Configuring this 
        simplified form of authentication requires the <literal>Identity</literal> component to be configured in 
        <literal>components.xml</literal>:
      </para>
      
      <programlisting>
        <![CDATA[
      <component class="org.jboss.seam.security.Identity">
          <property name="authMethod">#{authenticator.authenticate}</property>
      </component>      
        ]]>
      </programlisting>
      
      <para>
        The EL expression <literal>#{authenticator.authenticate}</literal> is a method binding indicating the
        <literal>authenticate</literal> method of the <literal>authenticator</literal> component.
      </para>
      
    </sect2>
    
    <sect2>
      <title>Writing an authentication method</title>
    
      <para>
        The <literal>authMethod</literal> property in <literal>components.xml</literal> specifies which method will be 
        used by <literal>SeamLoginModule</literal> to authenticate users.  The prototype for this method is expected to be:
      </para>
        
      <programlisting>
        <![CDATA[
  boolean (java.lang.String username, java.lang.String password, java.util.Set roles)
        ]]>
      </programlisting>
  
      <para>
        The first and second parameters should hopefully be self-explanatory.  The third parameter (<literal>roles</literal>) 
        is a Set object that should be populated with the user's roles only if authentication is successful.  The return value should
        be set to <literal>true</literal> for a successful authentication, or <literal>false</literal> for an unsuccessful 
        authentication. Here's a complete example of an authentication method inside a JavaBean component:
      </para>
    
      <programlisting>
        <![CDATA[
@Name("authenticator")      
public class Authenticator {
   @In EntityManager entityManager;
   public boolean authenticate(String username, String password, Set<String> roles) {
      try
      {            
         authenticatedUser = (User) entityManager.createQuery(
            "from User where username = :username and password = :password")
            .setParameter("username", username)
            .setParameter("password", password)
            .getSingleResult();

         if (authenticatedUser.getRoles() != null)
         {
            for (UserRole mr : authenticatedUser.getRoles())
               roles.add(mr.getName());
         }
         
         return true;
      }
      catch (NoResultException ex)
      {
         FacesMessages.instance().add("Invalid username/password");
         return false;
      }      
   }       
        ]]>
      </programlisting>
    
      <para>
        In the above example, both <literal>User</literal> and <literal>UserRole</literal> are application-specific
        entity beans.  The <literal>roles</literal> parameter is populated with the roles that the user is a member
        of, which should be added to the <literal>Set</literal> as literal string values, e.g. "admin", "user".
        If the user record is not found and a <literal>NoResultException</literal> thrown, the authentication method
        returns <literal>false</literal> to indicate the authentication failed.      
      </para>
      
    </sect2>
    
    <sect2>
      <title>Writing a login page</title>
      
      <para>
        The <literal>Identity</literal> component provides both <literal>username</literal> and <literal>password</literal> 
        properties, catering for the most common authentication scenario. These properties can be bound directly to the 
        username and password fields on a login form.  Once these properties are set, the <literal>identity.login()</literal> 
        method will authenticate the user using the provided credentials.  Here's an example of a simple login form:
      </para>
      
      <programlisting>
        <![CDATA[
    <div>
      <h:outputLabel for="name" value="Username"/>
      <h:inputText id="name" value="#{identity.username}"/>
    </div>
    
    <div>
      <h:outputLabel for="password" value="Password"/>
      <h:inputSecret id="password" value="#{identity.password}"/>
    </div>
    
    <div>
      <h:commandButton value="Login" action="#{identity.login}"/>
    </div>                
        ]]>
      </programlisting>
    </sect2>
    
  </sect1>
  
  <sect1>
    <title>Identity</title>
    
    <para>
      The <literal>Identity</literal> component is the core component of the Security API.  It is a session-scoped
      component that 1) contains the current state of the user's security, and 2) provides a number of useful 
      security-related methods.  This section details the most useful features of the <literal>Identity</literal> component.
    </para>
    
    <sect2>
      <title>Obtaining a reference</title>
      
      <para>
        There are two ways of obtaining a reference to the <literal>Identity</literal> for the current user's session.
        The first, inline method is to simply call <literal>Identity.instance()</literal>.  Alternatively, you may inject
        the <literal>Identity</literal> directly into your own components:
      </para>
      
      <programlisting>
        <![CDATA[
  @In Identity identity;        
        ]]>
      </programlisting>
    </sect2>
    
    <sect2>
      <title>isLoggedIn()</title>      
      <para>
        The <literal>isLoggedIn()</literal> method returns a boolean value indicating whether the user has been
        successfully authenticated or not. It may be useful for controlling the rendering of certain sections of a page,
        depending if the user is logged in or not.
      </para>
    </sect2>
    
    <sect2>
      <title>getSubject()</title>
      <para>
        The <literal>getSubject()</literal> method returns the <literal>javax.security.auth.Subject</literal> instance
        for the user's session.  The subject contains all of an authenticated user's principals.  If
        you are authenticating with your own <literal>LoginContext</literal>, it should be instantiated with the
        <literal>identity</literal>'s subject.
      </para>
    </sect2>
    
    <sect2>
      <title>isUserInRole()</title>
      <para>
        This method accepts a <literal>java.lang.String</literal> parameter and returns a <literal>boolean</literal>
        indicating whether the user is a member of the specified role.  Here's an example:
      </para>
      
      <programlisting>
        <![CDATA[
  if (!Identity.instance().isUserInRole("admin"))
    throw new AuthorizationException("Insufficient privileges");
        ]]>
      </programlisting>
    </sect2>
    
    <sect2>
      <title>checkRestriction()</title>
      <para>
        The <literal>checkRestriction()</literal> method accepts a <literal>java.lang.String</literal> parameter
        specifying a security EL expression to evaluate.  If the expression evaluates to <literal>false</literal>,
        one of two things happen; 1) if the user is not logged in, a <literal>NotLoggedInException</literal> is
        thrown, or 2) if the user is logged in, an <literal>AuthorizationException</literal> is thrown.  EL security
        functions are discussed in the Authorization section of this chapter.
      </para>
      
      <programlisting>
        <![CDATA[
  public void deleteCustomer() {
    Identity.instance().checkRestriction("#{s:hasPermission('customer', 'delete', customer)}");
    //...code
  }        
        ]]>
      </programlisting>
    </sect2>
    
    <sect2>
      <title>login()</title>
      <para>
        This method attempts to authenticate using the set values of the <literal>username</literal> and 
        <literal>password</literal> properties.  An overloaded version of this method, 
        <literal>login(LoginContext ctx)</literal> authenticates using an externally provided 
        <literal>LoginContext</literal>.  This method throws a <literal>LoginException</literal> if authentication
        is not successful.
      </para>
    </sect2>
    
    <sect2>
      <title>logout()</title>
      <para>
        This method clears the security state for the currently authenticated user.
      </para>
    </sect2>
    
  </sect1>
                
  <sect1>
    <title>Authorization</title>

    <para>
      The authorization features of the Seam security API make it possible to restrict access to a Seam 
      component based on the roles and permissions granted to the authenticated user.  Security restrictions 
      are defined using EL expressions, and configured by annotating either a Seam component method, or the component 
      class itself, with the <literal>@Restrict</literal> annotation. 
    </para>    
    
    <sect2>
      <title>Types of authorization checks</title>
      
      <para>
        The Seam security API provides two types of authorization checks; role checks and permission checks.  Role
        checks are simple checks to determine if a user is a member of a specific role.  They are equivalent in
        function to the <literal>isUserInRole()</literal> method found within the servlet specification.  Role checks
        can be performed by using the <literal>s:hasRole()</literal> EL function.  Here's a few examples of role checks.
      </para>
      
      <para>
        This first example demonstrates how to restrict access to the Seam component <literal>secureAction</literal>
        to all users besides those in the <literal>admin</literal> role.
      </para>      
      
      <programlisting>
        <![CDATA[
@Name("secureAction")
@Restrict("#{s:hasRole('admin')}")
public class SecureAction {
   // ...
}
        ]]>
      </programlisting>
      
      <para>
        This example demonstrates how to restrict access to a method of a Seam component to users in the
        <literal>superuser</literal> role.
      </para>
      
      <programlisting>
        <![CDATA[
  @Restrict("#{s:hasRole('superuser')}")
  public void secureMethod {
    // ...
  }
        ]]>
      </programlisting>
      
      <para>
        This last example shows how an inline security check can be performed within the body of a method, 
        rather than using the <literal>@Restrict</literal> annotation.
      </para>
      
      <programlisting>
        <![CDATA[
  public String changeUserPassword() {
    // code here
    Identity.instance().checkRestriction("#{s:hasRole('superuser')}");    
    // code here
  }  
        ]]>
      </programlisting>
                    
    </sect2>
    
  </sect1>

</chapter>
