<chapter id="configuration">
	<title>Configuring Seam</title>
	<para>
        Configuration is a very boring topic and an extremely tedious pastime. 
        Unfortunately, several lines of XML are required to integrate Seam into 
        your JSF implementation and servlet container. There's no need to be too 
        put off by the following sections; you'll never need to type any of this stuff
        yourself, since you can just copy and paste from the example applications!
    </para>
    
    <sect1>
        <title>Basic Seam configuration</title>
        
        <para>
            First, let's look at the basic configuration that is needed whenever 
            we use Seam with JSF.
        </para>
        
        <sect2>
            <title>Integrating Seam with JSF and your servlet container</title>
        <para>
            Seam requires the following entry in your <literal>web.xml</literal>
            file:
        </para>
        
        <programlisting><![CDATA[<listener>
    <listener-class>org.jboss.seam.servlet.SeamListener</listener-class>
</listener>]]></programlisting>
         
        <para>
            This listener is responsible for bootstrapping Seam, and for destroying
            session and application contexts.
        </para>

        <para>
            If you are using Seam in Apache MyFaces (and possibly some other JSF implementations),
            you <emphasis>must</emphasis> use client-side state saving. So you'll also need this 
            in <literal>web.xml</literal>:
        </para>
        
<programlisting><![CDATA[<context-param>
    <param-name>javax.faces.STATE_SAVING_METHOD</param-name>
    <param-value>client</param-value>
</context-param>]]></programlisting>
        
        <!-- No longer required:
        
        <para>
            To force JSF to delegate variable resolution to Seam, we need to register
            a <literal>VariableResolver</literal> in the 
            <literal>faces-config.xml</literal> file:
        </para>
        
        <programlisting><![CDATA[<application>
    <variable-resolver>org.jboss.seam.jsf.SeamVariableResolver</variable-resolver>
</application>]]></programlisting>

         -->

        <para>
            To integrate with the JSF request lifecycle, we also need a JSF
            <literal>PhaseListener</literal> registered in in the 
            <literal>faces-config.xml</literal> file:
        </para>
        
        <programlisting><![CDATA[<lifecycle>
    <phase-listener>org.jboss.seam.jsf.SeamPhaseListener</phase-listener>
</lifecycle>]]></programlisting>

        <para>
            The actual listener class here varies depending upon how you want to
            manage transaction demarcation (more on this below).
        </para>
        
        <para>
            If you are using Sun's JSF 1.2 reference implementation, you should
            add this to <literal>faces-config.xml</literal>:
        </para>
        
        <programlisting><![CDATA[<application>
    <el-resolver>org.jboss.seam.jsf.SeamELResolver</el-resolver>
</application>]]></programlisting>
        
        <para>
            (This line should not strictly speaking be necessary, but it works 
            around a minor bug in the RI.)
        </para>
        
        </sect2>
        
        <sect2>
            <title>Integrating Seam with your EJB container</title>
            
        <para>
            We need to apply the <literal>SeamInterceptor</literal> to our Seam 
            components. The simplest way to do this is to add the 
            following interceptor binding to the <literal>&lt;assembly-descriptor&gt;</literal>
            in <literal>ejb-jar.xml</literal>:
        </para>

<programlisting><![CDATA[<interceptor-binding>
    <ejb-name>*</ejb-name>
    <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>
</interceptor-binding>]]></programlisting>

        <para>
            Seam needs to know where to go to find session beans in JNDI.
            One way to do this is specify the <literal>@JndiName</literal>
            annotation on every session bean Seam component. However, this
            is quite tedious. A better approach is to specify a pattern
            that Seam can use to calculate the JNDI name from the EJB name.
            Unfortunately, there is no standard mapping to global JNDI
            defined in the EJB3 specification, so this mapping is 
            vendor-specific. We must specify a pattern using the configuration
            property named <literal>org.jboss.seam.core.init.jndiPattern</literal>.
            We may specify this using <literal>components.xml</literal>,
            <literal>web.xml</literal> or even <literal>seam.properties</literal>.
        </para>
        
        <para>
            For JBoss AS, the following pattern is correct:
        </para>
        
        <programlisting><![CDATA[<core:init jndi-name="myEarName/#{ejbName}/local" />]]></programlisting>

        <para>
            Or:
        </para>

        <programlisting><![CDATA[<context-param>
    <param-name>org.jboss.seam.core.init.jndiPattern</param-name>
    <param-value>myEarName/#{ejbName}/local</param-value>
</context-param>]]></programlisting>

        <para>
            Where <literal>myEarName</literal> is the name of the EAR in which
            the bean is deployed. 
        </para>
        
        <para>
            Outside the context of an EAR (when using
            the JBoss Embeddable EJB3 container), the following pattern is
            the one to use:
        </para>
        
        <programlisting><![CDATA[<core:init jndi-name="#{ejbName}/local" />]]></programlisting>

        <para>
            Or:
        </para>

        <programlisting><![CDATA[<context-param>
    <param-name>org.jboss.seam.core.init.jndiPattern</param-name>
    <param-value>#{ejbName}/local</param-value>
</context-param>]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Enabling conversation propagation with redirects</title>

        <para>
            If you want to use post-then-redirect in JSF, and you want Seam to
            propagate the conversation context across the browser redirects,
            you need to register a servlet filter:
        </para>

<programlisting><![CDATA[<filter>
    <filter-name>Seam Redirect Filter</filter-name>
    <filter-class>org.jboss.seam.servlet.SeamRedirectFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>Seam Redirect Filter</filter-name>
    <url-pattern>*.jsf</url-pattern>
</filter-mapping>]]></programlisting>

        <para>
            This filter intercepts any browser redirects and adds a request
            parameter that specifies the Seam conversation id.
        </para>
        
        </sect2>

    </sect1>
    
    <sect1>
        <title>Configuring Seam in Java EE 5</title>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/ee5.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/ee5.png" align="center"/>
          </imageobject>
        </mediaobject>
        
        <para>
            If you're running in a Java EE 5 environment, this is all the configuration
            required to start using Seam! But there is one final item you need to know about. 
            You must place a <literal>seam.properties</literal> file in the root of any 
            archive in which your Seam components are deployed (even an empty properties file 
            will do). At startup, Seam will scan any archives with
            <literal>seam.properties</literal> files for seam components. If that doesn't
            work for you, you can also add components by installing them explicitly in
            <literal>components.xml</literal>. (We don't recommend this alternative approach.)
        </para>
        
        <sect2>
            <title>Packaging</title>
        
        <para>
            Once you've packaged all this stuff together into an EAR, the archive structure
            will look something like this:
        </para>
        
        <programlisting><![CDATA[my-application.ear/
    jboss-seam.jar
    META-INF/
        MANIFEST.MF
        application.xml
    my-application.war/
        META-INF/
            MANIFEST.MF
        WEB-INF/
            web.xml
            components.xml
            faces-config.xml
        login.jsp
        register.jsp
        ...
    my-application.jar/
        META-INF/
            MANIFEST.MF
            persistence.xml
        seam.properties
        org/
            jboss/
                myapplication/
                    User.class
                    Login.class
                    LoginBean.class
                    Register.class
                    RegisterBean.class
                    ...]]></programlisting>
        
        <para>
            Make sure you reference <literal>jboss-seam.jar</literal> from manifests of the
            EJB-JAR and WAR.
        </para>
        
        <para>
            Seam ships with several example applications that are deployable in any Java EE 
            container that supports EJB 3.0.
        </para>
        
        </sect2>
        
        <para>
            I really wish that was all there was to say on the topic of configuration but 
            unfortunately we're only about a third of the way there. If you're too overwhelmed 
            by all this tedious configuration stuff, feel free to skip over the rest of this section 
            and come back to it later.
        </para>
        
    </sect1>
    
    <sect1>
        <title>Configuring Seam with the JBoss Embeddable EJB3 container</title>
        <para>
            The JBoss Embeddable EJB3 container lets you run EJB3 components outside the context
            of the Java EE 5 application server. This is especially, but not only, useful for testing. 
        </para>
        
        <para>
            The Seam booking example application includes a TestNG integration test suite that runs on
            the Embeddable EJB3 container.
        </para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/testng.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/testng.png" align="center"/>
          </imageobject>
        </mediaobject>
        
        <para>
            The booking example application may even be deployed to Tomcat.
        </para>
        
          <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/e-ejb3.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/e-ejb3.png" align="center"/>
          </imageobject>
        </mediaobject>
        
      <sect2>
            <title>Installing the Embeddable EJB3 container</title>
        
        <para>
            Seam ships with a build of the Embeddable EJB3 container in the <literal>embedded-ejb</literal>
            directory. To use the Embeddable EJB3 container with Seam, add the 
            <literal>embedded-ejb/conf</literal> directory, and all jars in the <literal>lib</literal> 
            and <literal>embedded-ejb/lib</literal> directories to your classpath. Then, add the 
            following line to <literal>components.xml</literal>:
        </para>
        
        <programlisting><![CDATA[<core:ejb />]]></programlisting>

        <para>
            This setting installs the built-in component named <literal>org.jboss.seam.core.ejb</literal>.
            This component is responsible for bootstrapping the EJB container when Seam is started,
            and shutting it down when the web application is undeployed.
        </para>
        
        </sect2>
        
        <sect2>
            <title>Configuring a datasource with the Embeddable EJB3 container</title>
        
        <para>
            You should refer to the Embeddable EJB3 container documentation for more information about
            configuring the container. You'll probably at least need to set up your own datasource. 
            Embeddable EJB3 is implemented using the JBoss Microcontainer, so it's very easy to add 
            new services to the minimal set of services provided by default. For example, I can add a 
            new datasource by putting this <literal>jboss-beans.xml</literal> file in my classpath:
        </para>
        
        <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>

<deployment xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="urn:jboss:bean-deployer bean-deployer_1_0.xsd"
            xmlns="urn:jboss:bean-deployer">

   <bean name="bookingDatasourceBootstrap"
        class="org.jboss.resource.adapter.jdbc.local.LocalTxDataSource">
      <property name="driverClass">org.hsqldb.jdbcDriver</property>
      <property name="connectionURL">jdbc:hsqldb:.</property>
      <property name="userName">sa</property>
      <property name="jndiName">java:/bookingDatasource</property>
      <property name="minSize">0</property>
      <property name="maxSize">10</property>
      <property name="blockingTimeout">1000</property>
      <property name="idleTimeout">100000</property>
      <property name="transactionManager">
        <inject bean="TransactionManager"/>
      </property>
      <property name="cachedConnectionManager">
        <inject bean="CachedConnectionManager"/>
      </property>
      <property name="initialContextProperties">
        <inject bean="InitialContextProperties"/>
      </property>
   </bean>

   <bean name="bookingDatasource" class="java.lang.Object">
      <constructor factoryMethod="getDatasource">
         <factory bean="bookingDatasourceBootstrap"/>
      </constructor>
   </bean>

</deployment>]]></programlisting>

        </sect2>
                
        <sect2>
            <title>Packaging</title>
        
        <para>
            The archive structure of a WAR-based deployment on an servlet engine like Tomcat 
            will look something like this:
        </para>
        
        <programlisting><![CDATA[my-application.war/
    META-INF/
        MANIFEST.MF
    WEB-INF/
        web.xml
        components.xml
        faces-config.xml
        lib/
            jboss-seam.jar
            myfaces-api.jar
            myfaces-impl.jar
            jboss-ejb3.jar
            jboss-jca.jar
            jboss-j2ee.jar
            ...
            mc-conf.jar/
                ejb3-interceptors-aop.xml
                embedded-jboss-beans.xml
                default.persistence.properties
                jndi.properties
                login-config.xml
                security-beans.xml
                log4j.xml
            my-application.jar/
                META-INF/
                    MANIFEST.MF
                    persistence.xml
                    jboss-beans.xml
                log4j.xml
                seam.properties
                org/
                    jboss/
                        myapplication/
                            User.class
                            Login.class
                            LoginBean.class
                            Register.class
                            RegisterBean.class
                            ...
    login.jsp
    register.jsp
    ...]]></programlisting>
    
        <para>
            The <literal>mc-conf.jar</literal> just contains the standard
            JBoss Microcontainer configuration files for Embeddable EJB3.
            You won't usually need to edit these files yourself.
        </para>
        
        <para>
            Most of the Seam example applications may be deployed to Tomcat by running
            <literal>ant deploy.tomcat</literal>.
        </para>
        
        </sect2>

    </sect1>
    
    <sect1>
        <title>Seam managed transactions</title>
        <para>
            EJB session beans feature declarative transaction management. The EJB container is able
            to start a transaction transparently when the bean is invoked, and end it when the
            invocation ends. If we write a session bean method that acts as a JSF action listener, 
            we can do all the work associated with that action in one transaction, and be sure that
            it is committed or rolled back when we finish processing the action. This is a great feature, 
            and all that is needed by many Seam applications.
        </para>
        
        <para>
            There is just one problem with this approach. ORM solutions like Hibernate and EJB 3.0
            persistence support lazy fetching of entity associations inside a transaction context, 
            but throw <literal>LazyInitializationException</literal>s if you try to access an unfetched
            association outside the context of a transaction. This is a problem if your view page
            tries to access data that was not fetched during the transaction. Hibernate users developed 
            the <emphasis>open session in view</emphasis> pattern to work around this problem. This
            pattern is usually implemented as a transaction which spans the entire request. There are
            several problems with this idea, the most serious being that we can't be sure that a
            transaction has been successful until we commit it, but by the time we commit the transaction,
            we have already rendered the view. Furthermore, this is at best a partial solution to the
            problem, because we can still meet the dreaded <literal>LazyInitializationException</literal>
            if we try to re-use the entity object in the next request.
        </para>
        
        <para>
            Seam <emphasis>completely solves</emphasis> the problem of unwanted
            <literal>LazyInitializationException</literal>s, while working around the biggest problem
            in the <emphasis>open session in view</emphasis> pattern. The solution comes in two parts:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>
                    use an extended persistence context that is scoped to the conversation, 
                    instead of to the request
                </para>
            </listitem>
            <listitem>
                <para>
                    use two transactions per request; the first spans the beginning of the update model
                    values phase until the end of the invoke application phase; the second spans the
                    render response phase
                </para>
            </listitem>
        </itemizedlist>
        
        <sect2>
            <title>Enabling Seam-managed transactions</title>
        
        <para>
            To make use of <emphasis>Seam managed transactions</emphasis>, you need to use 
            <literal>SeamExtendedManagedPersistencePhaseListener</literal> in place of
            <literal>SeamPhaseListener</literal>.
        </para>
        
        <programlisting><![CDATA[<lifecycle>
     <phase-listener>
        org.jboss.seam.jsf.SeamExtendedManagedPersistencePhaseListener
    </phase-listener>
</lifecycle>]]></programlisting>

        <para>
            It's also a good idea to add a servlet filter to rollback uncommitted transactions 
            when uncaught exceptions occur.
        </para>
        
<programlisting><![CDATA[<filter>
    <filter-name>Seam Exception Filter</filter-name>
    <filter-class>org.jboss.seam.servlet.SeamExceptionFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>Seam Exception Filter</filter-name>
    <url-pattern>*.jsf</url-pattern>
</filter-mapping>]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Using a Seam-managed persistence context</title>

        <para>
            You'll need to use a <emphasis>managed persistence context</emphasis> (for EJB3) or
            <emphasis>managed session</emphasis> (for Hibernate) in your components. We'll see how to 
            use a managed session later. Configuring a managed persistence context is easy. In
            <literal>components.xml</literal>, we can write:
        </para>

        <programlisting><![CDATA[<core:managed-persistence-context name="bookingDatabase" auto-create="true"
    persistence-unit-jndi-name="java:/EntityManagerFactories/bookingData"/>]]></programlisting>

        <para>
            This configuration creates a conversation-scoped Seam component named 
            <literal>bookingDatabase</literal> that manages the lifecycle of <literal>EntityManager</literal> 
            instances for the persistence unit (<literal>EntityManagerFactory</literal> instance) 
            with JNDI name <literal>java:/EntityManagerFactories/bookingData</literal>.
        </para>
        
        <para>
            Of course, you need to make sure that you have bound the <literal>EntityManagerFactory</literal> 
            into JNDI. In JBoss, you can do this by adding the following property setting to 
            <literal>persistence.xml</literal>.
        </para>
        
        <programlisting><![CDATA[<property name="jboss.entity.manager.factory.jndi.name" 
          value="java:/EntityManagerFactories/bookingData"/>]]></programlisting>
        
        <para>
            Now we can have our <literal>EntityManager</literal> injected using:
        </para>

        <programlisting><![CDATA[@In EntityManager bookingDatabase;]]></programlisting>
        
        </sect2>
                
    </sect1>
    
    <sect1>
        <title>Configuring Seam with Hibernate in Java EE</title>
        <para>
            Seam is useful even if you're not yet ready to take the plunge into EJB 3.0. In this 
            case you would use Hibernate3 instead of EJB 3.0 persistence, and plain JavaBeans
            instead of session beans. You'll miss out on some of the nice features of session 
            beans but it will be very easy to migrate to EJB 3.0 when you're ready and, in the
            meantime, you'll be able to take advantage of Seam's unique declarative state
            management architecture.
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/hibernate-ee.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/hibernate-ee.png" align="center"/>
          </imageobject>
        </mediaobject>
        
        <para>
            Seam JavaBean components do not provide declarative transaction demarcation like session
            beans do. You <emphasis>could</emphasis> manage your transactions manually using the
            JTA <literal>UserTransaction</literal> (you could even implement your own declarative
            transaction management in a Seam interceptor). But most applications will use Seam managed 
            transactions when using Hibernate with JavaBeans. Follow the instructions above to
            enable <literal>SeamExtendedManagedPersistencePhaseListener</literal>.
        </para>
        
        <para>
            The Seam distribution includes a version of the booking example application that 
            uses Hibernate and JavaBeans instead of EJB3. This example application is ready to 
            deploy into any J2EE application server.
        </para>
        
        <sect2>
            <title>Boostrapping Hibernate in Seam</title>
        
        <para>
            Seam will bootstrap a Hibernate <literal>SessionFactory</literal> from your
            <literal>hibernate.cfg.xml</literal> file if you install the built-in component
            named <literal>org.jboss.seam.core.hibernate</literal>. 
        </para>
        
        </sect2>
        
        <sect2>
            <title>Using a Seam-managed Hibernate Session</title>
        
        <para>
            We will also need to configure a <emphasis>managed session</emphasis> if we want a Seam 
            managed Hibernate <literal>Session</literal> to be available via injection. 
        </para>
        
        <para>
            To configure our Seam component, as usual, we use <literal>components.xml</literal>:
        </para>
        
        <programlisting><![CDATA[<core:managed-hibernate-session name="hibernateSessionFactory"/>

<core:managed-hibernate-session name="bookingDatabase" auto-create="true"
    session-factory-jndi-name="java:/bookingSessionFactory"/>]]></programlisting>

        <para>
            Where <literal>java:/bookingSessionFactory</literal> is the name of the session factory 
            specified in <literal>hibernate.cfg.xml</literal>. 
        </para>
        
        <programlisting><![CDATA[<session-factory name="java:/bookingSessionFactory">
		<property name="transaction.flush_before_completion">true</property>
		<property name="connection.release_mode">after_statement</property>
		<property name="transaction.manager_lookup_class">org.hibernate.transaction.JBossTransactionManagerLookup</property>
		<property name="transaction.factory_class">org.hibernate.transaction.JTATransactionFactory</property>
		<property name="connection.datasource">java:/bookingDatasource</property>
    ...
</session-factory>]]></programlisting>

        <para>
            Note that Seam does not flush the session, so you should always enable
            <literal>hibernate.transaction.flush_before_completion</literal> to 
            ensure that the session is automatically flushed before the JTA transaction
            commits.
        </para>
        
        <para>
            We can now have a managed Hibernate <literal>Session</literal> injected into our
            JavaBean components using the following code:
        </para>
        
        <programlisting><![CDATA[@In Session bookingDatabase;]]></programlisting>

        </sect2>
        
        <sect2>
            <title>Packaging</title>
            
        <para>
            We can package our application as a WAR, in the following structure:
        </para>
            
        <programlisting><![CDATA[my-application.war/
    META-INF/
        MANIFEST.MF
    WEB-INF/
        web.xml
        components.xml
        faces-config.xml
        lib/
            jboss-seam.jar
            hibernate3.jar
            ...
            my-application.jar/
                META-INF/
                   MANIFEST.MF
                seam.properties
                hibernate.cfg.xml
                org/
                    jboss/
                        myapplication/
                            User.class
                            Login.class
                            Register.class
                            ...
    login.jsp
    register.jsp
    ...]]></programlisting>
    
        </sect2>
        
        <para>
            If we want to deploy Hibernate in a non-J2EE environment like Tomcat or TestNG, we 
            need to do a little bit more work.
        </para>

    </sect1>
    
    <sect1>
        <title>Configuring Seam with Hibernate in Java SE</title>
        <para>
            The Seam support for Hibernate requires JTA and a JCA datasource. If you are running in
            a non-EE environment like Tomcat or TestNG, you can run these services, and Hibernate 
            itself, in the JBoss Microcontainer. 
        </para>
        
        <para>
            You can even deploy the Hibernate version of the booking example in Tomcat.
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/hibernate-mc.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/hibernate-mc.png" align="center"/>
          </imageobject>
        </mediaobject>
        
        <para>
            Seam ships with an example Microcontainer configuration in 
            <literal>microcontainer/conf/jboss-beans.xml</literal> that provides all the things you
            need to run Seam with Hibernate in any non-EE environment. Just add the 
            <literal>microcontainer/conf</literal> directory, and all jars in the <literal>lib</literal>
            and <literal>microcontainer/lib</literal> directories to your classpath. Refer to 
            the documentation for the JBoss Microcontainer for more information.
        </para>
        
        <sect2>
            <title>Using Hibernate and the JBoss Microcontainer</title>
        
        <para>
            The built-in Seam component named <literal>org.jboss.seam.core.microcontainer</literal>
            bootstraps the microcontainer. As before, we probably want to use a Seam managed session.
        </para>

        <programlisting><![CDATA[<core:microcontainer/>

<core:managed-hibernate-session name="bookingDatabase" auto-create="true"
    session-factory-jndi-name="java:/bookingSessionFactory"/>]]></programlisting>

        <para>
            Where <literal>java:/bookingSessionFactory</literal> is the name of the Hibernate session
            factory specified in <literal>hibernate.cfg.xml</literal>.
        </para>
        
        <para>
            You'll need to provide a <literal>jboss.beans.xml</literal> file that installs JNDI,
            JTA, your JCA datasource and Hibernate into the microcontainer:
        </para>
        
<programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>

<deployment xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="urn:jboss:bean-deployer bean-deployer_1_0.xsd"
            xmlns="urn:jboss:bean-deployer">
            
   <bean name="Naming" class="org.jnp.server.SingletonNamingServer"/>

   <bean name="TransactionManagerFactory" class="org.jboss.seam.microcontainer.TransactionManagerFactory"/>
   <bean name="TransactionManager" class="java.lang.Object">
      <constructor factoryMethod="getTransactionManager">
         <factory bean="TransactionManagerFactory"/>
      </constructor>
   </bean>

   <bean name="bookingDatasourceFactory" class="org.jboss.seam.microcontainer.DataSourceFactory">
      <property name="driverClass">org.hsqldb.jdbcDriver</property>
      <property name="connectionUrl">jdbc:hsqldb:.</property>
      <property name="userName">sa</property>
      <property name="jndiName">java:/hibernateDatasource</property>
      <property name="minSize">0</property>
      <property name="maxSize">10</property>
      <property name="blockingTimeout">1000</property>
      <property name="idleTimeout">100000</property>
      <property name="transactionManager"><inject bean="TransactionManager"/></property>
   </bean>
   <bean name="bookingDatasource" class="java.lang.Object">
      <constructor factoryMethod="getDataSource">
         <factory bean="bookingDatasourceFactory"/>
      </constructor>
   </bean>
   
   <bean name="bookingDatabaseFactory" class="org.jboss.seam.microcontainer.HibernateFactory"/>
   <bean name="bookingDatabase" class="java.lang.Object">
      <constructor factoryMethod="getSessionFactory">
         <factory bean="bookingDatabaseFactory"/>
      </constructor>
      <depends>bookingDatasource</depends>
   </bean>

</deployment>]]></programlisting>

        </sect2>

        <sect2>
            <title>Packaging</title>
            
        <para>
            The WAR could have the following structure:
        </para>
            
        <programlisting><![CDATA[my-application.war/
    META-INF/
        MANIFEST.MF
    WEB-INF/
        web.xml
        components.xml
        faces-config.xml
        lib/
            jboss-seam.jar
            hibernate3.jar
            ...
            jboss-microcontainer.jar
            jboss-jca.jar
            ...
            myfaces-api.jar
            myfaces-impl.jar
            mc-conf.jar/
                jndi.properties
                log4j.xml
            my-application.jar/
                META-INF/
                    MANIFEST.MF
                    jboss-beans.xml
                seam.properties
                hibernate.cfg.xml
                log4j.xml
                org/
                    jboss/
                        myapplication/
                            User.class
                            Login.class
                            Register.class
                            ...
    login.jsp
    register.jsp
    ...]]></programlisting>
    
        </sect2>
        
    </sect1>
    
    <sect1>
        <title>Configuring jBPM in Seam</title>
        <para>
            Seam's jBPM integration is not installed by default, so you'll need
            to enable jBPM by installing a built-in component. You'll also need to 
            explicitly list your process and pageflow definitions. In 
            <literal>components.xml</literal>:
        </para>
        
        <programlisting><![CDATA[<core:jbpm>
    <core:pageflow-definitions>
        <value>createDocument.jpdl.xml</value>
        <value>editDocument.jpdl.xml</value>
        <value>approveDocument.jpdl.xml</value>
    </core:pageflow-definitions>
    <core:process-definitions>
        <value>documentLifecycle.jpdl.xml</value>
    </core:process-definitions>
</core:jbpm>]]></programlisting>

        <para>
            No further special configuration is needed if you only have pageflows.
            If you do have business process definitions, you need to provide a
            jBPM configuration, and a Hibernate configuration for jBPM. The Seam 
            DVD Store demo includes example <literal>jbpm.cfg.xml</literal> and 
            <literal>hibernate.cfg.xml</literal> files that will work with Seam:
        </para>
        
        <programlisting><![CDATA[<jbpm-configuration>

  <jbpm-context>
    <service name="persistence">
       <factory>
          <bean class="org.jbpm.persistence.db.DbPersistenceServiceFactory">
             <field name="isTransactionEnabled"><false/></field>
          </bean>
       </factory>
    </service>
    <service name="message" factory="org.jbpm.msg.db.DbMessageServiceFactory" />
    <service name="scheduler" factory="org.jbpm.scheduler.db.DbSchedulerServiceFactory" />
    <service name="logging" factory="org.jbpm.logging.db.DbLoggingServiceFactory" />
    <service name="authentication" factory="org.jbpm.security.authentication.DefaultAuthenticationServiceFactory" />
  </jbpm-context>

</jbpm-configuration>]]></programlisting>

        <para>
            The most important thing to notice here is that jBPM transaction control is disabled.
            Seam or EJB3 should control the JTA transactions.
        </para>
        
        <sect2>
            <title>Packaging</title>
            <para>
                There is not yet any well-defined packaging format for jBPM configuration
                and process/pageflow definition files. In the Seam examples we've decided
                to simply package all these files into the root of the EAR. In future, we
                will probably design some other standard packaging format. So the EAR looks
                something like this:
            </para>
            
        <programlisting><![CDATA[my-application.ear/
    jboss-seam.jar
    jbpm-3.1.jar
    META-INF/
        MANIFEST.MF
        application.xml
    my-application.war/
        META-INF/
            MANIFEST.MF
        WEB-INF/
            web.xml
            components.xml
            faces-config.xml
        login.jsp
        register.jsp
        ...
    my-application.jar/
        META-INF/
            MANIFEST.MF
            persistence.xml
        seam.properties
        org/
            jboss/
                myapplication/
                    User.class
                    Login.class
                    LoginBean.class
                    Register.class
                    RegisterBean.class
                    ...
    jbpm.cfg.xml
    hibernate.cfg.xml
    createDocument.jpdl.xml 
    editDocument.jpdl.xml 
    approveDocument.jpdl.xml
    documentLifecycle.jpdl.xml]]></programlisting>
    
            <para>
                Remember to add <literal>jbpm-3.1.jar</literal> to the manifest of your 
                EJB-JAR and WAR. 
            </para>
            
        </sect2>

    </sect1>
    
    <sect1>
        <title>Configuring Seam in a Portal</title>
        
        <para>
            To run a Seam application as a portlet, you'll need to provide certain
            portlet metadata (<literal>portlet.xml</literal>, etc) in addition to
            the usual Java EE metadata. See the <literal>examples/portal</literal>
            directory for an example of the booking demo preconfigured to run on
            JBoss Portal.
        </para>
        
        <para>
            In addition, you'll need to use a portlet-specific phase listener
            instead of <literal>SeamPhaseListener</literal> or 
            <literal>SeamExtendedManagedPersistencePhaseListener</literal>.
            The <literal>SeamPortletPhaseListener</literal> and
            <literal>SeamExtendedManagedPersistencePortletPhaseListener</literal>
            are adapted to the portlet lifecycle.
        </para>
        
    </sect1>
    
</chapter>