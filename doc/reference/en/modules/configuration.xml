<chapter id="configuration">
	<title>Configuring Seam</title>
	<para>
        Configuration is a very boring topic and an extremely tedious pastime. 
        Unfortunately, several lines of XML are required to integrate Seam into 
        your JSF implementation and servlet container. There's no need to be too 
        put off by the following sections; you'll never need to type any of this stuff
        yourself, since you can just copy and paste from the example applications!
    </para>
    
    <sect1>
        <title>Integrating Seam with JSF and your servlet container</title>
        <para>
            Seam requires the following entry in your <literal>web.xml</literal>
            file:
        </para>
        
        <programlisting><![CDATA[<listener>
    <listener-class>org.jboss.seam.servlet.SeamListener</listener-class>
</listener>]]></programlisting>
         
        <para>
            This listener is responsible for bootstrapping seam, and for destroying
            session and application contexts.
        </para>

        <para>
            To force JSF to delegate variable resolution to Seam, we need to register
            a <literal>VariableResolver</literal> in the 
            <literal>faces-config.xml</literal> file:
        </para>
        
        <programlisting><![CDATA[<application>
    <variable-resolver>org.jboss.seam.jsf.SeamVariableResolver</variable-resolver>
</application>]]></programlisting>

        <para>
            To integrate with the JSF request lifecycle, we also needs a JSF
            <literal>PhaseListener</literal> registered in in the 
            <literal>faces-config.xml</literal> file:
        </para>
        
        <programlisting><![CDATA[<lifecycle>
     <phase-listener>org.jboss.seam.jsf.SeamPhaseListener</phase-listener>
</lifecycle>]]></programlisting>

        <para>
            The actual listener class here varies depending upon how you want to
            manage transaction demarcation (more on this later).
        </para>

    </sect1>
    
    <sect1>
        <title>Configuring Seam in Java EE 5</title>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/ee5.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/ee5.png" align="center"/>
          </imageobject>
        </mediaobject>
        
        <para>
            If you're running in a Java EE 5 environment, this is all the configuration
            required to start using Seam! But there is one final item you need to know about. 
            You must place a <literal>seam.properties</literal> file in the root of any 
            archive in which your Seam components are deployed (even an empty properties file 
            will do). At startup, Seam will scan any archives with
            <literal>seam.properties</literal> files for seam components. If that doesn't
            work for you, you can also add components by listing them explicitly in
            the configuration property named <literal>org.jboss.seam.init.componentClasses</literal>.
        </para>
        
        <para>
            Seam ships with several example applications that are deployable in any Java EE 
            container that supports EJB 3.0.
        </para>
        
        <para>
            I really wish that was all there was to say on the topic of configuration but 
            unfortunately we're only about a third of the way there. If you're too overwhelmed 
            by all this tedious configuration stuff, feel free to skip over the rest of this section 
            and come back to it later.
        </para>
        
    </sect1>
    
    <sect1>
        <title>Configuring Seam with the JBoss Embeddable EJB3 container</title>
        <para>
            The JBoss Embeddable EJB3 container lets you run EJB3 components outside the context
            of the Java EE 5 application server. This is especially, but not only, useful for testing. 
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/e-ejb3.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/e-ejb3.png" align="center"/>
          </imageobject>
        </mediaobject>
        
        <para>
            Seam ships with a build of the Embeddable EJB3 container in the <literal>embedded-ejb</literal>
            directory. To use the Embeddable EJB3 container with Seam, add the 
            <literal>embedded-ejb/conf</literal> directory, and all jars in the <literal>lib</literal> 
            and <literal>embedded-ejb/lib</literal> directories to your classpath. Then, add the following 
            line to <literal>seam.properties</literal>:
        </para>
        
        <programlisting><![CDATA[org.jboss.seam.init.componentClasses org.jboss.seam.core.Ejb]]></programlisting>
        
        <para>
            Or, alternatively, add the following entry to <literal>web.xml</literal>:
        </para>
        
        <programlisting><![CDATA[<context-param>
    <param-name>org.jboss.seam.init.componentClasses</param-name>
    <param-value>org.jboss.seam.core.Ejb</param-value>
</context-param>]]></programlisting>

        <para>
            This setting installs the built-in component named <literal>org.jboss.seam.core.ejb</literal>.
            This component is responsible for bootstrapping the EJB container when Seam is started,
            and shutting it down when the web application is undeployed.
        </para>
        
        <para>
            You should refer to the Embeddable EJB3 container documentation for more information about
            configuring the container. You'll probably at least need to set up your own datasource. 
            Embeddable EJB3 is implemented using the JBoss Microcontainer, so it's very easy to add 
            new services to the minimal set of services provided by default. For example, I can add a 
            new datasource by putting this <literal>jboss-beans.xml</literal> file in my classpath:
        </para>
        
        <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>

<deployment xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="urn:jboss:bean-deployer bean-deployer_1_0.xsd"
            xmlns="urn:jboss:bean-deployer">

   <bean name="bookingDatasourceBootstrap"
        class="org.jboss.resource.adapter.jdbc.local.LocalTxDataSource">
      <property name="driverClass">org.hsqldb.jdbcDriver</property>
      <property name="connectionURL">jdbc:hsqldb:.</property>
      <property name="userName">sa</property>
      <property name="jndiName">java:/bookingDatasource</property>
      <property name="minSize">0</property>
      <property name="maxSize">10</property>
      <property name="blockingTimeout">1000</property>
      <property name="idleTimeout">100000</property>
      <property name="transactionManager">
        <inject bean="TransactionManager"/>
      </property>
      <property name="cachedConnectionManager">
        <inject bean="CachedConnectionManager"/>
      </property>
      <property name="initialContextProperties">
        <inject bean="InitialContextProperties"/>
      </property>
   </bean>

   <bean name="bookingDatasource" class="java.lang.Object">
      <constructor factoryMethod="getDatasource">
         <factory bean="bookingDatasourceBootstrap"/>
      </constructor>
   </bean>

</deployment>]]></programlisting>
        
        <para>
            The Seam booking example application includes a TestNG integration test suite that runs on
            the Embeddable EJB3 container.
        </para>

        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/testng.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/testng.png" align="center"/>
          </imageobject>
        </mediaobject>
        
    </sect1>
    
    <sect1>
    	<title>Seam managed transactions</title>
    	<para>
    	    EJB session beans feature declarative transaction management. The EJB container is able
    	    to start a transaction transparently when the bean is invoked, and end it when the
    	    invocation ends. If we write a session bean method that acts as a JSF action listener, 
    	    we can do all the work associated with that action in one transaction, and be sure that
    	    it is committed or rolled back when we finish processing the action. This is a great feature, 
    	    and all that is needed by many Seam applications.
    	</para>
    	
    	<para>
    	    There is just one problem with this approach. ORM solutions like Hibernate and EJB 3.0
    	    persistence support lazy fetching of entity associations inside a transaction context, 
    	    but throw <literal>LazyInitializationException</literal>s if you try to access an unfetched
    	    association outside the context of a transaction. This is a problem if your view page
    	    tries to access data that was not fetched during the transaction. Hibernate users developed 
    	    the <emphasis>open session in view</emphasis> pattern to work around this problem. This
    	    pattern is usually implemented as a transaction which spans the entire request. There are
    	    several problems with this idea, the most serious being that we can't be sure that a
    	    transaction has been successful until we commit it, but by the time we commit the transaction,
    	    we have already rendered the view. Furthermore, this is at best a partial solution to the
    	    problem, because we can still meet the dreaded <literal>LazyInitializationException</literal>
    	    if we try to re-use the entity object in the next request.
    	</para>
    	
    	<para>
    	    Seam <emphasis>completely solves</emphasis> the problem of unwanted
    	    <literal>LazyInitializationException</literal>s, while working around the biggest problem
    	    in the <emphasis>open session in view</emphasis> pattern. The solution comes in two parts:
    	</para>
    	
    	<itemizedlist>
    		<listitem>
    			<para>
    			    use an extended persistence context that is scoped to the conversation, 
    			    instead of to the request
    			</para>
    		</listitem>
    		<listitem>
    			<para>
    			    use two transactions per request; the first spans the beginning of the update model
    			    values phase until the end of the invoke application phase; the second spans the
    			    render response phase
    			</para>
    		</listitem>
    	</itemizedlist>
    	
    	<para>
    	    To make use of <emphasis>Seam managed transactions</emphasis>, you need to use 
    	    <literal>SeamExtendedManagedPersistencePhaseListener</literal> in place of
    	    <literal>SeamPhaseListener</literal>.
    	</para>
    	
        <programlisting><![CDATA[<lifecycle>
     <phase-listener>
        org.jboss.seam.jsf.SeamExtendedManagedPersistencePhaseListener
    </phase-listener>
</lifecycle>]]></programlisting>

        <para>
            It's also a good idea to add a servlet filter to rollback uncommitted transaction when 
            uncaught exceptions occur.
        </para>
        
<programlisting><![CDATA[<filter>
    <filter-name>Seam Exception Filter</filter-name>
    <filter-class>org.jboss.seam.servlet.SeamExceptionFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>Seam Exception Filter</filter-name>
    <url-pattern>*.jsf</url-pattern>
</filter-mapping>]]></programlisting>

        <para>
            You'll need to use a <emphasis>managed persistence context</emphasis> (for EJB3) or
            <emphasis>managed session</emphasis> (for Hibernate) in your components. We'll see how to 
            use a managed session later. Configuring a managed persistence context is easy. In
            <literal>seam.properties</literal>, we can write:
        </para>

        <programlisting><![CDATA[org.jboss.seam.init.managedPersistenceContexts bookingDatabase
bookingDatabase.persistenceUnitName java:/EntityManagerFactories/bookingData]]></programlisting>
        
        <para>
            Or, in <literal>web.xml</literal>:
        </para>
        
        <programlisting><![CDATA[<context-param>
    <param-name>org.jboss.seam.init.managedPersistenceContexts</param-name>
    <param-value>bookingDatabase</param-value>
</context-param>

<context-param>
    <param-name>bookingDatabase.persistenceUnitName</param-name>
    <param-value>java:/EntityManagerFactories/bookingData</param-value>
</context-param>]]></programlisting>

        <para>
            This configuration creates a conversation-scoped Seam component named 
            <literal>bookingDatabase</literal> that manages the lifecycle of <literal>EntityManager</literal> 
            instances for the persistence unit (<literal>EntityManagerFactory</literal> instance) 
            with JNDI name <literal>java:/EntityManagerFactories/bookingData</literal>.
        </para>
        
        <para>
            Now we can have our <literal>EntityManager</literal> injected using:
        </para>

        <programlisting><![CDATA[@In(create=true) EntityManager bookingDatabase;]]></programlisting>
                
    </sect1>
    
    <sect1>
        <title>Configuring Seam with Hibernate in Java EE</title>
        <para>
            Seam is useful even if you're not yet ready to take the plunge into EJB 3.0. In this 
            case you would use Hibernate3 instead of EJB 3.0 persistence, and plain JavaBeans
            instead of session beans. You'll miss out on some of the nice features of session 
            beans but it will be very easy to migrate to EJB 3.0 when you're ready and, in the
            meantime, you'll be able to take advantage of Seam's unique declarative state
            management architecture.
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/hibernate-ee.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/hibernate-ee.png" align="center"/>
          </imageobject>
        </mediaobject>
        
        <para>
            Seam JavaBean components do not provide declarative transaction demarcation like session
            beans do. You <emphasis>could</emphasis> manage your transactions manually using the
            JTA <literal>UserTransaction</literal> (you could even implement your own declarative
            transaction management in a Seam interceptor). But most applications will use Seam managed 
            transactions when using Hibernate with JavaBeans. Follow the instructions above to
            enable <literal>SeamExtendedManagedPersistencePhaseListener</literal>.
        </para>
        
        <para>
            Seam will bootstrap a Hibernate <literal>SessionFactory</literal> from your
            <literal>hibernate.cfg.xml</literal> file if you install the built-in component
            named <literal>org.jboss.seam.core.hibernate</literal>. 
        </para>
        
        <para>
            We will also need to configure a <emphasis>managed session</emphasis> if we want a Seam 
            managed Hibernate <literal>Session</literal> to be available via injection. 
        </para>
        
        <para>
            To configure our Seam components, as usual, we have a choice between 
            <literal>seam.properties</literal> and <literal>web.xml</literal>.
            Let's show just the properties file this time:
        </para>
        
        <programlisting><![CDATA[org.jboss.seam.init.componentClasses org.jboss.seam.core.Hibernate
org.jboss.seam.init.managedSessions bookingDatabase
bookingDatabase.sessionFactoryName java:/bookingSessionFactory]]></programlisting>

        <para>
            Where <literal>java:/bookingSessionFactory</literal> is the name of the session factory 
            specified in <literal>hibernate.cfg.xml</literal>. We can now have a managed Hibernate 
            <literal>Session</literal> injected into a JavaBean using the following code:
        </para>
        
        <programlisting><![CDATA[@In(create=true) Session bookingDatabase;]]></programlisting>

        <para>
            The Seam distribution includes a version of the booking example application that 
            uses Hibernate and JavaBeans instead of EJB3. This example application is ready to 
            deploy into any J2EE application server. If we want to deploy in a non-J2EE environment
            like Tomcat or TestNG, we need to do a little bit more work.
        </para>

    </sect1>
    
    <sect1>
        <title>Configuring Seam with Hibernate in Java SE</title>
        <para>
            The Seam support for Hibernate requires JTA and a JCA datasource. If you are running in
            a non-EE environment like Tomcat or TestNG, you can run these services, and Hibernate 
            itself, in the JBoss Microcontainer. 
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/hibernate-mc.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/hibernate-mc.png" align="center"/>
          </imageobject>
        </mediaobject>
        
        <para>
            Seam ships with an example Microcontainer configuration in 
            <literal>microcontainer/conf/jboss-beans.xml</literal> that provides all the things you
            need to run Seam with Hibernate in any non-EE environment. Just add the 
            <literal>microcontainer/conf</literal> directory, and all jars in the <literal>lib</literal>
            and <literal>microcontainer/lib</literal> directories to your classpath. To rename or 
            reconfigure the datasource, add a new datasource or reconfigure Hibernate, just edit 
            <literal>microcontainer/conf/jboss-beans.xml</literal>. Refer to the documentation for
            the JBoss Microcontainer for more information.
        </para>
        <para>
            The built-in Seam component named <literal>org.jboss.seam.core.microcontainer</literal>
            bootstraps the microcontainer. As before, we probably want to use a Seam managed session.
        </para>

        <programlisting><![CDATA[org.jboss.seam.init.componentClasses org.jboss.seam.core.Microcontainer
org.jboss.seam.init.managedSessions bookingDatabase
bookingDatabase.sessionFactoryName java:/bookingSessionFactory]]></programlisting>

        <para>
            Where <literal>java:/bookingSessionFactory</literal> is the name of the Hibernate session
            factory specified in <literal>hibernate.cfg.xml</literal>.
        </para>

    </sect1>    	
    
</chapter>