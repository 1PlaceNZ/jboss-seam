<chapter id="tutorial">
  <title>Seam Tutorial</title>
  
  <section id="try-examples">
    <title>Try the examples</title>
    
    <indexterm><primary>compile example</primary></indexterm>
    <indexterm><primary>example</primary><secondary>compile</secondary></indexterm>
    <indexterm><primary>build example</primary></indexterm>
    <indexterm><primary>example</primary><secondary>build</secondary></indexterm>
    
    <para>
      In this tutorial, we'll assume that you have checked out <literal>jboss-seam-head</literal>
      and compiled the Seam core as explained in <xref linkend="installation"/>, or simply unzipped 
      the Seam distribution.
    </para>
    
    <para>
      The directory structure of each example application follows this pattern:
    </para>

     <itemizedlist>
            <listitem>
              <para>
                  Resources, such as deployment descriptors and web pages may be found in
                  <filename>examples/<replaceable>registration</replaceable>/resources</filename>
               </para>
            </listitem>
            <listitem>
               <para>
                  Java source code may be found in
                  <filename>examples/<replaceable>registration</replaceable>/src</filename>
               </para>
            </listitem>
            <listitem>
               <para>
                  The Ant build script is
                  <filename>examples/<replaceable>registration</replaceable>/build.xml</filename>
               </para>
            </listitem>
        </itemizedlist>
        
        <mediaobject>
            <imageobject role="fo">
                <imagedata fileref="images/FileSystem.png" align="center"/>
            </imageobject>
            <imageobject role="html">
                <imagedata fileref="../shared/images/FileSystem.png" align="center"/>
            </imageobject>
        </mediaobject>

   <section>
       <title>Compiling the examples</title>
       
       <para>
           First, make sure you have Ant correctly installed, with <literal>$ANT_HOME</literal>
           and <literal>$JAVA_HOME</literal> set correctly. Next, make sure <literal>$JBOSS_HOME</literal> 
           is set correctly for your JBoss 4.0.3 installation.
       </para>
       
       <para>
            Now, launch the ant build script by typing <literal>ant</literal> in the
            <filename>examples/<replaceable>registration</replaceable></filename> directory. 
            You should see something like this:
        </para>
     
        <programlisting><![CDATA[~/Workspace/jboss-seam/examples/registration$ ant
Buildfile: build.xml

prepare:
[mkdir] Created dir: /home/user/Workspace/jboss-seam/examples/registration/output
[mkdir] Created dir: /home/user/Workspace/jboss-seam/examples/registration/output/classes
[mkdir] Created dir: /home/user/Workspace/jboss-seam/examples/registration/output/war

compile: <co id="registration-build-compile"/>
[javac] Compiling 3 source files to /home/user/Workspace/jboss-seam/examples/registration/output/classes

ejb3: <co id="registration-build-ejb3"/>
[jar] Building jar: /home/user/Workspace/jboss-seam/examples/registration/output/jboss-seam-registration.ejb3

war: <co id="registration-build-war"/>
[jar] Building jar: /home/user/Workspace/jboss-seam/examples/registration/output/jboss-seam-registration.war

ear: <co id="registration-build-ear"/>
[jar] Building jar: /home/user/Workspace/jboss-seam/examples/registration/output/jboss-seam-registration.ear

deploy: <co id="registration-build-deploy"/>
[copy] Copying 1 file to /home/user/Workspace/jboss-head/build/output/jboss-5.0.0alpha/server/default/deploy

BUILD SUCCESSFUL
Total time: 2 seconds]]></programlisting>
            <!--calloutlist>
                <callout arearefs="registration-build-compile">
                    <para>Compiles all the Java classes</para>
                </callout>
                <callout arearefs="registration-build-ejb3">
                    <para>Builds the EJB3 archive</para>
                </callout>
                <callout arearefs="registration-build-war">
                    <para>Builds the WAR archive</para>
                </callout>
                <callout arearefs="registration-build-ear">
                    <para>Package the EJB3 and WAR archives into an EAR</para>
                </callout>
                <callout arearefs="registration-build-deploy">
                    <para>
                        Copies the EAR to the deploy directory of the JBoss instance defined by
                        <literal>$JBOSS_HOME</literal>
                    </para>
                </callout>
            </calloutlist-->
        
        <para>
            Assuming that all is well, the example application will now be deployed to JBoss. 
        </para>
        
    </section>
        
  </section>
  
  <section id="registration-example">
    <title>Your first Seam application: the registration example</title>

    <indexterm id="registration-example-range" class="start-of-range">
        <primary>example</primary><secondary>registration example</secondary>
    </indexterm>

    <para>
        The registration example is a fairly trivial application that lets a new user store
        his username, real name and password in the database. The example isn't intended to
        show off all of the cool functionality of Seam. However, it demonstrates the use of
        an EJB3 session bean as a JSF action listener, and basic configuration of Seam.
    </para>
    
    <para>
        We'll go slowly, since we realize you might not yet be familiar with EJB 3.0.
    </para>
        
    <section>
      <title>Running the example</title>
      
      <indexterm><primary>running example</primary></indexterm>
      <indexterm><primary>example</primary><secondary>running</secondary></indexterm>
      
      <para>
          If it's not already running, start JBoss by typing <literal>bin/run.sh</literal> 
          in the <literal>$JBOSS_HOME</literal> directory. Look for this line in the
          JBoss log to verify that the application was started succesfully:
      </para>
      
      <programlisting><![CDATA[11:44:12,759 INFO  [EARDeployer] Started J2EE application: file:/home/user/Workspace/jboss-head/build/output/jboss-5.0.0alpha/server/default/deploy/jboss-seam-registration.ear]]></programlisting>
      
      <para>
        Now point your web browser to <ulink url="http://localhost:8080/seam-registration/faces/register.jsp">
        <literal>http://localhost:8080/seam-<replaceable>registration</replaceable>/faces/<replaceable>register.jsp</replaceable></literal>
        </ulink>
      </para>

      <para>
        The page displays a very basic form with three input fields. Try filling them 
        in and then submitting the form.
      </para>

      <para>
        Now open the HSQL Database Manager by going to the
        <ulink url="http://localhost:8080/jmx-console/HtmlAdaptor?action=inspectMBean&amp;name=jboss%3Aservice%3DHypersonic%2Cdatabase%3DlocalDB">JBoss JMX console</ulink> 
        and pressing the <mousebutton>invoke</mousebutton> button under the <literal>startDatabaseManager</literal> method.
      </para>
      
      <para>
        Type in the SQL query <literal>SELECT * FROM USERS</literal> and click
        <mousebutton>Execute SQL Statement</mousebutton>. You should see the 
        data you just entered.
      </para>
      
      <screenshot>
        <screeninfo>HSQL database manager</screeninfo>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/HSQLDatabaseManager.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/HSQLDatabaseManager.png" align="center"/>
          </imageobject>
        </mediaobject>
      </screenshot>
            

    </section>

    <section>
      <title>Understanding the code</title>

      <para>
          Let's take a look at the code, starting from the "bottom".
      </para>
      
      <section>
        <title>The entity bean: <literal>User.java</literal></title>

        <para>
            We need an EJB entity bean for user data. This class defines <emphasis>persistence</emphasis>  
            and <emphasis>validation</emphasis> declaratively, via annotations. It also needs some extra
            annotations that define the class as a Seam component.
        </para>

        <example>
            <programlistingco>
                <areaspec>
                    <area id="registration-entity-annotation" coords="1"/>
                    <area id="registration-name-annotation" coords="2"/>
                    <area id="registration-scope-annotation" coords="3"/>
                    <area id="registration-table-annotation" coords="4"/>
                    <area id="registration-attributes" coords="9"/>
                    <area id="registration-empty-constructor" coords="20"/>
                    <area id="registration-notnull" coords="22"/>
                    <area id="registration-id-annotation" coords="44"/>
                </areaspec>
                <programlisting><![CDATA[@Entity
@Name("user")
@Scope(SESSION)
@Table(name="users")
public class User implements Serializable
{
   private static final long serialVersionUID = 1881413500711441951L;
   
   private String username;
   private String password;
   private String name;
   
   public User(String name, String password, String username)
   {
      this.name = name;
      this.password = password;
      this.username = username;
   }
   
   public User() {}
   
   @NotNull @Length(min=5, max=15)
   public String getPassword()
   {
      return password;
   }

   public void setPassword(String password)
   {
      this.password = password;
   }
   
   @NotNull
   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
   
   @Id @NotNull @Length(min=5, max=15)
   public String getUsername()
   {
      return username;
   }

   public void setUsername(String username)
   {
      this.username = username;
   }

}]]></programlisting>
                <calloutlist>
                    <callout arearefs="registration-entity-annotation">
                        <!-- indexterm>
                            <primary>Annotation</primary>
                            <secondary>@javax.persistence.Entity</secondary>
                        </indexterm-->
                        <para>
                            The EJB3 standard <literal>@Entity</literal> annotation indicates that the
                            <literal>User</literal> class is an entity bean.
                        </para>
                    </callout>
                    <callout arearefs="registration-name-annotation">
                        <!-- indexterm>
                            <primary>Annotation</primary>
                            <secondary>@org.jboss.seam.annotation.Name</secondary>
                        </indexterm-->
                        <para>
                            A Seam component needs a <emphasis>component name</emphasis> specified by the 
                            <link linkend="name-annotation"><literal>@Name</literal></link> annotation. This 
                            name must be unique within the Seam application. When JSF asks Seam to resolve
                            a context variable with a name that is the same as a Seam component name, and
                            the context variable is currently undefined (null), Seam will instantiate that
                            component, and bind the new instance to the context variable. In this case,
                            Seam will instantiate a <literal>User</literal> the first time JSF encounters
                            a variable named <literal>user</literal>.
                        </para>
                    </callout>
                    <callout arearefs="registration-scope-annotation">
                        <!-- indexterm>
                            <primary>Annotation</primary>
                            <secondary>@org.jboss.seam.annotation.Scope</secondary>
                        </indexterm-->
                        <para>
                            Whenever Seam instantiates a component, it binds the new instance to a context
                            variable in the component's <emphasis>default context</emphasis>. The default 
                            context is specified using the 
                            <link linkend="scope-annotation"><literal>@Scope</literal></link> annotation. 
                            The <literal>User</literal> bean is a session scoped component.
                        </para>
                    </callout>
                    <callout arearefs="registration-table-annotation">
                        <!--indexterm>
                            <primary>Annotation</primary>
                            <secondary>@javax.persistence.Table</secondary>
                        </indexterm-->
                        <para>
                            The EJB standard <literal>@Table</literal> annotation indicates that 
                            the <literal>User</literal> class is mapped to the <literal>users</literal>
                            table.
                        </para>
                    </callout>
                    <callout arearefs="registration-attributes">
                        <para>
                            <literal>name</literal>, <literal>password</literal> and
                            <literal>username</literal> are the persistent attributes of the 
                            entity bean. All of our persistent attributes define accessor
                            methods. These are needed when this component is used by JSF
                            in the render response and update model values phases.
                        </para>
                    </callout>
                    <callout arearefs="registration-empty-constructor">
                        <para>
                            An empty constructor is both required by both the EJB specification 
                            and by Seam.
                        </para>
                    </callout>
                    <callout arearefs="registration-notnull">
                        <para>
                            The <literal>@NotNull</literal> and <literal>@Length</literal> 
                            annotations are part of the Hibernate Validator framework. Seam 
                            integrates Hibernate Validator and lets you use it for data validation 
                            (even if you are not using Hibernate for persistence).
                        </para>
                    </callout>
                    <callout arearefs="registration-id-annotation">
                        <!--indexterm>
                            <primary>Annotation</primary>
                            <secondary>@javax.persistence.Id</secondary>
                        </indexterm-->
                        <para>
                            The EJB standard <literal>@Id</literal> annotation indicates the 
                            primary key attribute of the entity bean.
                        </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <para>
                The most important things to notice in this example are the <literal>@Name</literal>
                and <literal>@Scope</literal> annotations. This annotations establish that this class
                as a Seam component.
            </para>
            <para>
                We'll see below that the properties of our <literal>User</literal> class are bound 
                to directly to JSF components and are populated by JSF during the update model values
                phase. We don't need any tedious glue code to copy data back and forth between the 
                JSP pages and the entity bean domain model.
            </para>
            <para>
                However, entity beans shouldn't do transaction management or database access. So we 
                can't use this component as a JSF action listener. For that we need a session bean.
            </para>
        </example>
                
      </section>
      
      <section>
        <title>The stateless session bean class: <literal>RegisterAction.java</literal></title>
        
        <para>
            Most Seam application use session beans as JSF action listeners (you can use JavaBeans
            instead if you like). 
        </para>
        <para>
            We have exactly one JSF action in our application, and one session bean method attached 
            to it. In this case, we'll use a stateless session bean, since all the state associated 
            with our action is held by the <literal>User</literal> bean. 
        </para>
        
        <para>
            This is the only really interesting code in the example!
        </para>
        
        <example>
            <programlistingco>
                <areaspec>
                    <area id="registration-stateless-annotation" coords="1"/>
                    <area id="registration-interceptor-annotation" coords="4"/>
                    <area id="registration-in-annotation" coords="8"/>
                    <area id="registration-valid-annotation" coords="8"/>
                    <area id="registration-persistencecontext-annotation" coords="11"/>
                    <area id="registration-facescontext" coords="15"/>
                    <area id="registration-ifinvalid-annotation" coords="17"/>
                    <area id="registration-action-listener" coords="18"/>
                </areaspec>    
            <programlisting><![CDATA[@Stateless
@Scope(EVENT)
@Name("register")
@Interceptor(SeamInterceptor.class)
public class RegisterAction implements Register
{

   @In @Valid
   private User user;
   
   @PersistenceContext
   private EntityManager em;
   
   @In
   private FacesContext facesContext;
   
   @IfInvalid(outcome=Outcome.REDISPLAY)
   public String register()
   {
      List existing = em.createQuery("select username from User where username=:username")
         .setParameter("username", user.getUsername())
         .getResultList();
         
      if (existing.size()==0)
      {
         em.persist(user);
         return "success";
      }
      else
      {
         facesContext.addMessage(null, new FacesMessage("username already exists"));
         return null;
      }
   }

}]]></programlisting>
                    
            <calloutlist>
                <callout arearefs="registration-stateless-annotation">
                    <!--indexterm>
                        <primary>Annotation</primary>
                        <secondary>@javax.ejb.Stateful</secondary>
                    </indexterm-->
                    <para>
                        The EJB standard <literal>@Stateless</literal> annotation marks this class 
                        as stateless session bean.
                    </para>
                </callout>
                <callout arearefs="registration-interceptor-annotation">
                    <!--indexterm>
                        <primary>Annotation</primary>
                        <secondary>@javax.ejb.Interceptor</secondary>
                    </indexterm-->
                    <para>
                        The <literal>SeamInterceptor</literal> EJB interceptor must be enabled for 
                        all session beans which are Seam components.
                    </para>
                </callout>
                <callout arearefs="registration-in-annotation">
                    <!--indexterm>
                        <primary>Annotation</primary>
                        <secondary>@org.jboss.seam.annotations.In</secondary>
                    </indexterm-->
                    <para>
                        The <link linkend="in-annotation"><literal>@In</literal></link> annotation 
                        marks an attribute of the bean as injected by Seam. In this case, the
                        attribute is injected from a context variable named <literal>user</literal>
                        (the instance variable name).
                    </para>
                </callout>
                <callout arearefs="registration-valid-annotation">
                    <para>
                        The <literal>@Valid</literal> annotation is provided by Hibernate Validator
                        to specify that recursive validation of related objects should occur.
                    </para>
                </callout>
                <callout arearefs="registration-persistencecontext-annotation">
                    <!--indexterm>
                        <primary>Annotation</primary>
                        <secondary>@javax.persistence.PersistenceContext</secondary>
                    </indexterm-->
                    <para>
                        The EJB standard <literal>@PersistenceContext</literal> annotation is used to 
                        inject the EJB3 entity manager.
                    </para>
                </callout>
                <callout arearefs="registration-facescontext">
                    <!--indexterm>
                        <primary>Annotation</primary>
                        <secondary>@javax.persistence.PersistenceContext</secondary>
                    </indexterm-->
                    <para>
                        Seam also allows various JSF, Seam and jBPM context objects to be injected.
                        To get the current <literal>FacesContext</literal> instance injected to
                        a Seam component, just mark an instance variable named 
                        <literal>facesContext</literal> with the <literal>@In</literal> annotation.
                    </para>
                </callout>
                <callout arearefs="registration-ifinvalid-annotation">
                    <!--indexterm>
                        <primary>Annotation</primary>
                        <secondary>@org.jboss.seam.annotations.IfInvalid</secondary>
                    </indexterm-->
                    <para>
                        The <link linkend="ifinvalid-annotation"><literal>@IfInvalid</literal></link> 
                        annotation tells Seam to validate the component state using Hibernate Validator 
                        before invoking the action listener method, and return a different JSF outcome 
                        if the state is invalid. In this example, the <literal>user</literal> is 
                        validated when the <literal>register()</literal> method is invoked, and the
                        form is redisplayed with messages if a validation failure occurs.
                    </para>
                </callout>
                <callout arearefs="registration-action-listener">
                    <para>
                        The action listener method uses the standard EJB3 <literal>EntityManager</literal> 
                        API to interact with the database, and returns the JSF outcome. Note that, since
                        this is a sesson bean, a transaction is automatically begun when the 
                        <literal>register()</literal> method is called, and committed when it completes.
                    </para>
                </callout>
            </calloutlist>
            </programlistingco>
        
        <para>
            Note that we did not explicitly specify a <literal>@Scope</literal> this time. Each Seam 
            component type has a default scope if not explicitly specified. For stateless session beans,
            the default scope is the stateless context. Actually, <emphasis>all</emphasis> stateless
            session beans belong in the stateless context.
        </para>
        
        <para>
            Our session bean action listener performs the business and persistence logic for our
            mini-application. In more complex applications, we might need to layer the code and
            refactor persistence logic into a dedicated data access component. That's perfectly
            trivial to do. But notice that Seam does not force you into any particular strategy 
            for application layering.
        </para>
        
        <para>
            Furthermore, notice that our session bean has simultaneous access to context associated
            with the web request (the <literal>FacesContext</literal> object, for example), and
            state held in transactional resources (the <literal>EntityManager</literal> object).
            This is a break from traditional J2EE architectures. Again, if you are more comfortable
            with the traditional J2EE layering, you can certainly implement that in a Seam application.
            But for many applications, it's simply not very useful.
        </para>

        </example>        
      
      </section>
      
      <section>
        <title>The session bean local interface: <literal>Register.java</literal></title>
        
        <para>Naturally, our session bean needs a local interface.</para>

        <indexterm><primary>Annotation</primary><secondary>@javax.ejb.Local</secondary></indexterm>
        
        <example>
          <programlisting><![CDATA[@Local
public interface Register
{
   public String register();
}]]></programlisting>
        </example>
        
        <para>
            That's the end of the Java code. Now onto the deployment descriptors.
        </para>
        
        <para>
            Stop yawning!
        </para>
                    

      </section>
      
      <section>
        <title>The web deployment description: <literal>web.xml</literal></title>
        
        <indexterm><primary>web.xml</primary></indexterm>
        <indexterm><primary>descriptor file</primary><secondary>web.xml</secondary></indexterm>
        
        <para>
            The presentation layer for our mini-application will be deployed in a WAR.
            So we'll need a web deployment descriptor.
        </para>
                
        <example>
          <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.4" 
    xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">


    <!-- Seam -->
    
    <listener>
        <listener-class>org.jboss.seam.servlet.SeamListener</listener-class>
    </listener>

    <!-- MyFaces -->

    <listener>
        <listener-class>org.apache.myfaces.webapp.StartupServletContextListener</listener-class>
    </listener>
    
    <context-param>
        <param-name>javax.faces.STATE_SAVING_METHOD</param-name>
        <param-value>client</param-value>
    </context-param>

    <servlet>
        <servlet-name>Faces Servlet</servlet-name>
        <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!-- Faces Servlet Mapping -->
    <servlet-mapping>
        <servlet-name>Faces Servlet</servlet-name>
        <url-pattern>/faces/*</url-pattern>
    </servlet-mapping>
    
</web-app>]]></programlisting>
        </example>
        
        <para>
            This <literal>web.xml</literal> file configures Seam and MyFaces. The configuration you
            see here is pretty much identical in all Seam applications. 
        </para>
        
        <para>
            (OK, you're allowed to yawn now.)
        </para>
      </section>
      
      <section>
        <title>The JSF configration: <literal>faces-config.xml</literal></title>
        
        <indexterm><primary>faces-config.xml</primary></indexterm>
        <indexterm><primary>descriptor file</primary><secondary>faces-config.xml</secondary></indexterm>
        
        <para>
            All Seam applications use JSF views as the presentation layer. So we'll need
            <literal>faces-config.xml</literal>.
        </para>
        
        <example id="registration-faces-config-xml">
          <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE faces-config 
PUBLIC "-//Sun Microsystems, Inc.//DTD JavaServer Faces Config 1.0//EN"
                            "http://java.sun.com/dtd/web-facesconfig_1_0.dtd">
<faces-config>

    <navigation-rule>
        <navigation-case>
            <from-outcome>success</from-outcome>
            <to-view-id>/registered.jsp</to-view-id>
        </navigation-case>
    </navigation-rule>

    <!-- Same for all Seam applications -->
    
    <application>
        <variable-resolver>org.jboss.seam.jsf.SeamVariableResolver</variable-resolver>
    </application>
    
    <lifecycle>
        <phase-listener>org.jboss.seam.jsf.SeamPhaseListener</phase-listener>
    </lifecycle>

</faces-config>]]></programlisting>
        </example>
        
        <indexterm><primary>variable resolver</primary></indexterm>
        <indexterm><primary>phase listener</primary></indexterm>
        
        <para>
            The <literal>jsf-config.xml</literal> file integrates Seam into JSF and specifies the 
            single navigation rule for our registration application. Note that there are no managed 
            bean declarations (they are not needed with Seam). The managed beans are the Seam 
            components. In Seam applications, the <literal>jsf-config.xml</literal> is used only 
            for specifying the page flow by mapping logical JSF outcome names to view pages.
        </para>
        
        <para>
            In fact, once you have all the basic descriptors set up, the <emphasis>only</emphasis>
            XML you need to write as you add new functionality to a Seam application is the navigation
            rules, and possibly jBPM process definitions. Seam takes the view that 
            <emphasis>process flow</emphasis> and <emphasis>configuration data</emphasis> are the only 
            things that truly belong in XML.
        </para>
        
      </section>
      
      <section>
        <title>The view: <literal>register.jsp</literal> and <literal>registered.jsp</literal></title>
        
        <para>
            The view pages for a Seam application could be implemented using any technology that
            supports JSF. In this example we use JSP, since it is familiar to most developers
            and since we have minimal requirements here anyway. (But if you take our advice, you'll 
            use Facelets for your own applications.)
        </para>
        
        <example id="registration-simpleform">
          <programlisting><![CDATA[<%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %>
<%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %>
<html>
 <head>
  <title>Register New User</title>
 </head>
 <body>
  <f:view>
   <h:form>
     <table border="0">
       <tr>
         <td>Username</td>
         <td><h:inputText value="#{user.username}"/></td>
       </tr>
       <tr>
         <td>Real Name</td>
         <td><h:inputText value="#{user.name}"/></td>
       </tr>
       <tr>
         <td>Password</td>
         <td><h:inputSecret value="#{user.password}"/></td>
       </tr>
     </table>
     <h:messages/>
     <h:commandButton type="submit" value="Register" action="#{register.register}"/>
   </h:form>
  </f:view>
 </body>
</html>]]></programlisting>
        </example>
        
        <example id="registration-simplepage">
          <programlisting><![CDATA[<%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %>
<%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %>
<html>
 <head>
  <title>Successfully Registered New User</title>
 </head>
 <body>
  <f:view>
    Welcome, <h:outputText value="#{user.name}"/>, 
    you are successfully registered as <h:outputText value="#{user.username}"/>.
  </f:view>
 </body>
</html>]]></programlisting>
        </example>        
        
        
        <para>
            These are boring old JSP pages using standard JSF components. There is
            nothing specific to Seam here.
        </para>

      </section>

      <section>
        <title>The EAR deployment descriptor: <literal>application.xml</literal></title>
        
        <indexterm><primary>application.xml</primary></indexterm>
        <indexterm><primary>descriptor file</primary><secondary>application.xml</secondary></indexterm>
        
        <para>
            Finally, since our application is deployed as an EAR, we need a deployment descriptor
            there, too.
        </para>
        
        <example id="registration-application-xml">
          <programlisting><![CDATA[<application>
    <display-name>Seam</display-name>

    <module>
        <web>
            <web-uri>jboss-seam-registration.war</web-uri>
            <context-root>/seam-registration</context-root>
        </web>
    </module>
    <module>
        <ejb>jboss-seam-registration.ejb3</ejb>
    </module>
    
</application>]]></programlisting>
        </example>
        
        <para>
            This deployment descriptor links modules in the enterprise archive and binds the web application 
            to the context root <literal>/seam-registration</literal>.
        </para>
        
      </section>
              
        <para>
            We've now seen <emphasis>all</emphasis> the files in the entire application!
        </para>
    
    </section>
    
    <section>
      <title>How it works</title>

      <para>
          When the form is submitted, JSF asks Seam to resolve the variable named
          <literal>user</literal>. Since there is no value already bound to that
          name (in any Seam context), Seam instantiates the <literal>user</literal>
          component, and returns the resulting <literal>User</literal> entity
          bean instance to JSF after storing it in the Seam session context. JSF 
          binds the form input values to properties of the <literal>User</literal> 
          entity bean.
      </para>
      <para>
          Next, JSF asks Seam to resolve the variable named <literal>register</literal>.
          Seam finds the <literal>RegisterAction</literal> stateless session bean
          in the stateless context and returns it. JSF invokes the <literal>register()</literal>
          action listener method.
      </para>
      <para>
          Seam intercepts the method call, injects the <literal>User</literal> entity
          from the session context, and the current <literal>FacesContext</literal> 
          instance, before asking Hibernate Validator to validate the session bean 
          instance (and, recursively, the <literal>User</literal> entity bean instance).
          If the state is valid, the invocation proceeds and the 
          <literal>register()</literal> method is called. If not, Seam returns a 
          <literal>null</literal> outcome and JSF redisplays the page.
      </para>
      <para>
          When JSF comes to render the next JSP page, it asks Seam to resolve the
          variable named <literal>user</literal> and uses property values of the 
          returned <literal>User</literal> entity from Seam's session scope.
      </para>

      <indexterm startref="registration-example-range" class="endofrange"/>

    </section>

  </section>

  <section id="booking">
    <title>A complete Seam application: the booking example</title>
    
    <indexterm id="booking-example" class="start-of-range">
        <primary>example</primary><secondary>Booking example</secondary>
    </indexterm>
    
    <section>
      <title>Introduction</title>
      
      <para>
          The booking application is a complete hotel room reservation system
          incorporating the following features: 
      </para>
      
      <itemizedlist>
        <listitem>
          <para>User registration</para>
        </listitem>
        <listitem>
          <para>Login</para>
        </listitem>
        <listitem>
          <para>Logout</para>
        </listitem>
        <listitem>
          <para>Set password</para>
        </listitem>
        <listitem>
          <para>Hotel search</para>
        </listitem>
        <listitem>
          <para>Hotel selection</para>
        </listitem>
        <listitem>
          <para>Room reservation</para>
        </listitem>
        <listitem>
          <para>Reservation confirmation</para>
        </listitem>
        <listitem>
          <para>Existing reservation list</para>
        </listitem>
          </itemizedlist>
          
      <screenshot>
        <screeninfo>Booking example</screeninfo>
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="images/booking.png" align="center"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="../shared/images/booking.png" align="center"/>
          </imageobject>
        </mediaobject>
      </screenshot>
      
      <para>
          The booking application uses JSF, EJB 3.0 and Seam, together with Facelets for the
          view. There is also a port of this application to JSF, Facelets, Seam, JavaBeans
          and Hibernate3.
      </para>

      <para>
          One of the things you'll notice if you play with this application for long enough
          is that it is extremely <emphasis>robust</emphasis>. You can play with back buttons
          and browser refresh and opening multiple windows and entering nonsensical data as 
          much as you like and you will find it very difficult to make the application crash. 
          You might think that we spent weeks testing and fixing bugs to achive this. Actually, 
          this is not the case. Seam was designed to make it very straightforward to build
          robust web applications and a lot of robustness that you are probably used to having to
          code yourself comes naturally and automatically with Seam.
      </para>
      <para>
          As you browse the sourcecode of the example application, and learn how the application
          works, observe how the declarative state management and integrated validation has been
          used to achieve this robustness.
      </para>
      
    </section>
    
    <section>
      <title>Overview of the booking example</title>

      <para>
          The project structure is identical to the previous one, to install and deploy this
          application, please refer to <xref linkend="try-examples"/>. Just ten classes (plus six 
          session beans local interfaces and 1 annotation interface) where used to implement 
          this application. 
      </para>
      
      <para>
          Six session bean action listeners contain all the business logic for the listed features.
      </para>
      
      <itemizedlist>
          <listitem>
              <literal>BookingListAction</literal> retrieves existing bookings for the currently
              logged in user.
          </listitem>
          <listitem>
              <literal>ChangePasswordAction</literal> updates the password of the currently logged
              in user.
          </listitem>
          <listitem>
              <literal>HotelBookingAction</literal> implements the core functionality of the application:
              hotel room searching, selection, booking and booking confirmation. This functionality is
              implemented as a <emphasis>conversation</emphasis>, so this is the most interesting class
              in the application. 
          </listitem>
          <listitem>
              <literal>LoginAction</literal> validates the login details and retrieves the logged 
              in user.
          </listitem>
          <listitem>
              <literal>LogoutAction</literal> ends the login session.
          </listitem>
          <listitem>
              <literal>RegisterAction</literal> registers a new system user.
          </listitem>
      </itemizedlist> 
                
      <para>
          Three entity beans implement the application's persistent domain model.
      </para>
      
      <itemizedlist>
          <listitem>
              <literal>Hotel</literal> is an entity bean that represent a hotel
          </listitem>
          <listitem>
              <literal>Booking</literal> is an entity bean that represents an existing booking
          </listitem>
          <listitem>
              <literal>User</literal> is an entity bean to represents a user who can make 
              hotel bookings
          </listitem>
      </itemizedlist>
      
      <para>
          Finally, the <literal>LoggedIn</literal> annotation and the <literal>LoggedInInterceptor</literal>
          are used to protect actions that require a logged in user.
      </para>
      
    </section>
    
    <section>
        <title>Understanding Seam conversations</title>
        <para>
            We encourage you browse the sourcecode at your pleasure. In this tutorial we'll concentrate
            upon one particular piece of functionality: hotel search, selection, booking and confirmation.
            From the point of view of the user, this is one continuous unit of work, a 
            <emphasis>conversation</emphasis>. 
        </para>
        <para>
            Most web application architectures have no first class construct to represent a conversation. 
            This causes enormous problems managing state associated with the conversation. Usually, Java 
            web applications use a combination of two techniques: first, some state is thrown into the 
            <literal>HttpSession</literal>; second, persistable state is flushed to the database after 
            every request, and reconstructed from the database at the beginning of each new request. 
        </para>
        <para>
            Since the database is the least scalable tier, this often results in an utterly unacceptable 
            lack of scalability. Added latency is also a problem, due to the extra traffic to and from the 
            database on every request. To reduce this redundant traffic, Java applications often introduce 
            a data (second-level) cache that keeps commonly accessed data between requests. This cache is 
            necessarily inefficient, because invalidation is based upon an LRU policy instead of being based 
            upon when the user has finished working with the data. Furthermore, because the cache is shared 
            between many concurrent transactions, we've introduced a whole raft of problem's associated with 
            keeping the cached state consistent with the database.
        </para>
        <para>
            Now consider the state held in the <literal>HttpSession</literal>. By very careful programming, 
            we might be able to control the size of the session data. This is a lot difficult than it sounds, 
            since web browsers permit ad hoc non-linear navigation. But suppose we suddenly discover a system 
            requirement that says that a user is allowed to have <emphasis>mutiple concurrent conversations</emphasis>,
            halfway through the development of the system (this has happened to me). Developing mechanisms
            to isolate session state associated with different concurrent conversations, and incorporating
            failsafes to ensure that conversation state is destroyed when the user aborts one of the 
            conversations by closing a browser window or tab is not for the faint hearted (I've implemented 
            this stuff twice so far, once for a client application, once for Seam, but I'm famously
            psychotic).
        </para>
        <para>
            Now there is a better way.
        </para>
        <para>
            Seam introduces the <emphasis>conversation context</emphasis> as a first class construct. You
            can safely keep conversational state in this context, and be assured that it will have a 
            well-defined lifecycle. Even better, you won't need to be continually pushing data back and 
            forth between the application server and the database, since the conversation context is a
            natural cache of data that the user is currently working with.
        </para>
        <para>
            Usually, the components we keep in the conversation context are stateful session beans. (We 
            can also keep entity beans and JavaBeans in the conversation context.) There is an ancient
            canard in the Java community that stateful session beans are a scalability killer. This may
            have been true in 1998 when WebFoobar 1.0 was released. It is no longer true today.
            Application servers like JBoss 4.0 have extremely sophisticated mechanisms for stateful
            session bean state replication. (For example, the JBoss EJB3 container performs fine-grained
            replication, replicating only those bean attribute values which actually changed.) Note 
            that all the traditional technical arguments for why stateful beans are inefficient apply
            equally to the <literal>HttpSession</literal>, so the practice of shifting state from business 
            tier stateful session bean components to the web session to try and improve performance is 
            unbelievably misguided. It is certainly possible to write unscalable applications using 
            stateful session beans, by using stateful beans incorrectly, or by using them for the wrong 
            thing. But that doesn't mean you should <emphasis>never</emphasis> use them. Anyway, Seam 
            guides you toward a safe usage model. Welcome to 2005.
        </para>
        <para>
            OK, I'll stop ranting now, and get back to the tutorial.
        </para>
        <para>
            Let's see how the booking example application uses a conversation-scoped stateful session
            bean to achieve a natural cache of persistent data related to the conversation.
        </para>
        
        <example>
            <programlistingco>
                <areaspec>
                    <area id="registration-stateful-annotation" coords="1"/>
                    <area id="registration-conversational-annotation" coords="4"/>
                    <area id="registration-custom-annotation" coords="5"/>
                    <area id="registration-out-annotation" coords="16"/>
                    <area id="registration-begin-annotation" coords="34"/>
                    <area id="registration-end-annotation" coords="121"/>
                    <area id="registration-remove-annotation" coords="121"/>
                    <area id="registration-destroy-annotation" coords="130"/>
                </areaspec>    
            <programlisting><![CDATA[@Stateful
@Name("hotelBooking")
@Interceptor(SeamInterceptor.class)
@Conversational(ifNotBegunOutcome="main")
@LoggedIn
public class HotelBookingAction implements HotelBooking, Serializable
{
   private static final Logger log = Logger.getLogger(HotelBooking.class);
   
   @In(create=true)
   private EntityManager bookingDatabase;
   
   private String searchString;
   private List<Hotel> hotels;
   
   @Out(required=false)
   private Hotel hotel;
   
   @In(required=false) 
   @Out(required=false)
   @Valid
   private Booking booking;
   
   @In
   private User user;
   
   @Out
   private DataModel hotelsDataModel = new ListDataModel();
   int rowIndex = 0;
   
   @In
   private FacesContext facesContext;

   @Begin
   public String find()
   {
      hotel = null;
      String searchPattern = searchString==null ? "%" : '%' + searchString.toLowerCase().replace('*', '%') + '%';
      hotels = bookingDatabase.createQuery("from Hotel where lower(city) like :search or lower(zip) like :search or lower(address) like :search")
            .setParameter("search", searchPattern)
            .setMaxResults(50)
            .getResultList();
      
      log.info(hotels.size() + " hotels found");
      
      hotelsDataModel.setWrappedData(hotels);
      
      return "main";
   }
   
   public String getSearchString()
   {
      return searchString;
   }

   public void setSearchString(String searchString)
   {
      this.searchString = searchString;
   }
   
   public String selectHotel()
   {
      rowIndex = hotelsDataModel.getRowIndex();
      setHotel();
      return "selected";
   }

   public String nextHotel()
   {
      if ( rowIndex<hotels.size()-1 )
      {
         hotelsDataModel.setRowIndex(++rowIndex);
         setHotel();
      }
      return null;
   }

   public String lastHotel()
   {
      if (rowIndex>0)
      {
         hotelsDataModel.setRowIndex(--rowIndex);
         setHotel();
      }
      return null;
   }

   private void setHotel()
   {
      hotel = (Hotel) hotelsDataModel.getRowData();
      log.info( rowIndex + "=>" + hotel );
   }
   
   public String bookHotel()
   {
      if (hotel==null) return "main";
      booking = new Booking(hotel, user);
      booking.setCheckinDate( new Date() );
      booking.setCheckoutDate( new Date() );
      return "book";
   }
   
   @IfInvalid(outcome=REDISPLAY)
   public String setBookingDetails()
   {
      if (booking==null || hotel==null) return "main";
      if ( !booking.getCheckinDate().before( booking.getCheckoutDate() ) )
      {
         log.info("invalid booking dates");
         FacesMessage facesMessage = new FacesMessage("Check in date must be later than check out date");
         facesContext.addMessage(null, facesMessage);
         return null;
      }
      else
      {
         log.info("valid booking");
         return "success";
      }
   }
      
   @End @Remove 
   public String confirm()
   {
      if (booking==null || hotel==null) return "main";
      bookingDatabase.persist(booking);
      log.info("booking confirmed");
      return "confirmed";
   }
      
   @Destroy @Remove
   public void destroy() {
      log.info("destroyed");
   }
   
   @PrePassivate
   public void passivate()
   {
      hotelsDataModel = null;
   }
   
   @PostActivate
   public void activate()
   {
      hotelsDataModel = new ListDataModel();
      hotelsDataModel.setWrappedData(hotels);
      hotelsDataModel.setRowIndex(rowIndex);
   }
}]]></programlisting>                    
            <calloutlist>
                <callout arearefs="registration-stateful-annotation">
                    <para>
                        The EJB standard <literal>@Stateful</literal> annotation identifies
                        this class as a stateful session bean. Stateful session beans are
                        scoped to the conversation context by default.
                    </para>
                </callout>
                <callout arearefs="registration-conversational-annotation">
                    <para>
                        The Seam <link linkend="conversational-annotation"><literal>@Conversational</literal></link> 
                        annotation declares this as a <emphasis>conversational</emphasis> component that cannot be 
                        invoked outside of a long-running conversation that was started by a call to its 
                        <literal>@Begin</literal> method. If such an invocation does occur, Seam returns the
                        <literal>ifNotBegunOutcome</literal> to JSF.
                    </para>
                </callout>
                <callout arearefs="registration-custom-annotation">
                    <para>
                        The <literal>@LoggedIn</literal> annotation applies a custom Seam interceptor
                        to the component. This works because <literal>@LoggedIn</literal> is marked
                        with an <literal>@Interceptor</literal> meta-annotation.
                    </para>
                </callout>
                <callout arearefs="registration-out-annotation">
                    <para>
                        The <link linkend="out-annotation"><literal>@Out</literal></link> annotation
                        declares that an attribute value is <emphasis>outjected</emphasis> to a
                        context variable after method invocations. In this case, the context variable
                        named <literal>hotel</literal> will be set to the value of the 
                        <literal>hotel</literal> instance variable after every action listener
                        invocation completes.
                    </para>
                </callout>
                <callout arearefs="registration-begin-annotation">
                    <para>
                        The <link linkend="begin-annotation"><literal>@Begin</literal></link> annotation
                        specifies that the annotated method begins a 
                        <emphasis>long-running conversation</emphasis>, so the current conversation context
                        will not be destroyed at the end of the request. Instead, it will be reassociated
                        with every request from the current window, and destroyed either by timeout due to
                        conversation inactivity or invocation of a matching <literal>@End</literal> method.
                    </para>
                </callout>
                <callout arearefs="registration-end-annotation">
                    <para>
                        The <link linkend="end-annotation"><literal>@End</literal></link> annotation
                        specifies that the annotated method ends the current long-running conversation, 
                        so the current conversation context be destroyed at the end of the request.
                    </para>
                </callout>
                <callout arearefs="registration-remove-annotation">
                    <para>
                        The EJB standard <literal>@Remove</literal> annotation specifies that a stateful
                        session bean should be removed and its state destroyed after invocation of the
                        annotated method. We don't really need it here, since the conversation context
                        is about to end and Seam is about to call the <literal>@Destroy</literal>
                        method.
                    </para>
                </callout>
                <callout arearefs="registration-destroy-annotation">
                    <para>
                        All stateful session beans should define a method marked 
                        <literal>@Destroy @Remove</literal>. This is the EJB remove method that will
                        be called when Seam destroys the conversation context. Actually, the
                        <link linkend="destroy-annotation"><literal>@Destroy</literal></link> 
                        annotation is of more general usefulness, since it can be used for any 
                        kind of cleanup that should happen when any Seam context ends.
                    </para>
                </callout>
            </calloutlist>
            </programlistingco>
        </example>
        
        <para>
            <literal>HotelBookingAction</literal> contains all the action listener methods that implement 
            hotel searching, selection, booking and booking confirmation, and holds state related to
            this work in its instance variables. We think you'll agree that this code is much cleaner
            and simpler than getting and setting <literal>HttpSession</literal> attributes.
        </para>
        <para>
            Even better, a user can have multiple isolated conversations per login session. Try it!
            Log in, and open the hotel search page in multiple browser tabs. You'll be able to work
            on creating two different hotel reservations at the same time. If you leave any one
            conversation inactive for long enough, Seam will eventually time out that conversation
            and destroy its state.
        </para>
    </section>

    <indexterm startref="booking-example" class="endofrange"/>

  </section>

  <section id="dvdstore">
      <title>A complete Seam application: the DVD store example</title>
      <para>TODO</para>
  </section>
  
</chapter>
