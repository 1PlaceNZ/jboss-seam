<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % RH_ENTITIES SYSTEM "Common_Content/Entities.ent">
%RH_ENTITIES;
<!ENTITY % RH_TRANS_ENTITIES SYSTEM "Common_Content/Translatable-Entities.ent">
%RH_TRANS_ENTITIES;
]>

<chapter id="tutorial">
	<title>Seam Tutorial</title>
	<section id="try-examples">
		<title>Try the examples</title>
		<para>
			In this tutorial, we&#39;ll assume that you have downloaded JBoss AS 4.2. You should also have a copy of Seam downloaded and extracted to a work directory.
		</para>
		<para>
			The directory structure of each example in Seam follows this pattern:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					Web pages, images and stylesheets may be found in <filename>examples/<replaceable>registration</replaceable>/view</filename>
				</para>
			</listitem>
			<listitem>
				<para>
					Resources such as deployment descriptors and data import scripts may be found in <filename>examples/<replaceable>registration</replaceable>/resources</filename>
				</para>
			</listitem>
			<listitem>
				<para>
					Java source code may be found in <filename>examples/<replaceable>registration</replaceable>/src</filename>
				</para>
			</listitem>
			<listitem>
				<para>
					The Ant build script is <filename>examples/<replaceable>registration</replaceable>/build.xml</filename>
				</para>
			</listitem>
		</itemizedlist>
		<section>
			<title>Running the examples on JBoss AS</title>
			<para>
				First, make sure you have Ant correctly installed, with <literal>$ANT_HOME</literal> and <literal>$JAVA_HOME</literal> set correctly. Next, make sure you set the location of your JBoss AS 4.2 installation in the <literal>build.properties</literal> file in the root folder of your Seam installation. If you haven&#39;t already done so, start JBoss AS now by typing <literal>bin/run.sh</literal> or <literal>bin/run.bat</literal> in the root directory of your JBoss installation.
			</para>
			<para>
				Now, build and deploy the example by typing <literal>ant deploy</literal> in the <filename>examples/<replaceable>registration</replaceable></filename> directory.
			</para>
			<para>
				Try it out by accessing <ulink url="http://localhost:8080/seam-registration/"><literal>http://localhost:8080/seam-registration/</literal></ulink> with your web browser.
			</para>
		</section>
		
		<section>
			<title>Running the examples on Tomcat</title>
			<para>
				First, make sure you have Ant correctly installed, with <literal>$ANT_HOME</literal> and <literal>$JAVA_HOME</literal> set correctly. Next, make sure you set the location of your Tomcat 6.0 installation in the <literal>build.properties</literal> file in the root folder of your Seam installation. You will need to follow the instructions in <xref linkend="config.install.embedded" /> for installing JBoss Embedded on Tomcat 6.0. JBoss Embedded is required to run the Seam demo applications on Tomcat. (However, it is possible to use Seam on Tomcat without JBoss Embedded.)
			</para>
			<para>
				Now, build and deploy the example by typing <literal>ant tomcat.deploy</literal> in the <filename>examples/<replaceable>registration</replaceable></filename> directory.
			</para>
			<para>
				Finally, start Tomcat.
			</para>
			<para>
				Try it out by accessing <ulink url="http://localhost:8080/jboss-seam-registration/"><literal>http://localhost:8080/jboss-seam-registration/</literal></ulink> with your web browser.
			</para>
			<para>
				When you deploy the example to Tomcat, any EJB3 components will run inside the JBoss Embeddable EJB3 container, a complete standalone EJB3 container environment.
			</para>
		</section>
		
		<section>
			<title>Running the example tests</title>
			<para>
				Most of the examples come with a suite of TestNG integration tests. The easiest way to run the tests is to run <literal>ant testexample</literal> inside the <filename>examples/<replaceable>registration</replaceable></filename> directory. It is also possible to run the tests inside your IDE using the TestNG plugin.
			</para>
		</section>

	</section>
	
	<section id="registration-example">
		<title>Your first Seam application: the registration example</title>
		<para>
			The registration example is a fairly trivial application that lets a new user store his username, real name and password in the database. The example isn&#39;t intended to show off all of the cool functionality of Seam. However, it demonstrates the use of an EJB3 session bean as a JSF action listener, and basic configuration of Seam.
		</para>
		<para>
			We&#39;ll go slowly, since we realize you might not yet be familiar with EJB 3.0.
		</para>
		<para>
			The start page displays a very basic form with three input fields. Try filling them in and then submitting the form. This will save a user object in the database.
		</para>
		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="/images/registration.png" />
			</imageobject>
			<imageobject role="html">
				<imagedata align="center" fileref="/images/registration.png" />
			</imageobject>
		</mediaobject>
		<section>
			<title>Understanding the code</title>
			<para>
				The example is implemented with two JSP pages, one entity bean and one stateless session bean.
			</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata align="center" fileref="/images/register.png" />
				</imageobject>
				<imageobject role="html">
					<imagedata align="center" fileref="/images/register.png" />
				</imageobject>
			</mediaobject>
			<para>
				Let&#39;s take a look at the code, starting from the "bottom".
			</para>
			<section>
				<title>The entity bean: <literal>User.java</literal></title>
				<para>
					We need an EJB entity bean for user data. This class defines <emphasis>persistence</emphasis> and <emphasis>validation</emphasis> declaratively, via annotations. It also needs some extra annotations that define the class as a Seam component.
				</para>
				<example>
					<title>user data</title>
					<programlistingco>
						<areaspec>
							<area coords="1" id="registration-entity-annotation" />
							<area coords="2" id="registration-name-annotation" />
							<area coords="3" id="registration-scope-annotation" />
							<area coords="4" id="registration-table-annotation" />
							<area coords="9" id="registration-attributes" />
							<area coords="20" id="registration-empty-constructor" />
							<area coords="22" id="registration-notnull" />
							<area coords="44" id="registration-id-annotation" />
						</areaspec>
<programlisting>@Entity
@Name("user")
@Scope(SESSION)
@Table(name="users")
public class User implements Serializable
{
   private static final long serialVersionUID = 1881413500711441951L;
   
   private String username;
   private String password;
   private String name;
   
   public User(String name, String password, String username)
   {
      this.name = name;
      this.password = password;
      this.username = username;
   }
   
   public User() {}
   
   @NotNull @Length(min=5, max=15)
   public String getPassword()
   {
      return password;
   }

   public void setPassword(String password)
   {
      this.password = password;
   }
   
   @NotNull
   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
   
   @Id @NotNull @Length(min=5, max=15)
   public String getUsername()
   {
      return username;
   }

   public void setUsername(String username)
   {
      this.username = username;
   }

}
</programlisting>
						<calloutlist>
							<callout arearefs="registration-entity-annotation">
								<para>
									The EJB3 standard <literal>@Entity</literal> annotation indicates that the <literal>User</literal> class is an entity bean.
								</para>
							</callout>
							<callout arearefs="registration-name-annotation">
								<para>
									A Seam component needs a <emphasis>component name</emphasis> specified by the <link linkend="name-annotation"><literal>@Name</literal></link> annotation. This name must be unique within the Seam application. When JSF asks Seam to resolve a context variable with a name that is the same as a Seam component name, and the context variable is currently undefined (null), Seam will instantiate that component, and bind the new instance to the context variable. In this case, Seam will instantiate a <literal>User</literal> the first time JSF encounters a variable named <literal>user</literal>.
								</para>
							</callout>
							<callout arearefs="registration-scope-annotation">
								<para>
									Whenever Seam instantiates a component, it binds the new instance to a context variable in the component&#39;s <emphasis>default context</emphasis>. The default context is specified using the <link linkend="scope-annotation"><literal>@Scope</literal></link> annotation. The <literal>User</literal> bean is a session scoped component.
								</para>
							</callout>
							<callout arearefs="registration-table-annotation">
								<para>
									The EJB standard <literal>@Table</literal> annotation indicates that the <literal>User</literal> class is mapped to the <literal>users</literal> table.
								</para>
							</callout>
							<callout arearefs="registration-attributes">
								<para>
									<literal>name</literal>, <literal>password</literal> and <literal>username</literal> are the persistent attributes of the entity bean. All of our persistent attributes define accessor methods. These are needed when this component is used by JSF in the render response and update model values phases.
								</para>
							</callout>
							<callout arearefs="registration-empty-constructor">
								<para>
									An empty constructor is both required by both the EJB specification and by Seam.
								</para>
							</callout>
							<callout arearefs="registration-notnull">
								<para>
									The <literal>@NotNull</literal> and <literal>@Length</literal> annotations are part of the Hibernate Validator framework. Seam integrates Hibernate Validator and lets you use it for data validation (even if you are not using Hibernate for persistence).
								</para>
							</callout>
							<callout arearefs="registration-id-annotation">
								<para>
									The EJB standard <literal>@Id</literal> annotation indicates the primary key attribute of the entity bean.
								</para>
							</callout>
						</calloutlist>
					</programlistingco>
					
					<para>
						The most important things to notice in this example are the <literal>@Name</literal> and <literal>@Scope</literal> annotations. These annotations establish that this class is a Seam component.
					</para>
					<para>
						We&#39;ll see below that the properties of our <literal>User</literal> class are bound to directly to JSF components and are populated by JSF during the update model values phase. We don&#39;t need any tedious glue code to copy data back and forth between the JSP pages and the entity bean domain model.
					</para>
					<para>
						However, entity beans shouldn&#39;t do transaction management or database access. So we can&#39;t use this component as a JSF action listener. For that we need a session bean.
					</para>
				</example>
			</section>
			
			<section>
				<title>The stateless session bean class: <literal>RegisterAction.java</literal></title>
				<para>
					Most Seam application use session beans as JSF action listeners (you can use JavaBeans instead if you like).
				</para>
				<para>
					We have exactly one JSF action in our application, and one session bean method attached to it. In this case, we&#39;ll use a stateless session bean, since all the state associated with our action is held by the <literal>User</literal> bean.
				</para>
				<para>
					This is the only really interesting code in the example!
				</para>
				<example>
					<title></title>
					<programlistingco>
						<areaspec>
							<area coords="1" id="registration-stateless-annotation" />
							<area coords="6" id="registration-in-annotation" />
							<area coords="9" id="registration-persistencecontext-annotation" />
							<area coords="12" id="registration-logger-annotation" />
							<area coords="15" id="registration-action-listener" />
							<area coords="18" id="registration-query" />
							<area coords="24" id="registration-log" />
							<area coords="25" id="registration-outcome" />
							<area coords="29" id="registration-builtin" />
						</areaspec>
<programlisting>@Stateless
@Name("register")
public class RegisterAction implements Register
{

   @In
   private User user;
   
   @PersistenceContext
   private EntityManager em;
   
   @Logger
   private Log log;
   
   public String register()
   {
      List existing = em.createQuery(
         "select username from User where username=#{user.username}")
         .getResultList();
         
      if (existing.size()==0)
      {
         em.persist(user);
         log.info("Registered new user #{user.username}");
         return "/registered.xhtml";
      }
      else
      {
         FacesMessages.instance().add("User #{user.username} already exists");
         return null;
      }
   }

}
</programlisting>
						<calloutlist>
							<callout arearefs="registration-stateless-annotation">
								<para>
									The EJB standard <literal>@Stateless</literal> annotation marks this class as stateless session bean.
								</para>
							</callout>
							<callout arearefs="registration-in-annotation">
								<para>
									The <link linkend="in-annotation"><literal>@In</literal></link> annotation marks an attribute of the bean as injected by Seam. In this case, the attribute is injected from a context variable named <literal>user</literal> (the instance variable name).
								</para>
							</callout>
							<callout arearefs="registration-persistencecontext-annotation">
								<para>
									The EJB standard <literal>@PersistenceContext</literal> annotation is used to inject the EJB3 entity manager.
								</para>
							</callout>
							<callout arearefs="registration-logger-annotation">
								<para>
									The Seam <literal>@Logger</literal> annotation is used to inject the component&#39;s <literal>Log</literal> instance.
								</para>
							</callout>
							<callout arearefs="registration-action-listener">
								<para>
									The action listener method uses the standard EJB3 <literal>EntityManager</literal> API to interact with the database, and returns the JSF outcome. Note that, since this is a sesson bean, a transaction is automatically begun when the <literal>register()</literal> method is called, and committed when it completes.
								</para>
							</callout>
							<callout arearefs="registration-query">
								<para>
									Notice that Seam lets you use a JSF EL expression inside EJB-QL. Under the covers, this results in an ordinary JPA <literal>setParameter()</literal> call on the standard JPA <literal>Query</literal> object. Nice, huh?
								</para>
							</callout>
							<callout arearefs="registration-log">
								<para>
									The <literal>Log</literal> API lets us easily display templated log messages.
								</para>
							</callout>
							<callout arearefs="registration-outcome">
								<para>
									JSF action listener methods return a string-valued outcome that determines what page will be displayed next. A null outcome (or a void action listener method) redisplays the previous page. In plain JSF, it is normal to always use a JSF <emphasis>navigation rule</emphasis> to determine the JSF view id from the outcome. For complex application this indirection is useful and a good practice. However, for very simple examples like this one, Seam lets you use the JSF view id as the outcome, eliminating the requirement for a navigation rule. <emphasis>Note that when you use a view id as an outcome, Seam always performs a browser redirect.</emphasis>
								</para>
							</callout>
							<callout arearefs="registration-builtin">
								<para>
									Seam provides a number of <emphasis>built-in components</emphasis> to help solve common problems. The <literal>FacesMessages</literal> component makes it easy to display templated error or success messages. Built-in Seam components may be obtained by injection, or by calling an <literal>instance()</literal> method.
								</para>
							</callout>
						</calloutlist>
					</programlistingco>
					
					<para>
						Note that we did not explicitly specify a <literal>@Scope</literal> this time. Each Seam component type has a default scope if not explicitly specified. For stateless session beans, the default scope is the stateless context. Actually, <emphasis>all</emphasis> stateless session beans belong in the stateless context.
					</para>
					<para>
						Our session bean action listener performs the business and persistence logic for our mini-application. In more complex applications, we might need to layer the code and refactor persistence logic into a dedicated data access component. That&#39;s perfectly trivial to do. But notice that Seam does not force you into any particular strategy for application layering.
					</para>
					<para>
						Furthermore, notice that our session bean has simultaneous access to context associated with the web request (the form values in the <literal>User</literal> object, for example), and state held in transactional resources (the <literal>EntityManager</literal> object). This is a break from traditional J2EE architectures. Again, if you are more comfortable with the traditional J2EE layering, you can certainly implement that in a Seam application. But for many applications, it&#39;s simply not very useful.
					</para>
				</example>
			</section>
			
			<section>
				<title>The session bean local interface: <literal>Register.java</literal></title>
				<para>
					Naturally, our session bean needs a local interface.
				</para>
				<example>
					<title></title>
<programlisting>@Local
public interface Register
{
   public String register();
}
</programlisting>
				</example>
				<para>
					That&#39;s the end of the Java code. Now onto the deployment descriptors.
				</para>
			</section>
			
			<section>
				<title>The Seam component deployment descriptor: <literal>components.xml</literal></title>
				<para>
					If you&#39;ve used many Java frameworks before, you&#39;ll be used to having to declare all your component classes in some kind of XML file that gradually grows more and more unmanageable as your project matures. You&#39;ll be relieved to know that Seam does not require that application components be accompanied by XML. Most Seam applications require a very small amount of XML that does not grow very much as the project gets bigger.
				</para>
				<para>
					Nevertheless, it is often useful to be able to provide for <emphasis>some</emphasis> external configuration of <emphasis>some</emphasis> components (particularly the components built in to Seam). You have a couple of options here, but the most flexible option is to provide this configuration in a file called <literal>components.xml</literal>, located in the <literal>WEB-INF</literal> directory. We&#39;ll use the <literal>components.xml</literal> file to tell Seam how to find our EJB components in JNDI:
				</para>
				<example>
					<title></title>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;components xmlns="http://jboss.com/products/seam/components"
            xmlns:core="http://jboss.com/products/seam/core"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation=
                "http://jboss.com/products/seam/core http://jboss.com/products/seam/core-2.1.xsd 
                 http://jboss.com/products/seam/components http://jboss.com/products/seam/components-2.1.xsd"&gt;
            
     &lt;core:init jndi-pattern="@jndiPattern@"/&gt;
     
&lt;/components&gt;
</programlisting>
				</example>
				<para>
					This code configures a property named <literal>jndiPattern</literal> of a built-in Seam component named <literal>org.jboss.seam.core.init</literal>. The funny <literal>@</literal> symbols are there because our Ant build script puts the correct JNDI pattern in when we deploy the application.
				</para>
			</section>
			
			<section>
				<title>The web deployment description: <literal>web.xml</literal></title>
				<para>
					The presentation layer for our mini-application will be deployed in a WAR. So we&#39;ll need a web deployment descriptor.
				</para>
				<example>
					<title>web deployment descriptor config</title>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.5"
    xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;

    &lt;!-- Seam --&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.jboss.seam.servlet.SeamListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- JSF --&gt;
              
    &lt;listener&gt;
        &lt;listener-class&gt;com.sun.faces.config.ConfigureListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    
    &lt;context-param&gt;
        &lt;param-name&gt;javax.faces.DEFAULT_SUFFIX&lt;/param-name&gt;
        &lt;param-value&gt;.xhtml&lt;/param-value&gt;
    &lt;/context-param&gt;
              
    &lt;servlet&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.seam&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
              
    &lt;session-config&gt;
        &lt;session-timeout&gt;10&lt;/session-timeout&gt;
    &lt;/session-config&gt;

&lt;/web-app&gt;
</programlisting>
				</example>
				<para>
					This <literal>web.xml</literal> file configures Seam and JSF. The configuration you see here is pretty much identical in all Seam applications.
				</para>
			</section>
			
			<section>
				<title>The JSF configration: <literal>faces-config.xml</literal></title>
				<para>
					Most Seam applications use JSF views as the presentation layer. So usually we&#39;ll need <literal>faces-config.xml</literal>. In our case, we are going to use Facelets for defining our views, so we need to tell JSF to use Facelets as its templating engine.
				</para>
				<example id="registration-faces-config-xml">
					<title>registration faces configuration</title>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;faces-config version="1.2"
              xmlns="http://java.sun.com/xml/ns/javaee"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-facesconfig_1_2.xsd"&gt;

    &lt;!-- Facelets support --&gt;
    &lt;application&gt;
        &lt;view-handler&gt;com.sun.facelets.FaceletViewHandler&lt;/view-handler&gt;
    &lt;/application&gt;
    
&lt;/faces-config&gt;
</programlisting>
				</example>
				<para>
					Note that we don&#39;t need any JSF managed bean declarations! Our managed beans are annotated Seam components. In Seam applications, the <literal>faces-config.xml</literal> is used much less often than in plain JSF.
				</para>
				<para>
					In fact, once you have all the basic descriptors set up, the <emphasis>only</emphasis> XML you need to write as you add new functionality to a Seam application is orchestration: navigation rules or jBPM process definitions. Seam takes the view that <emphasis>process flow</emphasis> and <emphasis>configuration data</emphasis> are the only things that truly belong in XML.
				</para>
				<para>
					In this simple example, we don&#39;t even need a navigation rule, since we decided to embed the view id in our action code.
				</para>
			</section>
			
			<section>
				<title>The EJB deployment descriptor: <literal>ejb-jar.xml</literal></title>
				<para>
					The <literal>ejb-jar.xml</literal> file integrates Seam with EJB3, by attaching the <literal>SeamInterceptor</literal> to all session beans in the archive.
				</para>
<programlisting>&lt;ejb-jar xmlns="http://java.sun.com/xml/ns/javaee" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                             http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd"
         version="3.0"&gt;
         
   &lt;interceptors&gt;
      &lt;interceptor&gt;
         &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
      &lt;/interceptor&gt;
   &lt;/interceptors&gt;
   
   &lt;assembly-descriptor&gt;
      &lt;interceptor-binding&gt;
         &lt;ejb-name&gt;*&lt;/ejb-name&gt;
         &lt;interceptor-class&gt;org.jboss.seam.ejb.SeamInterceptor&lt;/interceptor-class&gt;
      &lt;/interceptor-binding&gt;
   &lt;/assembly-descriptor&gt;
   
&lt;/ejb-jar&gt;
</programlisting>
			</section>
			
			<section>
				<title>The EJB persistence deployment descriptor: <literal>persistence.xml</literal></title>
				<para>
					The <literal>persistence.xml</literal> file tells the EJB persistence provider where to find the datasource, and contains some vendor-specific settings. In this case, enables automatic schema export at startup time.
				</para>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence 
                                 http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" 
             version="1.0"&gt;

   &lt;persistence-unit name="userDatabase"&gt;
      &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
    &lt;/persistence-unit&gt;
    
&lt;/persistence&gt;
</programlisting>
			</section>
			
			<section>
				<title>The view: <literal>register.xhtml</literal> and <literal>registered.xhtml</literal></title>
				<para>
					The view pages for a Seam application could be implemented using any technology that supports JSF. In this example we use Facelets, because we think it&#39;s better than JSP.
				</para>
				<example id="registration-simpleform">
					<title>registration form</title>
<programlisting>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:s="http://jboss.com/products/seam/taglib"
      xmlns:h="http://java.sun.com/jsf/html"
      xmlns:f="http://java.sun.com/jsf/core"&gt;

   &lt;head&gt;
      &lt;title&gt;Register New User&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;f:view&gt;
         &lt;h:form&gt;
            &lt;s:validateAll&gt;
               &lt;h:panelGrid columns="2"&gt;
                  Username: &lt;h:inputText value="#{user.username}" required="true"/&gt;
                  Real Name: &lt;h:inputText value="#{user.name}" required="true"/&gt;
                  Password: &lt;h:inputSecret value="#{user.password}" required="true"/&gt;
               &lt;/h:panelGrid&gt;
            &lt;/s:validateAll&gt;
            &lt;h:messages/&gt;
            &lt;h:commandButton value="Register" action="#{register.register}"/&gt;
         &lt;/h:form&gt;
      &lt;/f:view&gt;
   &lt;/body&gt;

&lt;/html&gt;
</programlisting>
				</example>
				<para>
					The only thing here that is specific to Seam is the <literal>&lt;s:validateAll&gt;</literal> tag. This JSF component tells JSF to validate all the contained input fields against the Hibernate Validator annotations specified on the entity bean.
				</para>
				<example id="registration-simplepage">
					<title>registration page</title>
<programlisting>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:f="http://java.sun.com/jsf/core"&gt;

   &lt;head&gt;
      &lt;title&gt;Successfully Registered New User&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
      &lt;f:view&gt;
         Welcome, #{user.name}, you are successfully registered as #{user.username}.
      &lt;/f:view&gt;
   &lt;/body&gt;

&lt;/html&gt;
</programlisting>
				</example>
				<para>
					This is a boring old Facelets page using some embedded EL. There is nothing specific to Seam here.
				</para>
			</section>
			
			<section>
				<title>The EAR deployment descriptor: <literal>application.xml</literal></title>
				<para>
					Finally, since our application is deployed as an EAR, we need a deployment descriptor there, too.
				</para>
				<example id="registration-application-xml">
					<title>registration application</title>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;application xmlns="http://java.sun.com/xml/ns/javaee" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                                 http://java.sun.com/xml/ns/javaee/application_5.xsd"
             version="5"&gt;
             
    &lt;display-name&gt;Seam Registration&lt;/display-name&gt;

    &lt;module&gt;
        &lt;web&gt;
            &lt;web-uri&gt;jboss-seam-registration.war&lt;/web-uri&gt;
            &lt;context-root&gt;/seam-registration&lt;/context-root&gt;
        &lt;/web&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;ejb&gt;jboss-seam-registration.jar&lt;/ejb&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;ejb&gt;jboss-seam.jar&lt;/ejb&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;java&gt;jboss-el.jar&lt;/java&gt;
    &lt;/module&gt;

&lt;/application&gt;
</programlisting>
				</example>
				<para>
					This deployment descriptor links modules in the enterprise archive and binds the web application to the context root <literal>/seam-registration</literal>.
				</para>
				<para>
					We&#39;ve now seen <emphasis>all</emphasis> the files in the entire application!
				</para>
			</section>

		</section>
		
		<section>
			<title>How it works</title>
			<para>
				When the form is submitted, JSF asks Seam to resolve the variable named <literal>user</literal>. Since there is no value already bound to that name (in any Seam context), Seam instantiates the <literal>user</literal> component, and returns the resulting <literal>User</literal> entity bean instance to JSF after storing it in the Seam session context.
			</para>
			<para>
				The form input values are now validated against the Hibernate Validator constraints specified on the <literal>User</literal> entity. If the constraints are violated, JSF redisplays the page. Otherwise, JSF binds the form input values to properties of the <literal>User</literal> entity bean.
			</para>
			<para>
				Next, JSF asks Seam to resolve the variable named <literal>register</literal>. Seam finds the <literal>RegisterAction</literal> stateless session bean in the stateless context and returns it. JSF invokes the <literal>register()</literal> action listener method.
			</para>
			<para>
				Seam intercepts the method call and injects the <literal>User</literal> entity from the Seam session context, before continuing the invocation.
			</para>
			<para>
				The <literal>register()</literal> method checks if a user with the entered username already exists. If so, an error message is queued with the <literal>FacesMessages</literal> component, and a null outcome is returned, causing a page redisplay. The <literal>FacesMessages</literal> component interpolates the JSF expression embedded in the message string and adds a JSF <literal>FacesMessage</literal> to the view.
			</para>
			<para>
				If no user with that username exists, the <literal>"/registered.xhtml"</literal> outcome triggers a browser redirect to the <literal>registered.xhtml</literal> page. When JSF comes to render the page, it asks Seam to resolve the variable named <literal>user</literal> and uses property values of the returned <literal>User</literal> entity from Seam&#39;s session scope.
			</para>
		</section>

	</section>
	
	<section id="messages">
		<title>Clickable lists in Seam: the messages example</title>
		<para>
			Clickable lists of database search results are such an important part of any online application that Seam provides special functionality on top of JSF to make it easier to query data using EJB-QL or HQL and display it as a clickable list using a JSF <literal>&lt;h:dataTable&gt;</literal>. The messages example demonstrates this functionality.
		</para>
		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="/images/messages.png" />
			</imageobject>
			<imageobject role="html">
				<imagedata align="center" fileref="/images/messages.png" />
			</imageobject>
		</mediaobject>
		<section>
			<title>Understanding the code</title>
			<para>
				The message list example has one entity bean, <literal>Message</literal>, one session bean, <literal>MessageListBean</literal> and one JSP.
			</para>
			<section>
				<title>The entity bean: <literal>Message.java</literal></title>
				<para>
					The <literal>Message</literal> entity defines the title, text, date and time of a message, and a flag indicating whether the message has been read:
				</para>
				<example>
					<title></title>
<programlisting>@Entity
@Name("message")
@Scope(EVENT)
public class Message implements Serializable
{
   private Long id;
   private String title;
   private String text;
   private boolean read;
   private Date datetime;
   
   @Id @GeneratedValue
   public Long getId() {
      return id;
   }
   public void setId(Long id) {
      this.id = id;
   }
   
   @NotNull @Length(max=100)
   public String getTitle() {
      return title;
   }
   public void setTitle(String title) {
      this.title = title;
   }
   
   @NotNull @Lob
   public String getText() {
      return text;
   }
   public void setText(String text) {
      this.text = text;
   }
   
   @NotNull
   public boolean isRead() {
      return read;
   }
   public void setRead(boolean read) {
      this.read = read;
   }
   
   @NotNull 
   @Basic @Temporal(TemporalType.TIMESTAMP)
   public Date getDatetime() {
      return datetime;
   }
   public void setDatetime(Date datetime) {
      this.datetime = datetime;
   }
   
}
</programlisting>
				</example>
			</section>
			
			<section>
				<title>The stateful session bean: <literal>MessageManagerBean.java</literal></title>
				<para>
					Just like in the previous example, we have a session bean, <literal>MessageManagerBean</literal>, which defines the action listener methods for the two buttons on our form. One of the buttons selects a message from the list, and displays that message. The other button deletes a message. So far, this is not so different to the previous example.
				</para>
				<para>
					But <literal>MessageManagerBean</literal> is also responsible for fetching the list of messages the first time we navigate to the message list page. There are various ways the user could navigate to the page, and not all of them are preceded by a JSF action—the user might have bookmarked the page, for example. So the job of fetching the message list takes place in a Seam <emphasis>factory method</emphasis>, instead of in an action listener method.
				</para>
				<para>
					We want to cache the list of messages in memory between server requests, so we will make this a stateful session bean.
				</para>
				<example>
					<title></title>
					<programlistingco>
						<areaspec>
							<area coords="7" id="messages-datamodel" />
							<area coords="10" id="messages-datamodelselection" />
							<area coords="11" id="messages-out" />
							<area coords="14" id="messages-persistencecontext" />
							<area coords="17" id="messages-factory" />
							<area coords="24" id="messages-select" />
							<area coords="29" id="messages-delete" />
							<area coords="36" id="messages-remove" />
						</areaspec>
<programlisting>@Stateful
@Scope(SESSION)
@Name("messageManager")
public class MessageManagerBean implements Serializable, MessageManager
{

   @DataModel
   private List&lt;Message&gt; messageList;
   
   @DataModelSelection
   @Out(required=false)
   private Message message;
   
   @PersistenceContext(type=EXTENDED)
   private EntityManager em;
   
   @Factory("messageList")
   public void findMessages()
   {
      messageList = em.createQuery("from Message msg order by msg.datetime desc")
                      .getResultList();
   }
   
   public void select()
   {
      message.setRead(true);
   }
   
   public void delete()
   {
      messageList.remove(message);
      em.remove(message);
      message=null;
   }
   
   @Remove
   public void destroy() {}

}
</programlisting>
						<calloutlist>
							<callout arearefs="messages-datamodel">
								<para>
									The <literal>@DataModel</literal> annotation exposes an attibute of type <literal>java.util.List</literal> to the JSF page as an instance of <literal>javax.faces.model.DataModel</literal>. This allows us to use the list in a JSF <literal>&lt;h:dataTable&gt;</literal> with clickable links for each row. In this case, the <literal>DataModel</literal> is made available in a session context variable named <literal>messageList</literal>.
								</para>
							</callout>
							<callout arearefs="messages-datamodelselection">
								<para>
									The <literal>@DataModelSelection</literal> annotation tells Seam to inject the <literal>List</literal> element that corresponded to the clicked link.
								</para>
							</callout>
							<callout arearefs="messages-out">
								<para>
									The <literal>@Out</literal> annotation then exposes the selected value directly to the page. So ever time a row of the clickable list is selected, the <literal>Message</literal> is injected to the attribute of the stateful bean, and the subsequently <emphasis>outjected</emphasis> to the event context variable named <literal>message</literal>.
								</para>
							</callout>
							<callout arearefs="messages-persistencecontext">
								<para>
									This stateful bean has an EJB3 <emphasis>extended persistence context</emphasis>. The messages retrieved in the query remain in the managed state as long as the bean exists, so any subsequent method calls to the stateful bean can update them without needing to make any explicit call to the <literal>EntityManager</literal>.
								</para>
							</callout>
							<callout arearefs="messages-factory">
								<para>
									The first time we navigate to the JSP page, there will be no value in the <literal>messageList</literal> context variable. The <literal>@Factory</literal> annotation tells Seam to create an instance of <literal>MessageManagerBean</literal> and invoke the <literal>findMessages()</literal> method to initialize the value. We call <literal>findMessages()</literal> a <emphasis>factory method</emphasis> for <literal>messages</literal>.
								</para>
							</callout>
							<callout arearefs="messages-select">
								<para>
									The <literal>select()</literal> action listener method marks the selected <literal>Message</literal> as read, and updates it in the database.
								</para>
							</callout>
							<callout arearefs="messages-delete">
								<para>
									The <literal>delete()</literal> action listener method removes the selected <literal>Message</literal> from the database.
								</para>
							</callout>
							<callout arearefs="messages-remove">
								<para>
									All stateful session bean Seam components <emphasis>must</emphasis> have a method with no parameters marked <literal>@Remove</literal> that Seam uses to remove the stateful bean when the Seam context ends, and clean up any server-side state.
								</para>
							</callout>
						</calloutlist>
					</programlistingco>

				</example>
				<para>
					Note that this is a session-scoped Seam component. It is associated with the user login session, and all requests from a login session share the same instance of the component. (In Seam applications, we usually use session-scoped components sparingly.)
				</para>
			</section>
			
			<section>
				<title>The session bean local interface: <literal>MessageManager.java</literal></title>
				<para>
					All session beans have a business interface, of course.
				</para>
<programlisting>@Local
public interface MessageManager
{
   public void findMessages();
   public void select();
   public void delete();
   public void destroy();
}
</programlisting>
				<para>
					From now on, we won&#39;t show local interfaces in our code examples.
				</para>
				<para>
					Let&#39;s skip over <literal>components.xml</literal>, <literal>persistence.xml</literal>, <literal>web.xml</literal>, <literal>ejb-jar.xml</literal>, <literal>faces-config.xml</literal> and <literal>application.xml</literal> since they are much the same as the previous example, and go straight to the JSP.
				</para>
			</section>
			
			<section>
				<title>The view: <literal>messages.jsp</literal></title>
				<para>
					The JSP page is a straightforward use of the JSF <literal>&lt;h:dataTable&gt;</literal> component. Again, nothing specific to Seam.
				</para>
				<example>
					<title></title>
<programlisting>&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;Messages&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;f:view&gt;
   &lt;h:form&gt;
     &lt;h2&gt;Message List&lt;/h2&gt;
     &lt;h:outputText value="No messages to display" 
                   rendered="#{messageList.rowCount==0}"/&gt;
     &lt;h:dataTable var="msg" value="#{messageList}" 
                  rendered="#{messageList.rowCount&gt;0}"&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Read"/&gt;
           &lt;/f:facet&gt;
           &lt;h:selectBooleanCheckbox value="#{msg.read}" disabled="true"/&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Title"/&gt;
           &lt;/f:facet&gt;
           &lt;h:commandLink value="#{msg.title}" action="#{messageManager.select}"/&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;f:facet name="header"&gt;
              &lt;h:outputText value="Date/Time"/&gt;
           &lt;/f:facet&gt;
           &lt;h:outputText value="#{msg.datetime}"&gt;
              &lt;f:convertDateTime type="both" dateStyle="medium" timeStyle="short"/&gt;
           &lt;/h:outputText&gt;
        &lt;/h:column&gt;
        &lt;h:column&gt;
           &lt;h:commandButton value="Delete" action="#{messageManager.delete}"/&gt;
        &lt;/h:column&gt;
     &lt;/h:dataTable&gt;
     &lt;h3&gt;&lt;h:outputText value="#{message.title}"/&gt;&lt;/h3&gt;
     &lt;div&gt;&lt;h:outputText value="#{message.text}"/&gt;&lt;/div&gt;
   &lt;/h:form&gt;
  &lt;/f:view&gt;
 &lt;/body&gt;
&lt;/html&gt;
</programlisting>
				</example>
			</section>

		</section>
		
		<section>
			<title>How it works</title>
			<para>
				The first time we navigate to the <literal>messages.jsp</literal> page, whether by a JSF postback (faces request) or a direct browser GET request (non-faces request), the page will try to resolve the <literal>messageList</literal> context variable. Since this context variable is not initialized, Seam will call the factory method <literal>findMessages()</literal>, which performs a query against the database and results in a <literal>DataModel</literal> being outjected. This <literal>DataModel</literal> provides the row data needed for rendering the <literal>&lt;h:dataTable&gt;</literal>.
			</para>
			<para>
				When the user clicks the <literal>&lt;h:commandLink&gt;</literal>, JSF calls the <literal>select()</literal> action listener. Seam intercepts this call and injects the selected row data into the <literal>message</literal> attribute of the <literal>messageManager</literal> component. The action listener fires, marking the selected <literal>Message</literal> as read. At the end of the call, Seam outjects the selected <literal>Message</literal> to the context variable named <literal>message</literal>. Next, the EJB container commits the transaction, and the change to the <literal>Message</literal> is flushed to the database. Finally, the page is re-rendered, redisplaying the message list, and displaying the selected message below it.
			</para>
			<para>
				If the user clicks the <literal>&lt;h:commandButton&gt;</literal>, JSF calls the <literal>delete()</literal> action listener. Seam intercepts this call and injects the selected row data into the <literal>message</literal> attribute of the <literal>messageList</literal> component. The action listener fires, removing the selected <literal>Message</literal> from the list, and also calling <literal>remove()</literal> on the <literal>EntityManager</literal>. At the end of the call, Seam refreshes the <literal>messageList</literal> context variable and clears the context variable named <literal>message</literal>. The EJB container commits the transaction, and deletes the <literal>Message</literal> from the database. Finally, the page is re-rendered, redisplaying the message list.
			</para>
		</section>

	</section>
	
	<section id="todo">
		<title>Seam and jBPM: the todo list example</title>
		<para>
			jBPM provides sophisticated functionality for workflow and task management. To get a small taste of how jBPM integrates with Seam, we&#39;ll show you a simple "todo list" application. Since managing lists of tasks is such core functionality for jBPM, there is hardly any Java code at all in this example.
		</para>
		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="/images/todo.png" />
			</imageobject>
			<imageobject role="html">
				<imagedata align="center" fileref="/images/todo.png" />
			</imageobject>
		</mediaobject>
		<section>
			<title>Understanding the code</title>
			<para>
				The center of this example is the jBPM process definition. There are also two JSPs and two trivial JavaBeans (There was no reason to use session beans, since they do not access the database, or have any other transactional behavior). Let&#39;s start with the process definition:
			</para>
			<example>
				<title></title>
				<programlistingco>
					<areaspec>
						<area coords="3" id="todo-startstate" />
						<area coords="7" id="todo-tasknode" />
						<area coords="8" id="todo-task" />
						<area coords="9" id="todo-assignment" />
						<area coords="14" id="todo-endstate" />
					</areaspec>
<programlisting>&lt;process-definition name="todo"&gt;
   
   &lt;start-state name="start"&gt;
      &lt;transition to="todo"/&gt;
   &lt;/start-state&gt;
   
   &lt;task-node name="todo"&gt;
      &lt;task name="todo" description="#{todoList.description}"&gt;
         &lt;assignment actor-id="#{actor.id}"/&gt;
      &lt;/task&gt;
      &lt;transition to="done"/&gt;
   &lt;/task-node&gt;
   
   &lt;end-state name="done"/&gt;
   
&lt;/process-definition&gt;
</programlisting>
					<calloutlist>
						<callout arearefs="todo-startstate">
							<para>
								The <literal>&lt;start-state&gt;</literal> node represents the logical start of the process. When the process starts, it immediately transitions to the <literal>todo</literal> node.
							</para>
						</callout>
						<callout arearefs="todo-tasknode">
							<para>
								The <literal>&lt;task-node&gt;</literal> node represents a <emphasis>wait state</emphasis>, where business process execution pauses, waiting for one or more tasks to be performed.
							</para>
						</callout>
						<callout arearefs="todo-task">
							<para>
								The <literal>&lt;task&gt;</literal> element defines a task to be performed by a user. Since there is only one task defined on this node, when it is complete, execution resumes, and we transition to the end state. The task gets its description from a Seam component named <literal>todoList</literal> (one of the JavaBeans).
							</para>
						</callout>
						<callout arearefs="todo-assignment">
							<para>
								Tasks need to be assigned to a user or group of users when they are created. In this case, the task is assigned to the current user, which we get from a built-in Seam component named <literal>actor</literal>. Any Seam component may be used to perform task assignment.
							</para>
						</callout>
						<callout arearefs="todo-endstate">
							<para>
								The <literal>&lt;end-state&gt;</literal> node defines the logical end of the business process. When execution reaches this node, the process instance is destroyed.
							</para>
						</callout>
					</calloutlist>
				</programlistingco>

			</example>
			<para>
				If we view this process definition using the process definition editor provided by JBossIDE, this is what it looks like:
			</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata align="center" fileref="/images/todo-process.png" />
				</imageobject>
				<imageobject role="html">
					<imagedata align="center" fileref="/images/todo-process.png" />
				</imageobject>
			</mediaobject>
			<para>
				This document defines our <emphasis>business process</emphasis> as a graph of nodes. This is the most trivial possible business process: there is one <emphasis>task</emphasis> to be performed, and when that task is complete, the business process ends.
			</para>
			<para>
				The first JavaBean handles the login screen <literal>login.jsp</literal>. Its job is just to initialize the jBPM actor id using the <literal>actor</literal> component. (In a real application, it would also need to authenticate the user.)
			</para>
			<example>
				<title></title>
<programlisting>@Name("login")
public class Login {
   
   @In
   private Actor actor;
   
   private String user;

   public String getUser() {
      return user;
   }

   public void setUser(String user) {
      this.user = user;
   }
   
   public String login()
   {
      actor.setId(user);
      return "/todo.jsp";
   }
}
</programlisting>
			</example>
			<para>
				Here we see the use of <literal>@In</literal> to inject the built-in <literal>Actor</literal> component.
			</para>
			<para>
				The JSP itself is trivial:
			</para>
			<example>
				<title></title>
<programlisting>&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h"%&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f"%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Login&lt;/h1&gt;
&lt;f:view&gt;
    &lt;h:form&gt;
      &lt;div&gt;
        &lt;h:inputText value="#{login.user}"/&gt;
        &lt;h:commandButton value="Login" action="#{login.login}"/&gt;
      &lt;/div&gt;
    &lt;/h:form&gt;
&lt;/f:view&gt;
&lt;/body&gt;
&lt;/html&gt;
</programlisting>
			</example>
			<para>
				The second JavaBean is responsible for starting business process instances, and ending tasks.
			</para>
			<example>
				<title></title>
				<programlistingco>
					<areaspec>
						<area coords="6" id="todo-description" />
						<area coords="15" id="todo-createprocess-annotation" />
						<area coords="18" id="todo-task-annotations" />
					</areaspec>
<programlisting>@Name("todoList")
public class TodoList {
   
   private String description;
   
   public String getDescription()
   {
      return description;
   }

   public void setDescription(String description) {
      this.description = description;
   }
   
   @CreateProcess(definition="todo")
   public void createTodo() {}
   
   @StartTask @EndTask
   public void done() {}

}
</programlisting>
					<calloutlist>
						<callout arearefs="todo-description">
							<para>
								The description property accepts user input form the JSP page, and exposes it to the process definition, allowing the task description to be set.
							</para>
						</callout>
						<callout arearefs="todo-createprocess-annotation">
							<para>
								The Seam <literal>@CreateProcess</literal> annotation creates a new jBPM process instance for the named process definition.
							</para>
						</callout>
						<callout arearefs="todo-task-annotations">
							<para>
								The Seam <literal>@StartTask</literal> annotation starts work on a task. The <literal>@EndTask</literal> ends the task, and allows the business process execution to resume.
							</para>
						</callout>
					</calloutlist>
				</programlistingco>

			</example>
			<para>
				In a more realistic example, <literal>@StartTask</literal> and <literal>@EndTask</literal> would not appear on the same method, because there is usually work to be done using the application in order to complete the task.
			</para>
			<para>
				Finally, the meat of the application is in <literal>todo.jsp</literal>:
			</para>
			<example>
				<title></title>
<programlisting>&lt;%@ taglib uri="http://java.sun.com/jsf/html" prefix="h" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsf/core" prefix="f" %&gt;
&lt;%@ taglib uri="http://jboss.com/products/seam/taglib" prefix="s" %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Todo List&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Todo List&lt;/h1&gt;
&lt;f:view&gt;
   &lt;h:form id="list"&gt;
      &lt;div&gt;
         &lt;h:outputText value="There are no todo items." 
                       rendered="#{empty taskInstanceList}"/&gt;
         &lt;h:dataTable value="#{taskInstanceList}" var="task" 
                      rendered="#{not empty taskInstanceList}"&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Description"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.description}"/&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Created"/&gt;
                &lt;/f:facet&gt;
                &lt;h:outputText value="#{task.taskMgmtInstance.processInstance.start}"&gt;
                    &lt;f:convertDateTime type="date"/&gt;
                &lt;/h:outputText&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Priority"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.priority}" style="width: 30"/&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;f:facet name="header"&gt;
                    &lt;h:outputText value="Due Date"/&gt;
                &lt;/f:facet&gt;
                &lt;h:inputText value="#{task.dueDate}" style="width: 100"&gt;
                    &lt;f:convertDateTime type="date" dateStyle="short"/&gt;
                &lt;/h:inputText&gt;
            &lt;/h:column&gt;
            &lt;h:column&gt;
                &lt;s:button value="Done" action="#{todoList.done}" taskInstance="#{task}"/&gt;
            &lt;/h:column&gt;
         &lt;/h:dataTable&gt;
      &lt;/div&gt;
      &lt;div&gt;
      &lt;h:messages/&gt;
      &lt;/div&gt;
      &lt;div&gt;
         &lt;h:commandButton value="Update Items" action="update"/&gt;
      &lt;/div&gt;
   &lt;/h:form&gt;
   &lt;h:form id="new"&gt;
      &lt;div&gt;
         &lt;h:inputText value="#{todoList.description}"/&gt;
         &lt;h:commandButton value="Create New Item" action="#{todoList.createTodo}"/&gt;
      &lt;/div&gt;
   &lt;/h:form&gt;
&lt;/f:view&gt;
&lt;/body&gt;
&lt;/html&gt;
</programlisting>
			</example>
			<para>
				Let&#39;s take this one piece at a time.
			</para>
			<para>
				The page renders a list of tasks, which it gets from a built-in Seam component named <literal>taskInstanceList</literal>. The list is defined inside a JSF form.
			</para>
<programlisting>&lt;h:form id="list"&gt;
   &lt;div&gt;
      &lt;h:outputText value="There are no todo items." rendered="#{empty taskInstanceList}"/&gt;
      &lt;h:dataTable value="#{taskInstanceList}" var="task" 
                   rendered="#{not empty taskInstanceList}"&gt;
         ...
      &lt;/h:dataTable&gt;
   &lt;/div&gt;
&lt;/h:form&gt;
</programlisting>
			<para>
				Each element of the list is an instance of the jBPM class <literal>TaskInstance</literal>. The following code simply displays the interesting properties of each task in the list. For the description, priority and due date, we use input controls, to allow the user to update these values.
			</para>
<programlisting>&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
       &lt;h:outputText value="Description"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.description}"/&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Created"/&gt;
    &lt;/f:facet&gt;
    &lt;h:outputText value="#{task.taskMgmtInstance.processInstance.start}"&gt;
        &lt;f:convertDateTime type="date"/&gt;
    &lt;/h:outputText&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Priority"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.priority}" style="width: 30"/&gt;
&lt;/h:column&gt;
&lt;h:column&gt;
    &lt;f:facet name="header"&gt;
        &lt;h:outputText value="Due Date"/&gt;
    &lt;/f:facet&gt;
    &lt;h:inputText value="#{task.dueDate}" style="width: 100"&gt;
        &lt;f:convertDateTime type="date" dateStyle="short"/&gt;
    &lt;/h:inputText&gt;
&lt;/h:column&gt;
</programlisting>
			<para>
				This button ends the task by calling the action method annotated <literal>@StartTask @EndTask</literal>. It passes the task id to Seam as a request parameter:
			</para>
<programlisting>&lt;h:column&gt;
    &lt;s:button value="Done" action="#{todoList.done}" taskInstance="#{task}"/&gt;
&lt;/h:column&gt;
</programlisting>
			<para>
				(Note that this is using a Seam <literal>&lt;s:button&gt;</literal> JSF control from the <literal>seam-ui.jar</literal> package.)
			</para>
			<para>
				This button is used to update the properties of the tasks. When the form is submitted, Seam and jBPM will make any changes to the tasks persistent. There is no need for any action listener method:
			</para>
<programlisting>&lt;h:commandButton value="Update Items" action="update"/&gt;
</programlisting>
			<para>
				A second form on the page is used to create new items, by calling the action method annotated <literal>@CreateProcess</literal>.
			</para>
<programlisting>&lt;h:form id="new"&gt;
    &lt;div&gt;
        &lt;h:inputText value="#{todoList.description}"/&gt;
        &lt;h:commandButton value="Create New Item" action="#{todoList.createTodo}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;
</programlisting>
			<para>
				There are several other files needed for the example, but they are just standard jBPM and Seam configuration and not very interesting.
			</para>
		</section>
		
		<section>
			<title>How it works</title>
			<para>
				TODO
			</para>
		</section>

	</section>
	
	<section id="numberguess">
		<title>Seam pageflow: the numberguess example</title>
		<para>
			For Seam applications with relatively freeform (ad hoc) navigation, JSF/Seam navigation rules are a perfectly good way to define the page flow. For applications with a more constrained style of navigation, especially for user interfaces which are more stateful, navigation rules make it difficult to really understand the flow of the system. To understand the flow, you need to piece it together from the view pages, the actions and the navigation rules.
		</para>
		<para>
			Seam allows you to use a jPDL process definition to define pageflow. The simple number guessing example shows how this is done.
		</para>
		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="/images/numberguess.png" />
			</imageobject>
			<imageobject role="html">
				<imagedata align="center" fileref="/images/numberguess.png" />
			</imageobject>
		</mediaobject>
		<section>
			<title>Understanding the code</title>
			<para>
				The example is implemented using one JavaBean, three JSP pages and a jPDL pageflow definition. Let&#39;s begin with the pageflow:
			</para>
			<example>
				<title></title>
				<programlistingco>
					<areaspec>
						<area coords="8" id="numberguess-page" />
						<area coords="10" id="numberguess-transition" />
						<area coords="11" id="numberguess-action" />
						<area coords="16" id="numberguess-decision" />
					</areaspec>
<programlisting>&lt;pageflow-definition 
        xmlns="http://jboss.com/products/seam/pageflow"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.com/products/seam/pageflow 
                            http://jboss.com/products/seam/pageflow-2.1.xsd"
        name="numberGuess"&gt;
   
   &lt;start-page name="displayGuess" view-id="/numberGuess.jspx"&gt;
      &lt;redirect/&gt;
      &lt;transition name="guess" to="evaluateGuess"&gt;
         &lt;action expression="#{numberGuess.guess}"/&gt;
      &lt;/transition&gt;
      &lt;transition name="giveup" to="giveup"/&gt;
   &lt;/start-page&gt;
   
   &lt;decision name="evaluateGuess" expression="#{numberGuess.correctGuess}"&gt;
      &lt;transition name="true" to="win"/&gt;
      &lt;transition name="false" to="evaluateRemainingGuesses"/&gt;
   &lt;/decision&gt;
   
   &lt;decision name="evaluateRemainingGuesses" expression="#{numberGuess.lastGuess}"&gt;
      &lt;transition name="true" to="lose"/&gt;
      &lt;transition name="false" to="displayGuess"/&gt;
   &lt;/decision&gt;
   
   &lt;page name="giveup" view-id="/giveup.jspx"&gt;
      &lt;redirect/&gt;
      &lt;transition name="yes" to="lose"/&gt;
      &lt;transition name="no" to="displayGuess"/&gt;
   &lt;/page&gt;
   
   &lt;page name="win" view-id="/win.jspx"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation/&gt;
   &lt;/page&gt;
   
   &lt;page name="lose" view-id="/lose.jspx"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation/&gt;
   &lt;/page&gt;
   
&lt;/pageflow-definition&gt;
</programlisting>
					<calloutlist>
						<callout arearefs="numberguess-page">
							<para>
								The <literal>&lt;page&gt;</literal> element defines a wait state where the system displays a particular JSF view and waits for user input. The <literal>view-id</literal> is the same JSF view id used in plain JSF navigation rules. The <literal>redirect</literal> attribute tells Seam to use post-then-redirect when navigating to the page. (This results in friendly browser URLs.)
							</para>
						</callout>
						<callout arearefs="numberguess-transition">
							<para>
								The <literal>&lt;transition&gt;</literal> element names a JSF outcome. The transition is triggered when a JSF action results in that outcome. Execution will then proceed to the next node of the pageflow graph, after invocation of any jBPM transition actions.
							</para>
						</callout>
						<callout arearefs="numberguess-action">
							<para>
								A transition <literal>&lt;action&gt;</literal> is just like a JSF action, except that it occurs when a jBPM transition occurs. The transition action can invoke any Seam component.
							</para>
						</callout>
						<callout arearefs="numberguess-decision">
							<para>
								A <literal>&lt;decision&gt;</literal> node branches the pageflow, and determines the next node to execute by evaluating a JSF EL expression.
							</para>
						</callout>
					</calloutlist>
				</programlistingco>

			</example>
			<para>
				Here is what the pageflow looks like in the JBossIDE pageflow editor:
			</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata align="center" fileref="/images/numberguess-pageflow.png" />
				</imageobject>
				<imageobject role="html">
					<imagedata align="center" fileref="/images/numberguess-pageflow.png" />
				</imageobject>
			</mediaobject>
			<para>
				Now that we have seen the pageflow, it is very, very easy to understand the rest of the application!
			</para>
			<para>
				Here is the main page of the application, <literal>numberGuess.jspx</literal>:
			</para>
			<example>
				<title></title>
<programlisting>&lt;&lt;?xml version="1.0"?&gt;
&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" 
          xmlns:h="http://java.sun.com/jsf/html"
          xmlns:f="http://java.sun.com/jsf/core"
          xmlns:s="http://jboss.com/products/seam/taglib"
          xmlns="http://www.w3.org/1999/xhtml"
          version="2.0"&gt;
  &lt;jsp:output doctype-root-element="html" 
              doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
              doctype-system="http://www.w3c.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/&gt;
  &lt;jsp:directive.page contentType="text/html"/&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Guess a number...&lt;/title&gt;
    &lt;link href="niceforms.css" rel="stylesheet" type="text/css" /&gt;
    &lt;script language="javascript" type="text/javascript" src="niceforms.js" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Guess a number...&lt;/h1&gt;
    &lt;f:view&gt;
	  &lt;h:form styleClass="niceform"&gt;
	    
	    &lt;div&gt;
	    &lt;h:messages globalOnly="true"/&gt;
	    &lt;h:outputText value="Higher!" 
	           rendered="#{numberGuess.randomNumber gt numberGuess.currentGuess}"/&gt;
	    &lt;h:outputText value="Lower!" 
	           rendered="#{numberGuess.randomNumber lt numberGuess.currentGuess}"/&gt;
		&lt;/div&gt;
		
		&lt;div&gt;
        I&#39;m thinking of a number between 
        &lt;h:outputText value="#{numberGuess.smallest}"/&gt; and 
        &lt;h:outputText value="#{numberGuess.biggest}"/&gt;. You have 
        &lt;h:outputText value="#{numberGuess.remainingGuesses}"/&gt; guesses.
        &lt;/div&gt;
        
        &lt;div&gt;
        Your guess: 
        &lt;h:inputText value="#{numberGuess.currentGuess}" id="inputGuess" 
                     required="true" size="3" 
                     rendered="#{(numberGuess.biggest-numberGuess.smallest) gt 20}"&gt;
          &lt;f:validateLongRange maximum="#{numberGuess.biggest}" 
                               minimum="#{numberGuess.smallest}"/&gt;
        &lt;/h:inputText&gt;
        &lt;h:selectOneMenu value="#{numberGuess.currentGuess}" 
                         id="selectGuessMenu" required="true"
                         rendered="#{(numberGuess.biggest-numberGuess.smallest) le 20 and 
                                     (numberGuess.biggest-numberGuess.smallest) gt 4}"&gt;
          &lt;s:selectItems value="#{numberGuess.possibilities}" var="i" label="#{i}"/&gt;
        &lt;/h:selectOneMenu&gt;
        &lt;h:selectOneRadio value="#{numberGuess.currentGuess}" id="selectGuessRadio" 
                          required="true"
                          rendered="#{(numberGuess.biggest-numberGuess.smallest) le 4}"&gt;
          &lt;s:selectItems value="#{numberGuess.possibilities}" var="i" label="#{i}"/&gt;
        &lt;/h:selectOneRadio&gt;
		&lt;h:commandButton value="Guess" action="guess"/&gt;
        &lt;s:button value="Cheat" view="/confirm.jspx"/&gt;
        &lt;s:button value="Give up" action="giveup"/&gt;
		&lt;/div&gt;
		
		&lt;div&gt;
        &lt;h:message for="inputGuess" style="color: red"/&gt;
        &lt;/div&gt;
        
	  &lt;/h:form&gt;
    &lt;/f:view&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/jsp:root&gt;
</programlisting>
			</example>
			<para>
				Notice how the command button names the <literal>guess</literal> transition instead of calling an action directly.
			</para>
			<para>
				The <literal>win.jspx</literal> page is predictable:
			</para>
			<example>
				<title></title>
<programlisting>&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page" 
          xmlns:h="http://java.sun.com/jsf/html"
          xmlns:f="http://java.sun.com/jsf/core"
          xmlns="http://www.w3.org/1999/xhtml"
          version="2.0"&gt;
  &lt;jsp:output doctype-root-element="html"
              doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"
              doctype-system="http://www.w3c.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"/&gt;
  &lt;jsp:directive.page contentType="text/html"/&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;You won!&lt;/title&gt;
    &lt;link href="niceforms.css" rel="stylesheet" type="text/css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;You won!&lt;/h1&gt;
    &lt;f:view&gt;
      Yes, the answer was &lt;h:outputText value="#{numberGuess.currentGuess}" /&gt;.
      It took you &lt;h:outputText value="#{numberGuess.guessCount}" /&gt; guesses.
      &lt;h:outputText value="But you cheated, so it doesn&#39;t count!" 
                    rendered="#{numberGuess.cheat}"/&gt;
      Would you like to &lt;a href="numberGuess.seam"&gt;play again&lt;/a&gt;?
    &lt;/f:view&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/jsp:root&gt;
</programlisting>
			</example>
			<para>
				As is <literal>lose.jspx</literal> (which I can&#39;t be bothered copy/pasting). Finally, the JavaBean Seam component:
			</para>
			<example>
				<title></title>
				<programlistingco>
					<areaspec>
						<area coords="13" id="numberguess-create" />
					</areaspec>
<programlisting>@Name("numberGuess")
@Scope(ScopeType.CONVERSATION)
public class NumberGuess implements Serializable {
   
   private int randomNumber;
   private Integer currentGuess;
   private int biggest;
   private int smallest;
   private int guessCount;
   private int maxGuesses;
   private boolean cheated;
   
   @Create
   public void begin()
   {
      randomNumber = new Random().nextInt(100);
      guessCount = 0;
      biggest = 100;
      smallest = 1;
   }
   
   public void setCurrentGuess(Integer guess)
   {
      this.currentGuess = guess;
   }
   
   public Integer getCurrentGuess()
   {
      return currentGuess;
   }
   
   public void guess()
   {
      if (currentGuess&gt;randomNumber)
      {
         biggest = currentGuess - 1;
      }
      if (currentGuess&lt;randomNumber)
      {
         smallest = currentGuess + 1;
      }
      guessCount ++;
   }
   
   public boolean isCorrectGuess()
   {
      return currentGuess==randomNumber;
   }
   
   public int getBiggest()
   {
      return biggest;
   }
   
   public int getSmallest()
   {
      return smallest;
   }
   
   public int getGuessCount()
   {
      return guessCount;
   }
   
   public boolean isLastGuess()
   {
      return guessCount==maxGuesses;
   }

   public int getRemainingGuesses() {
      return maxGuesses-guessCount;
   }

   public void setMaxGuesses(int maxGuesses) {
      this.maxGuesses = maxGuesses;
   }

   public int getMaxGuesses() {
      return maxGuesses;
   }

   public int getRandomNumber() {
      return randomNumber;
   }

   public void cheated()
   {
      cheated = true;
   }
   
   public boolean isCheat() {
      return cheated;
   }
   
   public List&lt;Integer&gt; getPossibilities()
   {
      List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
      for(int i=smallest; i&lt;=biggest; i++) result.add(i);
      return result;
   }
   
}
</programlisting>
					<calloutlist>
						<callout arearefs="numberguess-create">
							<para>
								The first time a JSP page asks for a <literal>numberGuess</literal> component, Seam will create a new one for it, and the <literal>@Create</literal> method will be invoked, allowing the component to initialize itself.
							</para>
						</callout>
					</calloutlist>
				</programlistingco>

			</example>
			<para>
				The <literal>pages.xml</literal> file starts a Seam <emphasis>conversation</emphasis> (much more about that later), and specifies the pageflow definition to use for the conversation&#39;s page flow.
			</para>
			<example>
				<title></title>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;pages xmlns="http://jboss.com/products/seam/pages"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://jboss.com/products/seam/pages http://jboss.com/products/seam/pages-2.1.xsd"&gt;

  &lt;page view-id="/numberGuess.jspx"&gt;
    &lt;begin-conversation join="true" pageflow="numberGuess"/&gt;
  &lt;/page&gt;

  &lt;page view-id="/confirm.jspx"&gt;
    &lt;begin-conversation nested="true" pageflow="cheat"/&gt;
  &lt;/page&gt;

&lt;/pages&gt;
</programlisting>
			</example>
			<para>
				As you can see, this Seam component is pure business logic! It doesn&#39;t need to know anything at all about the user interaction flow. This makes the component potentially more reuseable.
			</para>
		</section>
		
		<section>
			<title>How it works</title>
			<para>
				TODO
			</para>
		</section>

	</section>
	
	<section id="booking">
		<title>A complete Seam application: the Hotel Booking example</title>
		<section>
			<title>Introduction</title>
			<para>
				The booking application is a complete hotel room reservation system incorporating the following features:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						User registration
					</para>
				</listitem>
				<listitem>
					<para>
						Login
					</para>
				</listitem>
				<listitem>
					<para>
						Logout
					</para>
				</listitem>
				<listitem>
					<para>
						Set password
					</para>
				</listitem>
				<listitem>
					<para>
						Hotel search
					</para>
				</listitem>
				<listitem>
					<para>
						Hotel selection
					</para>
				</listitem>
				<listitem>
					<para>
						Room reservation
					</para>
				</listitem>
				<listitem>
					<para>
						Reservation confirmation
					</para>
				</listitem>
				<listitem>
					<para>
						Existing reservation list
					</para>
				</listitem>
			</itemizedlist>
			<screenshot><screeninfo>Booking example</screeninfo>
			<mediaobject>
				<imageobject role="fo">
					<imagedata align="center" fileref="/images/booking.png" />
				</imageobject>
				<imageobject role="html">
					<imagedata align="center" fileref="/images/booking.png" />
				</imageobject>
			</mediaobject>
			</screenshot>
			<para>
				The booking application uses JSF, EJB 3.0 and Seam, together with Facelets for the view. There is also a port of this application to JSF, Facelets, Seam, JavaBeans and Hibernate3.
			</para>
			<para>
				One of the things you&#39;ll notice if you play with this application for long enough is that it is extremely <emphasis>robust</emphasis>. You can play with back buttons and browser refresh and opening multiple windows and entering nonsensical data as much as you like and you will find it very difficult to make the application crash. You might think that we spent weeks testing and fixing bugs to achive this. Actually, this is not the case. Seam was designed to make it very straightforward to build robust web applications and a lot of robustness that you are probably used to having to code yourself comes naturally and automatically with Seam.
			</para>
			<para>
				As you browse the sourcecode of the example application, and learn how the application works, observe how the declarative state management and integrated validation has been used to achieve this robustness.
			</para>
		</section>
		
		<section>
			<title>Overview of the booking example</title>
			<para>
				The project structure is identical to the previous one, to install and deploy this application, please refer to <xref linkend="try-examples" />. Once you&#39;ve successfully started the application, you can access it by pointing your browser to <ulink url="http://localhost:8080/seam-booking/"><literal>http://localhost:8080/seam-booking/</literal></ulink>
			</para>
			<para>
				Just nine classes (plus six session beans local interfaces) where used to implement this application. Six session bean action listeners contain all the business logic for the listed features.
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<literal>BookingListAction</literal> retrieves existing bookings for the currently logged in user.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>ChangePasswordAction</literal> updates the password of the currently logged in user.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>HotelBookingAction</literal> implements the core functionality of the application: hotel room searching, selection, booking and booking confirmation. This functionality is implemented as a <emphasis>conversation</emphasis>, so this is the most interesting class in the application.
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>RegisterAction</literal> registers a new system user.
					</para>
				</listitem>
			</itemizedlist>
			<para>
				Three entity beans implement the application&#39;s persistent domain model.
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<literal>Hotel</literal> is an entity bean that represent a hotel
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>Booking</literal> is an entity bean that represents an existing booking
					</para>
				</listitem>
				<listitem>
					<para>
						<literal>User</literal> is an entity bean to represents a user who can make hotel bookings
					</para>
				</listitem>
			</itemizedlist>
		</section>
		
		<section>
			<title>Understanding Seam conversations</title>
			<para>
				We encourage you browse the sourcecode at your pleasure. In this tutorial we&#39;ll concentrate upon one particular piece of functionality: hotel search, selection, booking and confirmation. From the point of view of the user, everything from selecting a hotel to confirming a booking is one continuous unit of work, a <emphasis>conversation</emphasis>. Searching, however, is <emphasis>not</emphasis> part of the conversation. The user can select multiple hotels from the same search results page, in different browser tabs.
			</para>
			<para>
				Most web application architectures have no first class construct to represent a conversation. This causes enormous problems managing state associated with the conversation. Usually, Java web applications use a combination of two techniques: first, some state is thrown into the <literal>HttpSession</literal>; second, persistable state is flushed to the database after every request, and reconstructed from the database at the beginning of each new request.
			</para>
			<para>
				Since the database is the least scalable tier, this often results in an utterly unacceptable lack of scalability. Added latency is also a problem, due to the extra traffic to and from the database on every request. To reduce this redundant traffic, Java applications often introduce a data (second-level) cache that keeps commonly accessed data between requests. This cache is necessarily inefficient, because invalidation is based upon an LRU policy instead of being based upon when the user has finished working with the data. Furthermore, because the cache is shared between many concurrent transactions, we&#39;ve introduced a whole raft of problem&#39;s associated with keeping the cached state consistent with the database.
			</para>
			<para>
				Now consider the state held in the <literal>HttpSession</literal>. By very careful programming, we might be able to control the size of the session data. This is a lot more difficult than it sounds, since web browsers permit ad hoc non-linear navigation. But suppose we suddenly discover a system requirement that says that a user is allowed to have <emphasis>mutiple concurrent conversations</emphasis>, halfway through the development of the system (this has happened to me). Developing mechanisms to isolate session state associated with different concurrent conversations, and incorporating failsafes to ensure that conversation state is destroyed when the user aborts one of the conversations by closing a browser window or tab is not for the faint hearted (I&#39;ve implemented this stuff twice so far, once for a client application, once for Seam, but I&#39;m famously psychotic).
			</para>
			<para>
				Now there is a better way.
			</para>
			<para>
				Seam introduces the <emphasis>conversation context</emphasis> as a first class construct. You can safely keep conversational state in this context, and be assured that it will have a well-defined lifecycle. Even better, you won&#39;t need to be continually pushing data back and forth between the application server and the database, since the conversation context is a natural cache of data that the user is currently working with.
			</para>
			<para>
				Usually, the components we keep in the conversation context are stateful session beans. (We can also keep entity beans and JavaBeans in the conversation context.) There is an ancient canard in the Java community that stateful session beans are a scalability killer. This may have been true in 1998 when WebFoobar 1.0 was released. It is no longer true today. Application servers like JBoss AS have extremely sophisticated mechanisms for stateful session bean state replication. (For example, the JBoss EJB3 container performs fine-grained replication, replicating only those bean attribute values which actually changed.) Note that all the traditional technical arguments for why stateful beans are inefficient apply equally to the <literal>HttpSession</literal>, so the practice of shifting state from business tier stateful session bean components to the web session to try and improve performance is unbelievably misguided. It is certainly possible to write unscalable applications using stateful session beans, by using stateful beans incorrectly, or by using them for the wrong thing. But that doesn&#39;t mean you should <emphasis>never</emphasis> use them. Anyway, Seam guides you toward a safe usage model. Welcome to 2005.
			</para>
			<para>
				OK, I&#39;ll stop ranting now, and get back to the tutorial.
			</para>
			<para>
				The booking example application shows how stateful components with different scopes can collaborate together to achieve complex behaviors. The main page of the booking application allows the user to search for hotels. The search results are kept in the Seam session scope. When the user navigates to one of these hotels, a conversation begins, and a conversation scoped component calls back to the session scoped component to retrieve the selected hotel.
			</para>
			<para>
				The booking example also demonstrates the use of RichFaces Ajax to implement rich client behavior without the use of handwritten JavaScript.
			</para>
			<para>
				The search functionality is implemented using a session-scope stateful session bean, similar to the one we saw in the message list example above.
			</para>
			<example>
				<title></title>
				<programlistingco>
					<areaspec>
						<area coords="1" id="booking-stateful-annotation" />
						<area coords="4" id="booking-restrict-annotation" />
						<area coords="15" id="booking-datamodel-annotation" />
						<area coords="70" id="booking-destroy-annotation" />
					</areaspec>
<programlisting>@Stateful
@Name("hotelSearch")
@Scope(ScopeType.SESSION)
@Restrict("#{identity.loggedIn}")
public class HotelSearchingAction implements HotelSearching
{
   
   @PersistenceContext
   private EntityManager em;
   
   private String searchString;
   private int pageSize = 10;
   private int page;
   
   @DataModel
   private List&lt;Hotel&gt; hotels;
   
   public void find()
   {
      page = 0;
      queryHotels();
   }
   public void nextPage()
   {
      page++;
      queryHotels();
   }
      
   private void queryHotels()
   {
      hotels = 
          em.createQuery("select h from Hotel h where lower(h.name) like #{pattern} " + 
                         "or lower(h.city) like #{pattern} " + 
                         "or lower(h.zip) like #{pattern} " +
                         "or lower(h.address) like #{pattern}")
            .setMaxResults(pageSize)
            .setFirstResult( page * pageSize )
            .getResultList();
   }
   
   public boolean isNextPageAvailable()
   {
      return hotels!=null &amp;&amp; hotels.size()==pageSize;
   }
   
   public int getPageSize() {
      return pageSize;
   }
   
   public void setPageSize(int pageSize) {
      this.pageSize = pageSize;
   }
   
   @Factory(value="pattern", scope=ScopeType.EVENT)
   public String getSearchPattern()
   {
      return searchString==null ? 
            "%" : &#39;%&#39; + searchString.toLowerCase().replace(&#39;*&#39;, &#39;%&#39;) + &#39;%&#39;;
   }
   
   public String getSearchString()
   {
      return searchString;
   }
   
   public void setSearchString(String searchString)
   {
      this.searchString = searchString;
   }
   
   @Remove
   public void destroy() {}
}
</programlisting>
					<calloutlist>
						<callout arearefs="booking-stateful-annotation">
							<para>
								The EJB standard <literal>@Stateful</literal> annotation identifies this class as a stateful session bean. Stateful session beans are scoped to the conversation context by default.
							</para>
						</callout>
						<callout arearefs="booking-restrict-annotation">
							<para>
								The <literal>@Restrict</literal> annotation applies a security restriction to the component. It restricts access to the component allowing only logged-in users. The security chapter explains more about security in Seam.
							</para>
						</callout>
						<callout arearefs="booking-datamodel-annotation">
							<para>
								The <link linkend="datamodel-annotation"><literal>@DataModel</literal></link> annotation exposes a <literal>List</literal> as a JSF <literal>ListDataModel</literal>. This makes it easy to implement clickable lists for search screens. In this case, the list of hotels is exposed to the page as a <literal>ListDataModel</literal> in the conversation variable named <literal>hotels</literal>.
							</para>
						</callout>
						<callout arearefs="booking-destroy-annotation">
							<para>
								The EJB standard <literal>@Remove</literal> annotation specifies that a stateful session bean should be removed and its state destroyed after invocation of the annotated method. In Seam, all stateful session beans must define a method with no parameters marked <literal>@Remove</literal>. This method will be called when Seam destroys the session context.
							</para>
						</callout>
					</calloutlist>
				</programlistingco>

			</example>
			<para>
				The main page of the application is a Facelets page. Let&#39;s look at the fragment which relates to searching for hotels:
			</para>
			<example>
				<title></title>
				<programlistingco>
					<areaspec>
						<area coords="14" id="booking-support-element" />
						<area coords="20" id="booking-status-element" />
						<area coords="37" id="booking-outputpanel-element" />
						<area coords="61" id="booking-link-element" />
					</areaspec>
<programlisting>&lt;div class="section"&gt;
  
    &lt;span class="errors"&gt;
       &lt;h:messages globalOnly="true"/&gt;
    &lt;/span&gt;
    
    &lt;h1&gt;Search Hotels&lt;/h1&gt;

	&lt;h:form id="searchCriteria"&gt;
	&lt;fieldset&gt; 
	   &lt;h:inputText id="searchString" value="#{hotelSearch.searchString}" 
                    style="width: 165px;"&gt;
         &lt;a:support event="onkeyup" actionListener="#{hotelSearch.find}" 
                    reRender="searchResults" /&gt;
       &lt;/h:inputText&gt;
       &#160;
	   &lt;a:commandButton id="findHotels" value="Find Hotels" action="#{hotelSearch.find}" 
                        reRender="searchResults"/&gt;
       &#160;
       &lt;a:status&gt;
          &lt;f:facet name="start"&gt;
             &lt;h:graphicImage value="/img/spinner.gif"/&gt;
          &lt;/f:facet&gt;
       &lt;/a:status&gt;
	   &lt;br/&gt;
       &lt;h:outputLabel for="pageSize"&gt;Maximum results:&lt;/h:outputLabel&gt;&#160;
       &lt;h:selectOneMenu value="#{hotelSearch.pageSize}" id="pageSize"&gt;
          &lt;f:selectItem itemLabel="5" itemValue="5"/&gt;
          &lt;f:selectItem itemLabel="10" itemValue="10"/&gt;
          &lt;f:selectItem itemLabel="20" itemValue="20"/&gt;
       &lt;/h:selectOneMenu&gt;
    &lt;/fieldset&gt;
    &lt;/h:form&gt;
    
&lt;/div&gt;

&lt;a:outputPanel id="searchResults"&gt;
  &lt;div class="section"&gt;
    &lt;h:outputText value="No Hotels Found"
                  rendered="#{hotels != null and hotels.rowCount==0}"/&gt;
    &lt;h:dataTable id="hotels" value="#{hotels}" var="hot" 
                 rendered="#{hotels.rowCount&gt;0}"&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
            #{hot.name}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Address&lt;/f:facet&gt;
            #{hot.address}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;City, State&lt;/f:facet&gt;
            #{hot.city}, #{hot.state}, #{hot.country}
        &lt;/h:column&gt; 
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Zip&lt;/f:facet&gt;
            #{hot.zip}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
            &lt;s:link id="viewHotel" value="View Hotel" 
                    action="#{hotelBooking.selectHotel(hot)}"/&gt;
        &lt;/h:column&gt;
    &lt;/h:dataTable&gt;
    &lt;s:link value="More results" action="#{hotelSearch.nextPage}" 
            rendered="#{hotelSearch.nextPageAvailable}"/&gt;
  &lt;/div&gt;
&lt;/a:outputPanel&gt;
</programlisting>
					<calloutlist>
						<callout arearefs="booking-support-element">
							<para>
								The RichFaces Ajax <literal>&lt;a:support&gt;</literal> tag allows a JSF action event listener to be called by asynchronous <literal>XMLHttpRequest</literal> when a JavaScript event like <literal>onkeyup</literal> occurs. Even better, the <literal>reRender</literal> attribute lets us render a fragment of the JSF page and perform a partial page update when the asynchronous response is received.
							</para>
						</callout>
						<callout arearefs="booking-status-element">
							<para>
								The RichFaces Ajax <literal>&lt;a:status&gt;</literal> tag lets us display a cheesy annimated image while we wait for asynchronous requests to return.
							</para>
						</callout>
						<callout arearefs="booking-outputpanel-element">
							<para>
								The RichFaces Ajax <literal>&lt;a:outputPanel&gt;</literal> tag defines a region of the page which can be re-rendered by an asynchronous request.
							</para>
						</callout>
						<callout arearefs="booking-link-element">
							<para>
								The Seam <literal>&lt;s:link&gt;</literal> tag lets us attach a JSF action listener to an ordinary (non-JavaScript) HTML link. The advantage of this over the standard JSF <literal>&lt;h:commandLink&gt;</literal> is that it preserves the operation of "open in new window" and "open in new tab". Also notice that we use a method binding with a parameter: <literal>#{hotelBooking.selectHotel(hot)}</literal>. This is not possible in the standard Unified EL, but Seam provides an extension to the EL that lets you use parameters on any method binding expression.
							</para>
							<para>
								If you&#39;re wondering how navigation occurs, you can find all the rules in <literal>WEB-INF/pages.xml</literal>; this is discussed in <xref linkend="events.pageaction.navigation" />.
							</para>
						</callout>
					</calloutlist>
				</programlistingco>

			</example>
			<para>
				This page displays the search results dynamically as we type, and lets us choose a hotel and pass it to the <literal>selectHotel()</literal> method of the <literal>HotelBookingAction</literal>, which is where the <emphasis>really</emphasis> interesting stuff is going to happen.
			</para>
			<para>
				Now let&#39;s see how the booking example application uses a conversation-scoped stateful session bean to achieve a natural cache of persistent data related to the conversation. The following code example is pretty long. But if you think of it as a list of scripted actions that implement the various steps of the conversation, it&#39;s understandable. Read the class from top to bottom, as if it were a story.
			</para>
			<example>
				<title></title>
				<programlistingco>
					<areaspec>
						<area coords="7" id="booking-extendedpersistencecontext-annotation" />
						<area coords="17" id="booking-out-annotation" />
						<area coords="31" id="booking-begin-annotation" />
						<area coords="72" id="booking-end-annotation" />
						<area coords="85" id="booking-dest-annotation" />
					</areaspec>
<programlisting>@Stateful
@Name("hotelBooking")
@Restrict("#{identity.loggedIn}")
public class HotelBookingAction implements HotelBooking
{
   
   @PersistenceContext(type=EXTENDED)
   private EntityManager em;
   
   @In 
   private User user;
   
   @In(required=false) @Out
   private Hotel hotel;
   
   @In(required=false) 
   @Out(required=false)
   private Booking booking;
     
   @In
   private FacesMessages facesMessages;
      
   @In
   private Events events;
   
   @Logger 
   private Log log;
   
   private boolean bookingValid;
   
   @Begin
   public void selectHotel(Hotel selectedHotel)
   {
      hotel = em.merge(selectedHotel);
   }
   
   public void bookHotel()
   {      
      booking = new Booking(hotel, user);
      Calendar calendar = Calendar.getInstance();
      booking.setCheckinDate( calendar.getTime() );
      calendar.add(Calendar.DAY_OF_MONTH, 1);
      booking.setCheckoutDate( calendar.getTime() );
   }
   
   public void setBookingDetails()
   {
      Calendar calendar = Calendar.getInstance();
      calendar.add(Calendar.DAY_OF_MONTH, -1);
      if ( booking.getCheckinDate().before( calendar.getTime() ) )
      {
         facesMessages.addToControl("checkinDate", "Check in date must be a future date");
         bookingValid=false;
      }
      else if ( !booking.getCheckinDate().before( booking.getCheckoutDate() ) )
      {
         facesMessages.addToControl("checkoutDate", 
                                    "Check out date must be later than check in date");
         bookingValid=false;
      }
      else
      {
         bookingValid=true;
      }
   }
   
   public boolean isBookingValid()
   {
      return bookingValid;
   }
   
   @End
   public void confirm()
   {
      em.persist(booking);
      facesMessages.add("Thank you, #{user.name}, your confimation number " + 
                        " for #{hotel.name} is #{booking.id}");
      log.info("New booking: #{booking.id} for #{user.username}");
      events.raiseTransactionSuccessEvent("bookingConfirmed");
   }
   
   @End
   public void cancel() {}
   
   @Remove
   public void destroy() {}
</programlisting>
					<calloutlist>
						<callout arearefs="booking-extendedpersistencecontext-annotation">
							<para>
								This bean uses an EJB3 <emphasis>extended persistence context</emphasis>, so that any entity instances remain managed for the whole lifecycle of the stateful session bean.
							</para>
						</callout>
						<callout arearefs="booking-out-annotation">
							<para>
								The <link linkend="out-annotation"><literal>@Out</literal></link> annotation declares that an attribute value is <emphasis>outjected</emphasis> to a context variable after method invocations. In this case, the context variable named <literal>hotel</literal> will be set to the value of the <literal>hotel</literal> instance variable after every action listener invocation completes.
							</para>
						</callout>
						<callout arearefs="booking-begin-annotation">
							<para>
								The <link linkend="begin-annotation"><literal>@Begin</literal></link> annotation specifies that the annotated method begins a <emphasis>long-running conversation</emphasis>, so the current conversation context will not be destroyed at the end of the request. Instead, it will be reassociated with every request from the current window, and destroyed either by timeout due to conversation inactivity or invocation of a matching <literal>@End</literal> method.
							</para>
						</callout>
						<callout arearefs="booking-end-annotation">
							<para>
								The <link linkend="end-annotation"><literal>@End</literal></link> annotation specifies that the annotated method ends the current long-running conversation, so the current conversation context will be destroyed at the end of the request.
							</para>
						</callout>
						<callout arearefs="booking-dest-annotation">
							<para>
								This EJB remove method will be called when Seam destroys the conversation context. Don&#39;t forget to define this method!
							</para>
						</callout>
					</calloutlist>
				</programlistingco>

			</example>
			<para>
				<literal>HotelBookingAction</literal> contains all the action listener methods that implement selection, booking and booking confirmation, and holds state related to this work in its instance variables. We think you&#39;ll agree that this code is much cleaner and simpler than getting and setting <literal>HttpSession</literal> attributes.
			</para>
			<para>
				Even better, a user can have multiple isolated conversations per login session. Try it! Log in, run a search, and navigate to different hotel pages in multiple browser tabs. You&#39;ll be able to work on creating two different hotel reservations at the same time. If you leave any one conversation inactive for long enough, Seam will eventually time out that conversation and destroy its state. If, after ending a conversation, you backbutton to a page of that conversation and try to perform an action, Seam will detect that the conversation was already ended, and redirect you to the search page.
			</para>
		</section>
		
		<section>
			<title>The Seam UI control library</title>
			<para>
				If you check inside the WAR file for the booking application, you&#39;ll find <literal>seam-ui.jar</literal> in the <literal>WEB-INF/lib</literal> directory. This package contains a number of JSF custom controls that integrate with Seam. The booking application uses the <literal>&lt;s:link&gt;</literal> control for navigation from the search screen to the hotel page:
			</para>
<programlisting>&lt;s:link value="View Hotel" action="#{hotelBooking.selectHotel(hot)}"/&gt;
</programlisting>
			<para>
				The use of <literal>&lt;s:link&gt;</literal> here allows us to attach an action listener to a HTML link without breaking the browser&#39;s "open in new window" feature. The standard JSF <literal>&lt;h:commandLink&gt;</literal> does not work with "open in new window". We&#39;ll see later that <literal>&lt;s:link&gt;</literal> also offers a number of other useful features, including conversation propagation rules.
			</para>
			<para>
				The booking application uses some other Seam and RichFaces Ajax controls, especially on the <literal>/book.xhtml</literal> page. We won&#39;t get into the details of those controls here, but if you want to understand this code, please refer to the chapter covering Seam&#39;s functionality for JSF form validation.
			</para>
		</section>
		
		<section>
			<title>The Seam Debug Page</title>
			<para>
				The WAR also includes <literal>seam-debug.jar</literal>. The Seam debug page will be availabled if this jar is deployed in <literal>WEB-INF/lib</literal>, along with the Facelets, and if you set the debug property of the <literal>init</literal> component:
			</para>
<programlisting>&lt;core:init jndi-pattern="@jndiPattern@" debug="true"/&gt;
</programlisting>
			<para>
				This page lets you browse and inspect the Seam components in any of the Seam contexts associated with your current login session. Just point your browser at <ulink url="http://localhost:8080/seam-booking/debug.seam"><literal>http://localhost:8080/seam-booking/debug.seam</literal></ulink>.
			</para>
			<mediaobject>
				<imageobject role="fo">
					<imagedata align="center" fileref="/images/debug.png" />
				</imageobject>
				<imageobject role="html">
					<imagedata align="center" fileref="/images/debug.png" />
				</imageobject>
			</mediaobject>
		</section>

	</section>
	
	<section id="dvdstore">
		<title>A complete application featuring Seam and jBPM: the DVD Store example</title>
		<para>
			The DVD Store demo application shows the practical usage of jBPM for both task management and pageflow.
		</para>
		<para>
			The user screens take advantage of a jPDL pageflow to implement searching and shopping cart functionality.
		</para>
		<screenshot><screeninfo>DVD Store example</screeninfo>
		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="/images/dvdsearch.png" />
			</imageobject>
			<imageobject role="html">
				<imagedata align="center" fileref="/images/dvdsearch.png" />
			</imageobject>
		</mediaobject>
		</screenshot>
		<para>
			The administration screens take use jBPM to manage the approval and shipping cycle for orders. The business process may even be changed dynamically, by selecting a different process definition!
		</para>
		<screenshot><screeninfo>DVD Store example</screeninfo>
		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="/images/dvdtasks.png" />
			</imageobject>
			<imageobject role="html">
				<imagedata align="center" fileref="/images/dvdtasks.png" />
			</imageobject>
		</mediaobject>
		</screenshot>
		<para>
			TODO
		</para>
		<para>
			Look in the <literal>dvdstore</literal> directory.
		</para>
	</section>
	
	<section id="hibernate">
		<title>An example of Seam with Hibernate: the Hibernate Booking example</title>
		<para>
			The Hibernate Booking demo is a straight port of the Booking demo to an alternative architecture that uses Hibernate for persistence and JavaBeans instead of session beans.
		</para>
		<para>
			TODO
		</para>
		<para>
			Look in the <literal>hibernate</literal> directory.
		</para>
	</section>
	
	<section id="blog">
		<title>A RESTful Seam application: the Blog example</title>
		<para>
			Seam makes it very easy to implement applications which keep state on the server-side. However, server-side state is not always appropriate, especially in for functionality that serves up <emphasis>content</emphasis>. For this kind of problem we often need to let the user bookmark pages and have a relatively stateless server, so that any page can be accessed at any time, via the bookmark. The Blog example shows how to a implement RESTful application using Seam. Every page of the application can be bookmarked, including the search results page.
		</para>
		<screenshot><screeninfo>Blog example</screeninfo>
		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="/images/blog.png" />
			</imageobject>
			<imageobject role="html">
				<imagedata align="center" fileref="/images/blog.png" />
			</imageobject>
		</mediaobject>
		</screenshot>
		<para>
			The Blog example demonstrates the use of "pull"-style MVC, where instead of using action listener methods to retrieve data and prepare the data for the view, the view pulls data from components as it is being rendered.
		</para>
		<section>
			<title>Using "pull"-style MVC</title>
			<para>
				This snippet from the <literal>index.xhtml</literal> facelets page displays a list of recent blog entries:
			</para>
			<example>
				<title></title>
<programlisting>&lt;h:dataTable value="#{blog.recentBlogEntries}" var="blogEntry" rows="3"&gt;
   &lt;h:column&gt;
      &lt;div class="blogEntry"&gt;
         &lt;h3&gt;#{blogEntry.title}&lt;/h3&gt;
         &lt;div&gt;
            &lt;h:outputText escape="false" 
                  value="#{blogEntry.excerpt==null ? blogEntry.body : blogEntry.excerpt}"/&gt;
         &lt;/div&gt;
         &lt;p&gt;
            &lt;h:outputLink value="entry.seam" rendered="#{blogEntry.excerpt!=null}"&gt;
               &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
               Read more...
            &lt;/h:outputLink&gt;
         &lt;/p&gt;
         &lt;p&gt;
            [Posted on 
            &lt;h:outputText value="#{blogEntry.date}"&gt;
               &lt;f:convertDateTime timeZone="#{blog.timeZone}" 
                                  locale="#{blog.locale}" type="both"/&gt;
            &lt;/h:outputText&gt;]
            &#160;
            &lt;h:outputLink value="entry.seam"&gt;[Link]
               &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
            &lt;/h:outputLink&gt;
         &lt;/p&gt;
      &lt;/div&gt;
   &lt;/h:column&gt;
&lt;/h:dataTable&gt;
</programlisting>
			</example>
			<para>
				If we navigate to this page from a bookmark, how does the data used by the <literal>&lt;h:dataTable&gt;</literal> actually get initialized? Well, what happens is that the <literal>Blog</literal> is retrieved lazily—"pulled"—when needed, by a Seam component named <literal>blog</literal>. This is the opposite flow of control to what is usual in traditional web action-based frameworks like Struts.
			</para>
			<example>
				<title></title>
				<programlistingco>
					<areaspec>
						<area coords="7" id="blog-seampc" />
						<area coords="9" id="blog-unwrap" />
					</areaspec>
<programlisting>@Name("blog")
@Scope(ScopeType.STATELESS)
@AutoCreate
public class BlogService 
{
   
   @In EntityManager entityManager;
  
   @Unwrap
   public Blog getBlog()
   {
      return (Blog) entityManager.createQuery("select distinct b from Blog b left join fetch b.blogEntries")
            .setHint("org.hibernate.cacheable", true)
            .getSingleResult();
   }

}
</programlisting>
					<calloutlist>
						<callout arearefs="blog-seampc">
							<para>
								This component uses a <emphasis>seam-managed persistence context</emphasis>. Unlike the other examples we&#39;ve seen, this persistence context is managed by Seam, instead of by the EJB3 container. The persistence context spans the entire web request, allowing us to avoid any exceptions that occur when accessing unfetched associations in the view.
							</para>
						</callout>
						<callout arearefs="blog-unwrap">
							<para>
								The <literal>@Unwrap</literal> annotation tells Seam to provide the return value of the method—the <literal>Blog</literal>—instead of the actual <literal>BlogService</literal> component to clients. This is the Seam <emphasis>manager component pattern</emphasis>.
							</para>
						</callout>
					</calloutlist>
				</programlistingco>

			</example>
			<para>
				This is good so far, but what about bookmarking the result of form submissions, such as a search results page?
			</para>
		</section>
		
		<section>
			<title>Bookmarkable search results page</title>
			<para>
				The blog example has a tiny form in the top right of each page that allows the user to search for blog entries. This is defined in a file, <literal>menu.xhtml</literal>, included by the facelets template, <literal>template.xhtml</literal>:
			</para>
			<example>
				<title></title>
<programlisting>&lt;div id="search"&gt;
   &lt;h:form&gt;
      &lt;h:inputText value="#{searchAction.searchPattern}"/&gt;
      &lt;h:commandButton value="Search" action="/search.xhtml"/&gt;
   &lt;/h:form&gt;
&lt;/div&gt;
</programlisting>
			</example>
			<para>
				To implement a bookmarkable search results page, we need to perform a browser redirect after processing the search form submission. Because we used the JSF view id as the action outcome, Seam automatically redirects to the view id when the form is submitted. Alternatively, we could have defined a navigation rule like this:
			</para>
			<example>
				<title></title>
<programlisting>&lt;navigation-rule&gt;
   &lt;navigation-case&gt;
      &lt;from-outcome&gt;searchResults&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/search.xhtml&lt;/to-view-id&gt;
      &lt;redirect/&gt;
   &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;
</programlisting>
			</example>
			<para>
				Then the form would have looked like this:
			</para>
			<example>
				<title></title>
<programlisting>&lt;div id="search"&gt;
   &lt;h:form&gt;
      &lt;h:inputText value="#{searchAction.searchPattern}"/&gt;
      &lt;h:commandButton value="Search" action="searchResults"/&gt;
   &lt;/h:form&gt;
&lt;/div&gt;
</programlisting>
			</example>
			<para>
				But when we redirect, we need to include the values submitted with the form as request parameters, to get a bookmarkable URL like <literal>http://localhost:8080/seam-blog/search.seam?searchPattern=seam</literal>. JSF does not provide an easy way to do this, but Seam does. We use a Seam <emphasis>page parameter</emphasis>, defined in <literal>WEB-INF/pages.xml</literal>:
			</para>
			<example>
				<title></title>
<programlisting>&lt;pages&gt;
   &lt;page view-id="/search.xhtml"&gt;
      &lt;param name="searchPattern" value="#{searchService.searchPattern}"/&gt;
   &lt;/page&gt;
   ...
&lt;/pages&gt;
</programlisting>
			</example>
			<para>
				This tells Seam to include the value of <literal>#{searchService.searchPattern}</literal> as a request parameter named <literal>searchPattern</literal> when redirecting to the page, and then re-apply the value of that parameter to the model before rendering the page.
			</para>
			<para>
				The redirect takes us to the <literal>search.xhtml</literal> page:
			</para>
			<example>
				<title></title>
<programlisting>&lt;h:dataTable value="#{searchResults}" var="blogEntry"&gt;
   &lt;h:column&gt;
      &lt;div&gt;
         &lt;h:outputLink value="entry.seam"&gt;
            &lt;f:param name="blogEntryId" value="#{blogEntry.id}"/&gt;
            #{blogEntry.title}
         &lt;/h:outputLink&gt;
         posted on 
         &lt;h:outputText value="#{blogEntry.date}"&gt;
            &lt;f:convertDateTime timeZone="#{blog.timeZone}" locale="#{blog.locale}" type="both"/&gt;
         &lt;/h:outputText&gt;
      &lt;/div&gt;
   &lt;/h:column&gt;
&lt;/h:dataTable&gt;
</programlisting>
			</example>
			<para>
				Which again uses "pull"-style MVC to retrieve the actual search results:
			</para>
			<example>
				<title></title>
<programlisting>@Name("searchService")
public class SearchService 
{
   
   @In
   private EntityManager entityManager;
   
   private String searchPattern;
   
   @Factory("searchResults")
   public List&lt;BlogEntry&gt; getSearchResults()
   {
      if (searchPattern==null)
      {
         return null;
      }
      else
      {
         return entityManager.createQuery("select be from BlogEntry be "" + 
                      "where lower(be.title) like :searchPattern " + 
                      "lower(be.body) like :searchPattern order by be.date desc")
               .setParameter( "searchPattern", getSqlSearchPattern() )
               .setMaxResults(100)
               .getResultList();
      }
   }

   private String getSqlSearchPattern()
   {
      return searchPattern==null ? "" :
             &#39;%&#39; + searchPattern.toLowerCase().replace(&#39;*&#39;, &#39;%&#39;).replace(&#39;?&#39;, &#39;_&#39;) + &#39;%&#39;;
   }

   public String getSearchPattern()
   {
      return searchPattern;
   }

   public void setSearchPattern(String searchPattern)
   {
      this.searchPattern = searchPattern;
   }

}
</programlisting>
			</example>
		</section>
		
		<section>
			<title>Using "push"-style MVC in a RESTful application</title>
			<para>
				Very occasionally, it makes more sense to use push-style MVC for processing RESTful pages, and so Seam provides the notion of a <emphasis>page action</emphasis>. The Blog example uses a page action for the blog entry page, <literal>entry.xhtml</literal>. Note that this is a little bit contrived, it would have been easier to use pull-style MVC here as well.
			</para>
			<para>
				The <literal>entryAction</literal> component works much like an action class in a traditional push-MVC action-oriented framework like Struts:
			</para>
			<example>
				<title></title>
<programlisting>@Name("entryAction")
@Scope(STATELESS)
public class EntryAction
{
   @In(create=true) 
   private Blog blog;
   
   @Out
   private BlogEntry blogEntry;
   
   public void loadBlogEntry(String id) throws EntryNotFoundException
   {
      blogEntry = blog.getBlogEntry(id);
      if (blogEntry==null) throw new EntryNotFoundException(id);
   }
   
}
</programlisting>
			</example>
			<para>
				Page actions are also declared in <literal>pages.xml</literal>:
			</para>
			<example>
				<title></title>
<programlisting>&lt;pages&gt;
   ...

   &lt;page view-id="/entry.xhtml" action="#{entryAction.loadBlogEntry(blogEntry.id)}"&gt;
      &lt;param name="blogEntryId" value="#{blogEntry.id}"/&gt;
   &lt;/page&gt;

   &lt;page view-id="/post.xhtml" action="#{loginAction.challenge}"/&gt;

   &lt;page view-id="*" action="#{blog.hitCount.hit}"/&gt;

&lt;/pages&gt;
</programlisting>
			</example>
			<para>
				Notice that the example is using page actions for some other functionality—the login challenge, and the pageview counter. Also notice the use of a parameter in the page action method binding. This is not a standard feature of JSF EL, but Seam lets you use it, not just for page actions, but also in JSF method bindings.
			</para>
			<para>
				When the <literal>entry.xhtml</literal> page is requested, Seam first binds the page parameter <literal>blogEntryId</literal> to the model, then runs the page action, which retrieves the needed data—the <literal>blogEntry</literal>—and places it in the Seam event context. Finally, the following is rendered:
			</para>
			<example>
				<title></title>
<programlisting>&lt;div class="blogEntry"&gt;
   &lt;h3&gt;#{blogEntry.title}&lt;/h3&gt;
   &lt;div&gt;
      &lt;h:outputText escape="false" value="#{blogEntry.body}"/&gt;
   &lt;/div&gt;
   &lt;p&gt;
      [Posted on&#160;
      &lt;h:outputText value="#{blogEntry.date}"&gt;
         &lt;f:convertDateTime timezone="#{blog.timeZone}" 
                            locale="#{blog.locale}" type="both"/&gt;
      &lt;/h:outputText&gt;]
   &lt;/p&gt;
&lt;/div&gt;
</programlisting>
			</example>
			<para>
				If the blog entry is not found in the database, the <literal>EntryNotFoundException</literal> exception is thrown. We want this exception to result in a 404 error, not a 505, so we annotate the exception class:
			</para>
			<example>
				<title></title>
<programlisting>@ApplicationException(rollback=true)
@HttpError(errorCode=HttpServletResponse.SC_NOT_FOUND)
public class EntryNotFoundException extends Exception
{
   EntryNotFoundException(String id)
   {
      super("entry not found: " + id);
   }
}
</programlisting>
			</example>
			<para>
				An alternative implementation of the example does not use the parameter in the method binding:
			</para>
			<example>
				<title></title>
<programlisting>@Name("entryAction")
@Scope(STATELESS)
public class EntryAction
{
   @In(create=true) 
   private Blog blog;
   
   @In @Out
   private BlogEntry blogEntry;
   
   public void loadBlogEntry() throws EntryNotFoundException
   {
      blogEntry = blog.getBlogEntry( blogEntry.getId() );
      if (blogEntry==null) throw new EntryNotFoundException(id);
   }
   
}
</programlisting>
<programlisting>&lt;pages&gt;
   ...

   &lt;page view-id="/entry.xhtml" action="#{entryAction.loadBlogEntry}"&gt;
      &lt;param name="blogEntryId" value="#{blogEntry.id}"/&gt;
   &lt;/page&gt;
   
   ...
&lt;/pages&gt;
</programlisting>
			</example>
			<para>
				It is a matter of taste which implementation you prefer.
			</para>
		</section>

	</section>

</chapter>

