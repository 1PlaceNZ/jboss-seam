<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % RH_ENTITIES SYSTEM "Common_Content/Entities.ent">
%RH_ENTITIES;
<!ENTITY % RH_TRANS_ENTITIES SYSTEM "Common_Content/Translatable-Entities.ent">
%RH_TRANS_ENTITIES;
]>

<chapter id="jbpm">
	<title>Pageflows and business processes</title>
	<para>
		JBoss jBPM is a business process management engine for any Java SE or EE environment. jBPM lets you represent a business process or user interaction as a graph of nodes representing wait states, decisions, tasks, web pages, etc. The graph is defined using a simple, very readable, XML dialect called jPDL, and may be edited and visualised graphically using an eclipse plugin. jPDL is an extensible language, and is suitable for a range of problems, from defining web application page flow, to traditional workflow management, all the way up to orchestration of services in a SOA environment.
	</para>
	<para>
		Seam applications use jBPM for two different problems:
	</para>
	<itemizedlist>
		<listitem>
			<para>
				Defining the pageflow involved in complex user interactions. A jPDL process definition defines the page flow for a single conversation. A Seam conversation is considered to be a relatively short-running interaction with a single user.
			</para>
		</listitem>
		<listitem>
			<para>
				Defining the overarching business process. The business process may span multiple conversations with multiple users. Its state is persistent in the jBPM database, so it is considered long-running. Coordination of the activities of multiple users is a much more complex problem than scripting an interaction with a single user, so jBPM offers sophisticated facilities for task management and dealing with multiple concurrent paths of execution.
			</para>
		</listitem>
	</itemizedlist>
	<para>
		Don&#39;t get these two things confused ! They operate at very different levels or granularity. <emphasis>Pageflow</emphasis>, <emphasis>conversation</emphasis> and <emphasis>task</emphasis> all refer to a single interaction with a single user. A business process spans many tasks. Futhermore, the two applications of jBPM are totally orthogonal. You can use them together or independently or not at all.
	</para>
	<para>
		You don&#39;t have to know jDPL to use Seam. If you&#39;re perfectly happy defining pageflow using JSF or Seam navigation rules, and if your application is more data-driven that process-driven, you probably don&#39;t need jBPM. But we&#39;re finding that thinking of user interaction in terms of a well-defined graphical representation is helping us build more robust applications.
	</para>
	<section>
		<title>Pageflow in Seam</title>
		<para>
			There are two ways to define pageflow in Seam:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					Using JSF or Seam navigation rules - the <emphasis>stateless navigation model</emphasis>
				</para>
			</listitem>
			<listitem>
				<para>
					Using jPDL - the <emphasis>stateful navigation model</emphasis>
				</para>
			</listitem>
		</itemizedlist>
		<para>
			Very simple applications will only need the stateless navigation model. Very complex applications will use both models in different places. Each model has its strengths and weaknesses!
		</para>
		<section>
			<title>The two navigation models</title>
			<para>
				The stateless model defines a mapping from a set of named, logical outcomes of an event directly to the resulting page of the view. The navigation rules are entirely oblivious to any state held by the application other than what page was the source of the event. This means that your action listener methods must sometimes make decisions about the page flow, since only they have access to the current state of the application.
			</para>
			<para>
				Here is an example page flow definition using JSF navigation rules:
			</para>
<programlisting>&lt;navigation-rule&gt;
    &lt;from-view-id&gt;/numberGuess.jsp&lt;/from-view-id&gt;
        
    &lt;navigation-case&gt;
        &lt;from-outcome&gt;guess&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/numberGuess.jsp&lt;/to-view-id&gt;
        &lt;redirect/&gt;
    &lt;/navigation-case&gt;

    &lt;navigation-case&gt;
        &lt;from-outcome&gt;win&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/win.jsp&lt;/to-view-id&gt;
        &lt;redirect/&gt;
    &lt;/navigation-case&gt;
        
    &lt;navigation-case&gt;
        &lt;from-outcome&gt;lose&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/lose.jsp&lt;/to-view-id&gt;
        &lt;redirect/&gt;
    &lt;/navigation-case&gt;

&lt;/navigation-rule&gt;
</programlisting>
			<para>
				Here is the same example page flow definition using Seam navigation rules:
			</para>
<programlisting>&lt;page view-id="/numberGuess.jsp"&gt;
        
    &lt;navigation&gt;
        &lt;rule if-outcome="guess"&gt;
            &lt;redirect view-id="/numberGuess.jsp"/&gt;
        &lt;/rule&gt;
        &lt;rule if-outcome="win"&gt;
            &lt;redirect view-id="/win.jsp"/&gt;
        &lt;/rule&gt;
        &lt;rule if-outcome="lose"&gt;
            &lt;redirect view-id="/lose.jsp"/&gt;
        &lt;/rule&gt;
    &lt;/navigation&gt;

&lt;/page&gt;
</programlisting>
			<para>
				If you find navigation rules overly verbose, you can return view ids directly from your action listener methods:
			</para>
<programlisting>public String guess() {
    if (guess==randomNumber) return "/win.jsp";
    if (++guessCount==maxGuesses) return "/lose.jsp";
    return null;
}
</programlisting>
			<para>
				Note that this results in a redirect. You can even specify parameters to be used in the redirect:
			</para>
<programlisting>public String search() {
    return "/searchResults.jsp?searchPattern=#{searchAction.searchPattern}";
}
</programlisting>
			<para>
				The stateful model defines a set of transitions between a set of named, logical application states. In this model, it is possible to express the flow of any user interaction entirely in the jPDL pageflow definition, and write action listener methods that are completely unaware of the flow of the interaction.
			</para>
			<para>
				Here is an example page flow definition using jPDL:
			</para>
<programlisting>&lt;pageflow-definition name="numberGuess"&gt;
    
   &lt;start-page name="displayGuess" view-id="/numberGuess.jsp"&gt;
      &lt;redirect/&gt;
      &lt;transition name="guess" to="evaluateGuess"&gt;
      	&lt;action expression="#{numberGuess.guess}" /&gt;
      &lt;/transition&gt;
   &lt;/start-page&gt;
   
   &lt;decision name="evaluateGuess" expression="#{numberGuess.correctGuess}"&gt;
      &lt;transition name="true" to="win"/&gt;
      &lt;transition name="false" to="evaluateRemainingGuesses"/&gt;
   &lt;/decision&gt;
   
   &lt;decision name="evaluateRemainingGuesses" expression="#{numberGuess.lastGuess}"&gt;
      &lt;transition name="true" to="lose"/&gt;
      &lt;transition name="false" to="displayGuess"/&gt;
   &lt;/decision&gt;
   
   &lt;page name="win" view-id="/win.jsp"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation /&gt;
   &lt;/page&gt;
   
   &lt;page name="lose" view-id="/lose.jsp"&gt;
      &lt;redirect/&gt;
      &lt;end-conversation /&gt;
   &lt;/page&gt;
   
&lt;/pageflow-definition&gt;
</programlisting>
			<mediaobject>
				<imageobject role="fo">
					<imagedata align="center" fileref="/images/plugin-jbpm-numguess.png" />
				</imageobject>
				<imageobject role="html">
					<imagedata align="center" fileref="/images/plugin-jbpm-numguess.png" />
				</imageobject>
			</mediaobject>
			<para>
				There are two things we notice immediately here:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						The JSF/Seam navigation rules are <emphasis>much</emphasis> simpler. (However, this obscures the fact that the underlying Java code is more complex.)
					</para>
				</listitem>
				<listitem>
					<para>
						The jPDL makes the user interaction immediately understandable, without us needing to even look at the JSP or Java code.
					</para>
				</listitem>
			</itemizedlist>
			<para>
				In addition, the stateful model is more <emphasis>constrained</emphasis>. For each logical state (each step in the page flow), there are a constrained set of possible transitions to other states. The stateless model is an <emphasis>ad hoc</emphasis> model which is suitable to relatively unconstrained, freeform navigation where the user decides where he/she wants to go next, not the application.
			</para>
			<para>
				The stateful/stateless navigation distinction is quite similar to the traditional view of modal/modeless interaction. Now, Seam applications are not usually modal in the simple sense of the word - indeed, avoiding application modal behavior is one of the main reasons for having conversations! However, Seam applications can be, and often are, modal at the level of a particular conversation. It is well-known that modal behavior is something to avoid as much as possible; it is very difficult to predict the order in which your users are going to want to do things! However, there is no doubt that the stateful model has its place.
			</para>
			<para>
				The biggest contrast between the two models is the back-button behavior.
			</para>
		</section>
		
		<section>
			<title>Seam and the back button</title>
			<para>
				When JSF or Seam navigation rules are used, Seam lets the user freely navigate via the back, forward and refresh buttons. It is the responsibility of the application to ensure that conversational state remains internally consistent when this occurs. Experience with the combination of web application frameworks like Struts or WebWork - that do not support a conversational model - and stateless component models like EJB stateless session beans or the Spring framework has taught many developers that this is close to impossible to do! However, our experience is that in the context of Seam, where there is a well-defined conversational model, backed by stateful session beans, it is actually quite straightforward. Usually it is as simple as combining the use of <literal>no-conversation-view-id</literal> with null checks at the beginning of action listener methods. We consider support for freeform navigation to be almost always desirable.
			</para>
			<para>
				In this case, the <literal>no-conversation-view-id</literal> declaration goes in <literal>pages.xml</literal>. It tells Seam to redirect to a different page if a request originates from a page rendered during a conversation, and that conversation no longer exists:
			</para>
<programlisting>&lt;page view-id="/checkout.xhtml" 
        no-conversation-view-id="/main.xhtml"/&gt;
</programlisting>
			<para>
				On the other hand, in the stateful model, backbuttoning is interpreted as an undefined transition back to a previous state. Since the stateful model enforces a defined set of transitions from the current state, back buttoning is by default disallowed in the stateful model! Seam transparently detects the use of the back button, and blocks any attempt to perform an action from a previous, "stale" page, and simply redirects the user to the "current" page (and displays a faces message). Whether you consider this a feature or a limitation of the stateful model depends upon your point of view: as an application developer, it is a feature; as a user, it might be frustrating! You can enable backbutton navigation from a particular page node by setting <literal>back="enabled"</literal>.
			</para>
<programlisting>&lt;page name="checkout" 
        view-id="/checkout.xhtml" 
        back="enabled"&gt;
    &lt;redirect/&gt;
    &lt;transition to="checkout"/&gt;
    &lt;transition name="complete" to="complete"/&gt;
&lt;/page&gt;
</programlisting>
			<para>
				This allows backbuttoning <emphasis>from</emphasis> the <literal>checkout</literal> state to <emphasis>any previous state!</emphasis>
			</para>
			<para>
				Of course, we still need to define what happens if a request originates from a page rendered during a pageflow, and the conversation with the pageflow no longer exists. In this case, the <literal>no-conversation-view-id</literal> declaration goes into the pageflow definition:
			</para>
<programlisting>&lt;page name="checkout" 
        view-id="/checkout.xhtml" 
        back="enabled" 
        no-conversation-view-id="/main.xhtml"&gt;
    &lt;redirect/&gt;
    &lt;transition to="checkout"/&gt;
    &lt;transition name="complete" to="complete"/&gt;
&lt;/page&gt;
</programlisting>
			<para>
				In practice, both navigation models have their place, and you&#39;ll quickly learn to recognize when to prefer one model over the other.
			</para>
		</section>

	</section>
	
	<section>
		<title>Using jPDL pageflows</title>
		<section>
			<title>Installing pageflows</title>
			<para>
				We need to install the Seam jBPM-related components, and tell them where to find our pageflow definition. We can specify this Seam configuration in <literal>components.xml</literal>.
			</para>
<programlisting>&lt;bpm:jbpm&gt;
    &lt;bpm:pageflow-definitions&gt;
        &lt;value&gt;pageflow.jpdl.xml&lt;/value&gt;
    &lt;/bpm:pageflow-definitions&gt;
&lt;/bpm:jbpm&gt;
</programlisting>
			<para>
				The first line installs jBPM, the second points to a jPDL-based pageflow definition.
			</para>
		</section>
		
		<section>
			<title>Starting pageflows</title>
			<para>
				We "start" a jPDL-based pageflow by specifying the name of the process definition using a <literal>@Begin</literal>, <literal>@BeginTask</literal> or <literal>@StartTask</literal> annotation:
			</para>
<programlisting>@Begin(pageflow="numberguess")
public void begin() { ... }
</programlisting>
			<para>
				Alternatively we can start a pageflow using pages.xml:
			</para>
<programlisting>&lt;page&gt;
        &lt;begin-conversation pageflow="numberguess"/&gt;
    &lt;/page&gt;
</programlisting>
			<para>
				If we are beginning the pageflow during the <literal>RENDER_RESPONSE</literal> phase—during a <literal>@Factory</literal> or <literal>@Create</literal> method, for example—we consider ourselves to be already at the page being rendered, and use a <literal>&lt;start-page&gt;</literal> node as the first node in the pageflow, as in the example above.
			</para>
			<para>
				But if the pageflow is begun as the result of an action listener invocation, the outcome of the action listener determines which is the first page to be rendered. In this case, we use a <literal>&lt;start-state&gt;</literal> as the first node in the pageflow, and declare a transition for each possible outcome:
			</para>
<programlisting>&lt;pageflow-definition name="viewEditDocument"&gt;

    &lt;start-state name="start"&gt;
        &lt;transition name="documentFound" to="displayDocument"/&gt;
        &lt;transition name="documentNotFound" to="notFound"/&gt;
    &lt;/start-state&gt;
    
    &lt;page name="displayDocument" view-id="/document.jsp"&gt;
        &lt;transition name="edit" to="editDocument"/&gt;
        &lt;transition name="done" to="main"/&gt;
    &lt;/page&gt;
    
    ...
    
    &lt;page name="notFound" view-id="/404.jsp"&gt;
        &lt;end-conversation/&gt;
    &lt;/page&gt;
    
&lt;/pageflow-definition&gt;
</programlisting>
		</section>
		
		<section>
			<title>Page nodes and transitions</title>
			<para>
				Each <literal>&lt;page&gt;</literal> node represents a state where the system is waiting for user input:
			</para>
<programlisting>&lt;page name="displayGuess" view-id="/numberGuess.jsp"&gt;
    &lt;redirect/&gt;
    &lt;transition name="guess" to="evaluateGuess"&gt;
        &lt;action expression="#{numberGuess.guess}" /&gt;
    &lt;/transition&gt;
&lt;/page&gt;
</programlisting>
			<para>
				The <literal>view-id</literal> is the JSF view id. The <literal>&lt;redirect/&gt;</literal> element has the same effect as <literal>&lt;redirect/&gt;</literal> in a JSF navigation rule: namely, a post-then-redirect behavior, to overcome problems with the browser&#39;s refresh button. (Note that Seam propagates conversation contexts over these browser redirects. So there is no need for a Ruby on Rails style "flash" construct in Seam!)
			</para>
			<para>
				The transition name is the name of a JSF outcome triggered by clicking a command button or command link in <literal>numberGuess.jsp</literal>.
			</para>
<programlisting>&lt;h:commandButton type="submit" value="Guess" action="guess"/&gt;
</programlisting>
			<para>
				When the transition is triggered by clicking this button, jBPM will activate the transition action by calling the <literal>guess()</literal> method of the <literal>numberGuess</literal> component. Notice that the syntax used for specifying actions in the jPDL is just a familiar JSF EL expression, and that the transition action handler is just a method of a Seam component in the current Seam contexts. So we have exactly the same event model for jBPM events that we already have for JSF events! (The <emphasis>One Kind of Stuff</emphasis> principle.)
			</para>
			<para>
				In the case of a null outcome (for example, a command button with no <literal>action</literal> defined), Seam will signal the transition with no name if one exists, or else simply redisplay the page if all transitions have names. So we could slightly simplify our example pageflow and this button:
			</para>
<programlisting>&lt;h:commandButton type="submit" value="Guess"/&gt;
</programlisting>
			<para>
				Would fire the following un-named transition:
			</para>
<programlisting>&lt;page name="displayGuess" view-id="/numberGuess.jsp"&gt;
    &lt;redirect/&gt;
    &lt;transition to="evaluateGuess"&gt;
        &lt;action expression="#{numberGuess.guess}" /&gt;
    &lt;/transition&gt;
&lt;/page&gt;
</programlisting>
			<para>
				It is even possible to have the button call an action method, in which case the action outcome will determine the transition to be taken:
			</para>
<programlisting>&lt;h:commandButton type="submit" value="Guess" action="#{numberGuess.guess}"/&gt;
</programlisting>
<programlisting>&lt;page name="displayGuess" view-id="/numberGuess.jsp"&gt;
    &lt;transition name="correctGuess" to="win"/&gt;
    &lt;transition name="incorrectGuess" to="evaluateGuess"/&gt;
&lt;/page&gt;
</programlisting>
			<para>
				However, this is considered an inferior style, since it moves responsibility for controlling the flow out of the pageflow definition and back into the other components. It is much better to centralize this concern in the pageflow itself.
			</para>
		</section>
		
		<section>
			<title>Controlling the flow</title>
			<para>
				Usually, we don&#39;t need the more powerful features of jPDL when defining pageflows. We do need the <literal>&lt;decision&gt;</literal> node, however:
			</para>
<programlisting>&lt;decision name="evaluateGuess" expression="#{numberGuess.correctGuess}"&gt;
    &lt;transition name="true" to="win"/&gt;
    &lt;transition name="false" to="evaluateRemainingGuesses"/&gt;
&lt;/decision&gt;
</programlisting>
			<para>
				A decision is made by evaluating a JSF EL expression in the Seam contexts.
			</para>
		</section>
		
		<section>
			<title>Ending the flow</title>
			<para>
				We end the conversation using <literal>&lt;end-conversation&gt;</literal> or <literal>@End</literal>. (In fact, for readability, use of <emphasis>both</emphasis> is encouraged.)
			</para>
<programlisting>&lt;page name="win" view-id="/win.jsp"&gt;
    &lt;redirect/&gt;
    &lt;end-conversation/&gt;
&lt;/page&gt;
</programlisting>
			<para>
				Optionally, we can end a task, specify a jBPM <literal>transition</literal> name. In this case, Seam will signal the end of the current task in the overarching business process.
			</para>
<programlisting>&lt;page name="win" view-id="/win.jsp"&gt;
    &lt;redirect/&gt;
    &lt;end-task transition="success"/&gt;
&lt;/page&gt;
</programlisting>
		</section>
		
		<section>
			<title>Pageflow composition</title>
			<para>
				It is possible to compose pageflows and have one pageflow pause pause while another pageflow executes. The <literal>&lt;process-state&gt;</literal> node pauses the outer pageflow, and begins execution of a named pageflow:
			</para>
<programlisting>&lt;process-state name="cheat"&gt;
    &lt;sub-process name="cheat"/&gt;
    &lt;transition to="displayGuess"/&gt;
&lt;/process-state&gt;
</programlisting>
			<para>
				The inner flow begins executing at a <literal>&lt;start-state&gt;</literal> node. When it reaches an <literal>&lt;end-state&gt;</literal> node, execution of the inner flow ends, and execution of the outer flow resumes with the transition defined by the <literal>&lt;process-state&gt;</literal> element.
			</para>
		</section>

	</section>
	
	<section>
		<title>Business process management in Seam</title>
		<para>
			A business process is a well-defined set of tasks that must be performed by users or software systems according to well-defined rules about <emphasis>who</emphasis> can perform a task, and <emphasis>when</emphasis> it should be performed. Seam&#39;s jBPM integration makes it easy to display lists of tasks to users and let them manage their tasks. Seam also lets the application store state associated with the business process in the <literal>BUSINESS_PROCESS</literal> context, and have that state made persistent via jBPM variables.
		</para>
		<para>
			A simple business process definition looks much the same as a page flow definition (<emphasis>One Kind of Stuff</emphasis>), except that instead of <literal>&lt;page&gt;</literal> nodes, we have <literal>&lt;task-node&gt;</literal> nodes. In a long-running business process, the wait states are where the system is waiting for some user to log in and perform a task.
		</para>
<programlisting>&lt;process-definition name="todo"&gt;
   
   &lt;start-state name="start"&gt;
      &lt;transition to="todo"/&gt;
   &lt;/start-state&gt;
   
   &lt;task-node name="todo"&gt;
      &lt;task name="todo" description="#{todoList.description}"&gt;
         &lt;assignment actor-id="#{actor.id}"/&gt;
      &lt;/task&gt;
      &lt;transition to="done"/&gt;
   &lt;/task-node&gt;
   
   &lt;end-state name="done"/&gt;
   
&lt;/process-definition&gt;
</programlisting>
		<mediaobject>
			<imageobject role="fo">
				<imagedata align="center" fileref="/images/plugin-jbpm-todo.png" />
			</imageobject>
			<imageobject role="html">
				<imagedata align="center" fileref="/images/plugin-jbpm-todo.png" />
			</imageobject>
		</mediaobject>
		<para>
			It is perfectly possible that we might have both jPDL business process definitions and jPDL pageflow definitions in the same project. If so, the relationship between the two is that a single <literal>&lt;task&gt;</literal> in a business process corresponds to a whole pageflow <literal>&lt;pageflow-definition&gt;</literal>
		</para>
	</section>
	
	<section>
		<title>Using jPDL business process definitions</title>
		<section>
			<title>Installing process definitions</title>
			<para>
				We need to install jBPM, and tell it where to find the business process definitions:
			</para>
<programlisting>&lt;bpm:jbpm&gt;
    &lt;bpm:process-definitions&gt;
        &lt;value&gt;todo.jpdl.xml&lt;/value&gt;
    &lt;/bpm:process-definitions&gt;
&lt;/bpm:jbpm&gt;
</programlisting>
			<para>
				As jBPM processes are persistent across application restarts, when using Seam in a production environment you won&#39;t want to install the process definition every time the application starts. Therefore, in a production environment, you&#39;ll need to deploy the process to jBPM outside of Seam. In other words, only install process definitions from <literal>components.xml</literal> when developing your application.
			</para>
		</section>
		
		<section>
			<title>Initializing actor ids</title>
			<para>
				We always need to know what user is currently logged in. jBPM "knows" users by their <emphasis>actor id</emphasis> and <emphasis>group actor ids</emphasis>. We specify the current actor ids using the built in Seam component named <literal>actor</literal>:
			</para>
<programlisting>@In Actor actor;

public String login() {
    ...
    actor.setId( user.getUserName() );
    actor.getGroupActorIds().addAll( user.getGroupNames() );
    ...
}
</programlisting>
		</section>
		
		<section>
			<title>Initiating a business process</title>
			<para>
				To initiate a business process instance, we use the <literal>@CreateProcess</literal> annotation:
			</para>
<programlisting>@CreateProcess(definition="todo")
public void createTodo() { ... }
</programlisting>
			<para>
				Alternatively we can initiate a business process using pages.xml:
			</para>
<programlisting>&lt;page&gt;
    &lt;create-process definition="todo" /&gt;
&lt;/page&gt;
</programlisting>
		</section>
		
		<section>
			<title>Task assignment</title>
			<para>
				When a process reaches a task node, task instances are created. These must be assigned to users or user groups. We can either hardcode our actor ids, or delegate to a Seam component:
			</para>
<programlisting>&lt;task name="todo" description="#{todoList.description}"&gt;
    &lt;assignment actor-id="#{actor.id}"/&gt;
&lt;/task&gt;
</programlisting>
			<para>
				In this case, we have simply assigned the task to the current user. We can also assign tasks to a pool:
			</para>
<programlisting>&lt;task name="todo" description="#{todoList.description}"&gt;
    &lt;assignment pooled-actors="employees"/&gt;
&lt;/task&gt;
</programlisting>
		</section>
		
		<section>
			<title>Task lists</title>
			<para>
				Several built-in Seam components make it easy to display task lists. The <literal>pooledTaskInstanceList</literal> is a list of pooled tasks that users may assign to themselves:
			</para>
<programlisting>&lt;h:dataTable value="#{pooledTaskInstanceList}" var="task"&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Description&lt;/f:facet&gt;
        &lt;h:outputText value="#{task.description}"/&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
        &lt;s:link action="#{pooledTask.assignToCurrentActor}" value="Assign" taskInstance="#{task}"/&gt;
    &lt;/h:column&gt;            	
&lt;/h:dataTable&gt;
</programlisting>
			<para>
				Note that instead of <literal>&lt;s:link&gt;</literal> we could have used a plain JSF <literal>&lt;h:commandLink&gt;</literal>:
			</para>
<programlisting>&lt;h:commandLink action="#{pooledTask.assignToCurrentActor}"&gt; 
    &lt;f:param name="taskId" value="#{task.id}"/&gt;
&lt;/h:commandLink&gt;
</programlisting>
			<para>
				The <literal>pooledTask</literal> component is a built-in component that simply assigns the task to the current user.
			</para>
			<para>
				The <literal>taskInstanceListForType</literal> component includes tasks of a particular type that are assigned to the current user:
			</para>
<programlisting>&lt;h:dataTable value="#{taskInstanceListForType[&#39;todo&#39;]}" var="task"&gt;
    &lt;h:column&gt;
        &lt;f:facet name="header"&gt;Description&lt;/f:facet&gt;
        &lt;h:outputText value="#{task.description}"/&gt;
    &lt;/h:column&gt;
    &lt;h:column&gt;
        &lt;s:link action="#{todoList.start}" value="Start Work" taskInstance="#{task}"/&gt;
    &lt;/h:column&gt;            	
&lt;/h:dataTable&gt;
</programlisting>
		</section>
		
		<section>
			<title>Performing a task</title>
			<para>
				To begin work on a task, we use either <literal>@StartTask</literal> or <literal>@BeginTask</literal> on the listener method:
			</para>
<programlisting>@StartTask
public String start() { ... }
</programlisting>
			<para>
				Alternatively we can begin work on a task using pages.xml:
			</para>
<programlisting>&lt;page&gt;
    &lt;start-task /&gt;
&lt;/page&gt;
</programlisting>
			<para>
				These annotations begin a special kind of conversation that has significance in terms of the overarching business process. Work done by this conversation has access to state held in the business process context.
			</para>
			<para>
				If we end the conversation using <literal>@EndTask</literal>, Seam will signal the completion of the task:
			</para>
<programlisting>@EndTask(transition="completed")
public String completed() { ... }
</programlisting>
			<para>
				Alternatively we can use pages.xml:
			</para>
<programlisting>&lt;page&gt;
    &lt;end-task transition="completed" /&gt;
&lt;/page&gt;
</programlisting>
			<para>
				You can also use EL to specify the transition in pages.xml.
			</para>
			<para>
				At this point, jBPM takes over and continues executing the business process definition. (In more complex processes, several tasks might need to be completed before process execution can resume.)
			</para>
			<para>
				Please refer to the jBPM documentation for a more thorough overview of the sophisticated features that jBPM provides for managing complex business processes.
			</para>
		</section>

	</section>

</chapter>

