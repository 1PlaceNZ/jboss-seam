<?xml version='1.0'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % RH_ENTITIES SYSTEM "Common_Content/Entities.ent">
%RH_ENTITIES;
<!ENTITY % RH_TRANS_ENTITIES SYSTEM "Common_Content/Translatable-Entities.ent">
%RH_TRANS_ENTITIES;
]>

<chapter id="framework">
	<title>The Seam Application Framework</title>
	<para>
		Seam makes it really easy to create applications by writing plain Java classes with annotations, which don&#39;t need to extend any special interfaces or superclasses. But we can simplify some common programming tasks even further, by providing a set of pre-built components which can be re-used either by configuration in <literal>components.xml</literal> (for very simple cases) or extension.
	</para>
	<para>
		The <emphasis>Seam Application Framework</emphasis> can reduce the amount of code you need to write when doing basic database access in a web application, using either Hibernate or JPA.
	</para>
	<para>
		We should emphasize that the framework is extremely simple, just a handful of simple classes that are easy to understand and extend. The "magic" is in Seam itselfâ€”the same magic you use when creating any Seam application even without using this framework.
	</para>
	<section>
		<title>Introduction</title>
		<para>
			The components provided by the Seam application framework may be used in one of two different approaches. The first way is to install and configure an instance of the component in <literal>components.xml</literal>, just like we have done with other kinds of built-in Seam components. For example, the following fragment from <literal>components.xml</literal> installs a component which can perform basic CRUD operations for a <literal>Person</literal> entity:
		</para>
<programlisting>&lt;framework:entity-home name="personHome" 
                       entity-class="eg.Person" 
                       entity-manager="#{personDatabase}"&gt;
    &lt;framework:id&gt;#{param.personId}&lt;/framework:id&gt;
&lt;/framework:entity-home&gt;
</programlisting>
		<para>
			If that looks a bit too much like "programming in XML" for your taste, you can use extension instead:
		</para>
<programlisting>@Stateful
@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; implements LocalPersonHome {
    @RequestParameter String personId;
    @In EntityManager personDatabase;
    
    public Object getId() { return personId; }
    public EntityManager getEntityManager() { return personDatabase; }
    
}
</programlisting>
		<para>
			The second approach has one huge advantage: you can easily add extra functionality, and override the built-in functionality (the framework classes were carefully designed for extension and customization).
		</para>
		<para>
			A second advantage is that your classes may be EJB stateful session beans, if you like. (They do not have to be, they can be plain JavaBean components if you prefer.) If you are using JBoss AS, you&#39;ll need 4.2.2.GA or later.
		</para>
		<para>
			At this time, the Seam Application Framework provides four main built-in components: <literal>EntityHome</literal> and <literal>HibernateEntityHome</literal> for CRUD, along with <literal>EntityQuery</literal> and <literal>HibernateEntityQuery</literal> for queries.
		</para>
		<para>
			The Home and Query components are written so that they can function with a scope of session, event or conversation. Which scope you use depends upon the state model you wish to use in your application.
		</para>
		<para>
			The Seam Application Framework only works with Seam-managed persistence contexts. By default, the components will look for a persistence context named <literal>entityManager</literal>.
		</para>
	</section>
	
	<section>
		<title>Home objects</title>
		<para>
			A Home object provides persistence operations for a particular entity class. Suppose we have our trusty <literal>Person</literal> class:
		</para>
<programlisting>@Entity
public class Person {
    @Id private Long id;
    private String firstName;
    private String lastName;
    private Country nationality;
    
    //getters and setters...
}
</programlisting>
		<para>
			We can define a <literal>personHome</literal> component either via configuration:
		</para>
<programlisting>&lt;framework:entity-home name="personHome" entity-class="eg.Person" /&gt;
</programlisting>
		<para>
			Or via extension:
		</para>
<programlisting>@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {}
</programlisting>
		<para>
			A Home object provides the following operations: <literal>persist()</literal>, <literal>remove()</literal>, <literal>update()</literal> and <literal>getInstance()</literal>. Before you can call the <literal>remove()</literal>, or <literal>update()</literal> operations, you must first set the identifier of the object you are interested in, using the <literal>setId()</literal> method.
		</para>
		<para>
			We can use a Home directly from a JSF page, for example:
		</para>
<programlisting>&lt;h1&gt;Create Person&lt;/h1&gt;
&lt;h:form&gt;
    &lt;div&gt;First name: &lt;h:inputText value="#{personHome.instance.firstName}"/&gt;&lt;/div&gt;
    &lt;div&gt;Last name: &lt;h:inputText value="#{personHome.instance.lastName}"/&gt;&lt;/div&gt;
    &lt;div&gt;
        &lt;h:commandButton value="Create Person" action="#{personHome.persist}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;
</programlisting>
		<para>
			Usually, it is much nicer to be able to refer to the <literal>Person</literal> merely as <literal>person</literal>, so let&#39;s make that possible by adding a line to <literal>components.xml</literal>:
		</para>
<programlisting>&lt;factory name="person" 
         value="#{personHome.instance}"/&gt;

&lt;framework:entity-home name="personHome" 
                       entity-class="eg.Person" /&gt;
</programlisting>
		<para>
			(If we are using configuration.) Or by adding a <literal>@Factory</literal> method to <literal>PersonHome</literal>:
		</para>
<programlisting>@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {
    
    @Factory("person")
    public Person initPerson() { return getInstance(); }
    
}
</programlisting>
		<para>
			(If we are using extension.) This change simplifies our JSF page to the following:
		</para>
<programlisting>&lt;h1&gt;Create Person&lt;/h1&gt;
&lt;h:form&gt;
    &lt;div&gt;First name: &lt;h:inputText value="#{person.firstName}"/&gt;&lt;/div&gt;
    &lt;div&gt;Last name: &lt;h:inputText value="#{person.lastName}"/&gt;&lt;/div&gt;
    &lt;div&gt;
        &lt;h:commandButton value="Create Person" action="#{personHome.persist}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;
</programlisting>
		<para>
			Well, that lets us create new <literal>Person</literal> entries. Yes, that is all the code that is required! Now, if we want to be able to display, update and delete pre-existing <literal>Person</literal> entries in the database, we need to be able to pass the entry identifier to the <literal>PersonHome</literal>. Page parameters are a great way to do that:
		</para>
<programlisting>&lt;pages&gt;
    &lt;page view-id="/editPerson.jsp"&gt;
        &lt;param name="personId" value="#{personHome.id}"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;
</programlisting>
		<para>
			Now we can add the extra operations to our JSF page:
		</para>
<programlisting>&lt;h1&gt;
    &lt;h:outputText rendered="#{!personHome.managed}" value="Create Person"/&gt;
    &lt;h:outputText rendered="#{personHome.managed}" value="Edit Person"/&gt;
&lt;/h1&gt;
&lt;h:form&gt;
    &lt;div&gt;First name: &lt;h:inputText value="#{person.firstName}"/&gt;&lt;/div&gt;
    &lt;div&gt;Last name: &lt;h:inputText value="#{person.lastName}"/&gt;&lt;/div&gt;
    &lt;div&gt;
        &lt;h:commandButton value="Create Person" action="#{personHome.persist}" rendered="#{!personHome.managed}"/&gt;
        &lt;h:commandButton value="Update Person" action="#{personHome.update}" rendered="#{personHome.managed}"/&gt;
        &lt;h:commandButton value="Delete Person" action="#{personHome.remove}" rendered="#{personHome.managed}"/&gt;
    &lt;/div&gt;
&lt;/h:form&gt;
</programlisting>
		<para>
			When we link to the page with no request parameters, the page will be displayed as a "Create Person" page. When we provide a value for the <literal>personId</literal> request parameter, it will be an "Edit Person" page.
		</para>
		<para>
			Suppose we need to create <literal>Person</literal> entries with their nationality initialized. We can do that easily, via configuration:
		</para>
<programlisting>&lt;factory name="person" 
         value="#{personHome.instance}"/&gt;

&lt;framework:entity-home name="personHome" 
                       entity-class="eg.Person" 
                       new-instance="#{newPerson}"/&gt;

&lt;component name="newPerson" 
           class="eg.Person"&gt;
    &lt;property name="nationality"&gt;#{country}&lt;/property&gt;
&lt;/component&gt;
</programlisting>
		<para>
			Or by extension:
		</para>
<programlisting>@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {
    
    @In Country country;
    
    @Factory("person")
    public Person initPerson() { return getInstance(); }
    
    protected Person createInstance() {
        return new Person(country);
    }
    
}
</programlisting>
		<para>
			Of course, the <literal>Country</literal> could be an object managed by another Home object, for example, <literal>CountryHome</literal>.
		</para>
		<para>
			To add more sophisticated operations (association management, etc), we can just add methods to <literal>PersonHome</literal>.
		</para>
<programlisting>@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {
    
    @In Country country;
    
    @Factory("person")
    public Person initPerson() { return getInstance(); }
    
    protected Person createInstance() {
        return new Person(country);
    }
    
    public void migrate()
    {
        getInstance().setCountry(country);
        update();
    }
    
}
</programlisting>
		<para>
			The Home object raises an <literal>org.jboss.seam.afterTransactionSuccess</literal> event when a transaction succeeds (a call to <literal>persist()</literal>, <literal>update()</literal> or <literal>remove()</literal> succeeds). By observing this event we can refresh our queries when the underlying entities are changed. If we only want to refresh certain queries when a particular entity is persited, updated or removed we can observe the <literal>org.jboss.seam.afterTransactionSuccess.&lt;name&gt;</literal> event (where <literal>&lt;name&gt;</literal> is the name of the entity).
		</para>
		<para>
			The Home object automatically displays faces messages when an operation is successful. To customize these messages we can, again, use configuration:
		</para>
<programlisting>&lt;factory name="person" 
         value="#{personHome.instance}"/&gt;

&lt;framework:entity-home name="personHome"
                       entity-class="eg.Person"
                       new-instance="#{newPerson}"&gt;
    &lt;framework:created-message&gt;New person #{person.firstName} #{person.lastName} created&lt;/framework:created-message&gt;
    &lt;framework:deleted-message&gt;Person #{person.firstName} #{person.lastName} deleted&lt;/framework:deleted-message&gt;
    &lt;framework:updated-message&gt;Person #{person.firstName} #{person.lastName} updated&lt;/framework:updated-message&gt;
&lt;/framework:entity-home&gt;

&lt;component name="newPerson" 
           class="eg.Person"&gt;
    &lt;property name="nationality"&gt;#{country}&lt;/property&gt;
&lt;/component&gt;
</programlisting>
		<para>
			Or extension:
		</para>
<programlisting>@Name("personHome")
public class PersonHome extends EntityHome&lt;Person&gt; {
    
    @In Country country;
    
    @Factory("person")
    public Person initPerson() { return getInstance(); }
    
    protected Person createInstance() {
        return new Person(country);
    }
    
    protected String getCreatedMessage() { return "New person #{person.firstName} #{person.lastName} created"; }
    protected String getUpdatedMessage() { return "Person #{person.firstName} #{person.lastName} updated"; }
    protected String getDeletedMessage() { return "Person #{person.firstName} #{person.lastName} deleted"; }
    
}
</programlisting>
		<para>
			But the best way to specify the messages is to put them in a resource bundle known to Seam (the bundle named <literal>messages</literal>, by default).
		</para>
<programlisting>Person_created=New person #{person.firstName} #{person.lastName} created
Person_deleted=Person #{person.firstName} #{person.lastName} deleted
Person_updated=Person #{person.firstName} #{person.lastName} updated
</programlisting>
		<para>
			This enables internationalization, and keeps your code and configuration clean of presentation concerns.
		</para>
		<para>
			The final step is to add validation functionality to the page, using <literal>&lt;s:validateAll&gt;</literal> and <literal>&lt;s:decorate&gt;</literal>, but I&#39;ll leave that for you to figure out.
		</para>
	</section>
	
	<section>
		<title>Query objects</title>
		<para>
			If we need a list of all <literal>Person</literal> instance in the database, we can use a Query object. For example:
		</para>
<programlisting>&lt;framework:entity-query name="people" 
                        ejbql="select p from Person p"/&gt;
</programlisting>
		<para>
			We can use it from a JSF page:
		</para>
<programlisting>&lt;h1&gt;List of people&lt;/h1&gt;
&lt;h:dataTable value="#{people.resultList}" var="person"&gt;
    &lt;h:column&gt;
        &lt;s:link view="/editPerson.jsp" value="#{person.firstName} #{person.lastName}"&gt;
            &lt;f:param name="personId" value="#{person.id}"/&gt;
        &lt;/s:link&gt;
    &lt;/h:column&gt;
&lt;/h:dataTable&gt;
</programlisting>
		<para>
			We probably need to support pagination:
		</para>
<programlisting>&lt;framework:entity-query name="people" 
                        ejbql="select p from Person p" 
                        order="lastName" 
                        max-results="20"/&gt;
</programlisting>
		<para>
			We&#39;ll use a page parameter to determine the page to display:
		</para>
<programlisting>&lt;pages&gt;
    &lt;page view-id="/searchPerson.jsp"&gt;
        &lt;param name="firstResult" value="#{people.firstResult}"/&gt;
    &lt;/page&gt;
&lt;/pages&gt;
</programlisting>
		<para>
			The JSF code for a pagination control is a bit verbose, but manageable:
		</para>
<programlisting>&lt;h1&gt;Search for people&lt;/h1&gt;
&lt;h:dataTable value="#{people.resultList}" var="person"&gt;
    &lt;h:column&gt;
        &lt;s:link view="/editPerson.jsp" value="#{person.firstName} #{person.lastName}"&gt;
            &lt;f:param name="personId" value="#{person.id}"/&gt;
        &lt;/s:link&gt;
    &lt;/h:column&gt;
&lt;/h:dataTable&gt;

&lt;s:link view="/search.xhtml" rendered="#{people.previousExists}" value="First Page"&gt;
    &lt;f:param name="firstResult" value="0"/&gt;
&lt;/s:link&gt;

&lt;s:link view="/search.xhtml" rendered="#{people.previousExists}" value="Previous Page"&gt;
    &lt;f:param name="firstResult" value="#{people.previousFirstResult}"/&gt;
&lt;/s:link&gt;

&lt;s:link view="/search.xhtml" rendered="#{people.nextExists}" value="Next Page"&gt;
    &lt;f:param name="firstResult" value="#{people.nextFirstResult}"/&gt;
&lt;/s:link&gt;

&lt;s:link view="/search.xhtml" rendered="#{people.nextExists}" value="Last Page"&gt;
    &lt;f:param name="firstResult" value="#{people.lastFirstResult}"/&gt;
&lt;/s:link&gt;
</programlisting>
		<para>
			Real search screens let the user enter a bunch of optional search criteria to narrow the list of results returned. The Query object lets you specify optional "restrictions" to support this important usecase:
		</para>
<programlisting>&lt;component name="examplePerson" class="Person"/&gt;
        
&lt;framework:entity-query name="people" 
                        ejbql="select p from Person p" 
                        order="lastName" 
                        max-results="20"&gt;
    &lt;framework:restrictions&gt;
        &lt;value&gt;lower(firstName) like lower( concat(#{examplePerson.firstName},&#39;%&#39;) )&lt;/value&gt;
        &lt;value&gt;lower(lastName) like lower( concat(#{examplePerson.lastName},&#39;%&#39;) )&lt;/value&gt;
    &lt;/framework:restrictions&gt;
&lt;/framework:entity-query&gt;
</programlisting>
		<para>
			Notice the use of an "example" object.
		</para>
<programlisting>&lt;h1&gt;Search for people&lt;/h1&gt;
&lt;h:form&gt;
    &lt;div&gt;First name: &lt;h:inputText value="#{examplePerson.firstName}"/&gt;&lt;/div&gt;
    &lt;div&gt;Last name: &lt;h:inputText value="#{examplePerson.lastName}"/&gt;&lt;/div&gt;
    &lt;div&gt;&lt;h:commandButton value="Search" action="/search.jsp"/&gt;&lt;/div&gt;
&lt;/h:form&gt;

&lt;h:dataTable value="#{people.resultList}" var="person"&gt;
    &lt;h:column&gt;
        &lt;s:link view="/editPerson.jsp" value="#{person.firstName} #{person.lastName}"&gt;
            &lt;f:param name="personId" value="#{person.id}"/&gt;
        &lt;/s:link&gt;
    &lt;/h:column&gt;
&lt;/h:dataTable&gt;
</programlisting>
		<para>
			To refresh the query when the underlying entities change we observe the <literal>org.jboss.seam.afterTransactionSuccess</literal> event:
		</para>
<programlisting>&lt;event type="org.jboss.seam.afterTransactionSuccess"&gt;
    &lt;action execute="#{people.refresh}" /&gt;
&lt;/event&gt;
</programlisting>
		<para>
			Or, to just refresh the query when the person entity is persisted, updated or removed through <literal>PersonHome</literal>:
		</para>
<programlisting>&lt;event type="org.jboss.seam.afterTransactionSuccess.Person"&gt;
    &lt;action execute="#{people.refresh}" /&gt;
    &lt;/event&gt;
</programlisting>
		<para>
			Unfortunately Query objects don&#39;t work well with <emphasis>join fetch</emphasis> queries - the use of pagination with these queries is not recomended, and you&#39;ll have to implement your own method of calculating the total number of results (by overriding <literal>getCountEjbql()</literal>.
		</para>
		<para>
			The examples in this section have all shown reuse by configuration. However, reuse by extension is equally possible for Query objects.
		</para>
	</section>
	
	<section>
		<title>Controller objects</title>
		<para>
			A totally optional part of the Seam Application Framework is the class <literal>Controller</literal> and its subclasses <literal>EntityController</literal><literal>HibernateEntityController</literal> and <literal>BusinessProcessController</literal>. These classes provide nothing more than some convenience methods for access to commonly used built-in components and methods of built-in components. They help save a few keystrokes (characters can add up!) and provide a great launchpad for new users to explore the rich functionality built in to Seam.
		</para>
		<para>
			For example, here is what <literal>RegisterAction</literal> from the Seam registration example would look like:
		</para>
<programlisting>@Stateless
@Name("register")
public class RegisterAction extends EntityController implements Register
{

   @In private User user;
   
   public String register()
   {
      List existing = createQuery("select u.username from User u where u.username=:username")
         .setParameter("username", user.getUsername())
         .getResultList();
      
      if ( existing.size()==0 )
      {
         persist(user);
         info("Registered new user #{user.username}");
         return "/registered.jspx";
      }
      else
      {
         addFacesMessage("User #{user.username} already exists");
         return null;
      }
   }

}
</programlisting>
		<para>
			As you can see, its not an earthshattering improvement...
		</para>
	</section>

</chapter>

