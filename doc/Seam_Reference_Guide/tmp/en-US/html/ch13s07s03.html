<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head xmlns="http://www.w3.org/1999/xhtml">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>13.7.3. Creating a security rules file</title>
    <link rel="stylesheet" href="./Common_Content/css/default.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.72.0" />
    <link rel="start" href="index.html" title="Seam - Contextual Components" />
    <link rel="up" href="ch13s07.html" title="13.7. Writing Security Rules" />
    <link rel="prev" href="ch13s07s02.html" title="13.7.2. Configuring a rules file" />
    <link rel="next" href="ch13s07s03s01.html" title="13.7.3.1. Wildcard permission checks" />
  </head>
  <body>
    <p xmlns="http://www.w3.org/1999/xhtml" id="title">
      <a href="http://www.redhat.com/docs">
        <strong>13.7.3. Creating a security rules file</strong>
      </a>
    </p>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="ch13s07s02.html">
          <strong>Prev</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch13s07s03s01.html">
          <strong>Next</strong>
        </a>
      </li>
    </ul>
    <div xmlns="http://www.w3.org/1999/xhtml" class="sect2" lang="en-US" xml:lang="en-US">
      <div class="titlepage">
        <div>
          <div>
            <h3 class="title"><a id="id2870155"></a>13.7.3. Creating a security rules file</h3>
          </div>
        </div>
      </div>
      <p>
		For this step you need to create a file called <code class="literal">security.drl</code> in the <code class="literal">/META-INF</code> directory of your application's jar file. In actual fact this file can be called anything you want, and exist in any location as long as it is configured appropriately in <code class="literal">components.xml</code>.
	</p>
      <p>
		So what should the security rules file contain? At this stage it might be a good idea to at least skim through the JBoss Rules documentation, however to get started here's an extremely simple example:
	</p>
      <pre class="programlisting">package MyApplicationPermissions;

import org.jboss.seam.security.PermissionCheck;
import org.jboss.seam.security.Role;

rule CanUserDeleteCustomers
when
  c: PermissionCheck(name == "customer", action == "delete")
  Role(name == "admin")
then
  c.grant();
end;
</pre>
      <p>
		Let's break this down. The first thing we see is the package declaration. A package in JBoss Rules is essentially a collection of rules. The package name can be anything you want - it doesn't relate to anything else outside the scope of the rule base.
	</p>
      <p>
		The next thing we can notice is a couple of import statements for the <code class="literal">PermissionCheck</code> and <code class="literal">Role</code> classes. These imports inform the rules engine that we'll be referencing these classes within our rules.
	</p>
      <p>
		Finally we have the code for the rule. Each rule within a package should be given a unique name (usually describing the purpose of the rule). In this case our rule is called <code class="literal">CanUserDeleteCustomers</code> and will be used to check whether a user is allowed to delete a customer record.
	</p>
      <p>
		Looking at the body of the rule definition we can notice two distinct sections. Rules have what is known as a left hand side (LHS) and a right hand side (RHS). The LHS consists of the conditional part of the rule, i.e. a list of conditions which must be satisfied for the rule to fire. The LHS is represented by the <code class="literal">when</code> section. The RHS is the consequence, or action section of the rule that will only be fired if all of the conditions in the LHS are met. The RHS is represented by the <code class="literal">then</code> section. The end of the rule is denoted by the <code class="literal">end;</code> line.
	</p>
      <p>
		If we look at the LHS of the rule, we see two conditions listed there. Let's examine the first condition:
	</p>
      <pre class="programlisting">c: PermissionCheck(name == "customer", action == "delete")
</pre>
      <p>
		In plain english, this condition is stating that there must exist a <code class="literal">PermissionCheck</code> object with a <code class="literal">name</code> property equal to "customer", and an <code class="literal">action</code> property equal to "delete" within the working memory.
	</p>
      <p>
		So what is the working memory? Also known as a "stateful session" in Drools terminology, the working memory is a session-scoped object that contains the contextual information that is required by the rules engine to make a decision about a permission check. Each time the <code class="literal">hasPermission()</code> method is called, a temporary <code class="literal">PermissionCheck</code> object, or <span class="emphasis"><em>Fact</em></span>, is inserted into the working memory. This <code class="literal">PermissionCheck</code> corresponds exactly to the permission that is being checked, so for example if you call <code class="literal">hasPermission("account", "create", null)</code> then a <code class="literal">PermissionCheck</code> object with a <code class="literal">name</code> equal to "account" and <code class="literal">action</code> equal to "create" will be inserted into the working memory for the duration of the permission check.
	</p>
      <p>
		Besides the <code class="literal">PermissionCheck</code> facts, there is also a <code class="literal">org.jboss.seam.security.Role</code> fact for each of the roles that the authenticated user is a member of. These <code class="literal">Role</code> facts are synchronized with the user's authenticated roles at the beginning of every permission check. As a consequence, any <code class="literal">Role</code> object that is inserted into the working memory during the course of a permission check will be removed before the next permission check occurs, if the authenticated user is not a member of that role. Besides the <code class="literal">PermissionCheck</code> and <code class="literal">Role</code> facts, the working memory also contains the <code class="literal">java.security.Principal</code> object that was created during the authentication process.
	</p>
      <p>
		It is also possible to insert additional long-lived facts into the working memory by calling <code class="literal">((RuleBasedIdentity) RuleBasedIdentity.instance()).getSecurityContext().insert()</code>, passing the object as a parameter. The exception to this is <code class="literal">Role</code> objects, which as already discussed are synchronized at the start of each permission check.
	</p>
      <p>
		Getting back to our simple example, we can also notice that the first line of our LHS is prefixed with <code class="literal">c:</code>. This is a variable binding, and is used to refer back to the object that is matched by the condition. Moving onto the second line of our LHS, we see this:
	</p>
      <pre class="programlisting">Role(name == "admin")
</pre>
      <p>
		This condition simply states that there must be a <code class="literal">Role</code> object with a <code class="literal">name</code> of "admin" within the working memory. As mentioned, user roles are inserted into the working memory at the beginning of each permission check. So, putting both conditions together, this rule is essentially saying "I will fire if you are checking for the <code class="literal">customer:delete</code> permission and the user is a member of the <code class="literal">admin</code> role".
	</p>
      <p>
		So what is the consequence of the rule firing? Let's take a look at the RHS of the rule:
	</p>
      <pre class="programlisting">c.grant()
</pre>
      <p>
		The RHS consists of Java code, and in this case is invoking the <code class="literal">grant()</code> method of the <code class="literal">c</code> object, which as already mentioned is a variable binding for the <code class="literal">PermissionCheck</code> object. Besides the <code class="literal">name</code> and <code class="literal">action</code> properties of the <code class="literal">PermissionCheck</code> object, there is also a <code class="literal">granted</code> property which is initially set to <code class="literal">false</code>. Calling <code class="literal">grant()</code> on a <code class="literal">PermissionCheck</code> sets the <code class="literal">granted</code> property to <code class="literal">true</code>, which means that the permission check was successful, allowing the user to carry out whatever action the permission check was intended for.
	</p>
    </div>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="ch13s07s02.html"><strong>Prev</strong>13.7.2. Configuring a rules file</a>
      </li>
      <li class="up">
        <a accesskey="u" href="#">
          <strong>Up</strong>
        </a>
      </li>
      <li class="home">
        <a accesskey="h" href="index.html">
          <strong>Home</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch13s07s03s01.html"><strong>Next</strong>13.7.3.1. Wildcard permission checks</a>
      </li>
    </ul>
  </body>
</html>
