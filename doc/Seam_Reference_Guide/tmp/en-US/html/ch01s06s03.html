<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head xmlns="http://www.w3.org/1999/xhtml">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>1.6.3. Understanding Seam conversations</title>
    <link rel="stylesheet" href="./Common_Content/css/default.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.72.0" />
    <link rel="start" href="index.html" title="Seam - Contextual Components" />
    <link rel="up" href="booking.html" title="1.6. A complete Seam application: the Hotel Booking example" />
    <link rel="prev" href="ch01s06s02.html" title="1.6.2. Overview of the booking example" />
    <link rel="next" href="ch01s06s04.html" title="1.6.4. The Seam UI control library" />
  </head>
  <body>
    <p xmlns="http://www.w3.org/1999/xhtml" id="title">
      <a href="http://www.redhat.com/docs">
        <strong>1.6.3. Understanding Seam conversations</strong>
      </a>
    </p>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="ch01s06s02.html">
          <strong>Prev</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch01s06s04.html">
          <strong>Next</strong>
        </a>
      </li>
    </ul>
    <div xmlns="http://www.w3.org/1999/xhtml" class="section" lang="en-US" xml:lang="en-US">
      <div class="titlepage">
        <div>
          <div>
            <h3 class="title"><a id="id2851703"></a>1.6.3. Understanding Seam conversations</h3>
          </div>
        </div>
      </div>
      <p>
				We encourage you browse the sourcecode at your pleasure. In this tutorial we'll concentrate upon one particular piece of functionality: hotel search, selection, booking and confirmation. From the point of view of the user, everything from selecting a hotel to confirming a booking is one continuous unit of work, a <span class="emphasis"><em>conversation</em></span>. Searching, however, is <span class="emphasis"><em>not</em></span> part of the conversation. The user can select multiple hotels from the same search results page, in different browser tabs.
			</p>
      <p>
				Most web application architectures have no first class construct to represent a conversation. This causes enormous problems managing state associated with the conversation. Usually, Java web applications use a combination of two techniques: first, some state is thrown into the <code class="literal">HttpSession</code>; second, persistable state is flushed to the database after every request, and reconstructed from the database at the beginning of each new request.
			</p>
      <p>
				Since the database is the least scalable tier, this often results in an utterly unacceptable lack of scalability. Added latency is also a problem, due to the extra traffic to and from the database on every request. To reduce this redundant traffic, Java applications often introduce a data (second-level) cache that keeps commonly accessed data between requests. This cache is necessarily inefficient, because invalidation is based upon an LRU policy instead of being based upon when the user has finished working with the data. Furthermore, because the cache is shared between many concurrent transactions, we've introduced a whole raft of problem's associated with keeping the cached state consistent with the database.
			</p>
      <p>
				Now consider the state held in the <code class="literal">HttpSession</code>. By very careful programming, we might be able to control the size of the session data. This is a lot more difficult than it sounds, since web browsers permit ad hoc non-linear navigation. But suppose we suddenly discover a system requirement that says that a user is allowed to have <span class="emphasis"><em>mutiple concurrent conversations</em></span>, halfway through the development of the system (this has happened to me). Developing mechanisms to isolate session state associated with different concurrent conversations, and incorporating failsafes to ensure that conversation state is destroyed when the user aborts one of the conversations by closing a browser window or tab is not for the faint hearted (I've implemented this stuff twice so far, once for a client application, once for Seam, but I'm famously psychotic).
			</p>
      <p>
				Now there is a better way.
			</p>
      <p>
				Seam introduces the <span class="emphasis"><em>conversation context</em></span> as a first class construct. You can safely keep conversational state in this context, and be assured that it will have a well-defined lifecycle. Even better, you won't need to be continually pushing data back and forth between the application server and the database, since the conversation context is a natural cache of data that the user is currently working with.
			</p>
      <p>
				Usually, the components we keep in the conversation context are stateful session beans. (We can also keep entity beans and JavaBeans in the conversation context.) There is an ancient canard in the Java community that stateful session beans are a scalability killer. This may have been true in 1998 when WebFoobar 1.0 was released. It is no longer true today. Application servers like JBoss AS have extremely sophisticated mechanisms for stateful session bean state replication. (For example, the JBoss EJB3 container performs fine-grained replication, replicating only those bean attribute values which actually changed.) Note that all the traditional technical arguments for why stateful beans are inefficient apply equally to the <code class="literal">HttpSession</code>, so the practice of shifting state from business tier stateful session bean components to the web session to try and improve performance is unbelievably misguided. It is certainly possible to write unscalable applications using stateful session beans, by using stateful beans incorrectly, or by using them for the wrong thing. But that doesn't mean you should <span class="emphasis"><em>never</em></span> use them. Anyway, Seam guides you toward a safe usage model. Welcome to 2005.
			</p>
      <p>
				OK, I'll stop ranting now, and get back to the tutorial.
			</p>
      <p>
				The booking example application shows how stateful components with different scopes can collaborate together to achieve complex behaviors. The main page of the booking application allows the user to search for hotels. The search results are kept in the Seam session scope. When the user navigates to one of these hotels, a conversation begins, and a conversation scoped component calls back to the session scoped component to retrieve the selected hotel.
			</p>
      <p>
				The booking example also demonstrates the use of RichFaces Ajax to implement rich client behavior without the use of handwritten JavaScript.
			</p>
      <p>
				The search functionality is implemented using a session-scope stateful session bean, similar to the one we saw in the message list example above.
			</p>
      <div class="example">
        <a id="id2851865"></a>
        <div class="example-contents">
          <div class="programlistingco">
            <pre class="programlisting">@Stateful
@Name("hotelSearch")
@Scope(ScopeType.SESSION)
@Restrict("#{identity.loggedIn}")
public class HotelSearchingAction implements HotelSearching
{
   
   @PersistenceContext
   private EntityManager em;
   
   private String searchString;
   private int pageSize = 10;
   private int page;
   
   @DataModel
   private List&lt;Hotel&gt; hotels;
   
   public void find()
   {
      page = 0;
      queryHotels();
   }
   public void nextPage()
   {
      page++;
      queryHotels();
   }
      
   private void queryHotels()
   {
      hotels = 
          em.createQuery("select h from Hotel h where lower(h.name) like #{pattern} " + 
                         "or lower(h.city) like #{pattern} " + 
                         "or lower(h.zip) like #{pattern} " +
                         "or lower(h.address) like #{pattern}")
            .setMaxResults(pageSize)
            .setFirstResult( page * pageSize )
            .getResultList();
   }
   
   public boolean isNextPageAvailable()
   {
      return hotels!=null &amp;&amp; hotels.size()==pageSize;
   }
   
   public int getPageSize() {
      return pageSize;
   }
   
   public void setPageSize(int pageSize) {
      this.pageSize = pageSize;
   }
   
   @Factory(value="pattern", scope=ScopeType.EVENT)
   public String getSearchPattern()
   {
      return searchString==null ? 
            "%" : '%' + searchString.toLowerCase().replace('*', '%') + '%';
   }
   
   public String getSearchString()
   {
      return searchString;
   }
   
   public void setSearchString(String searchString)
   {
      this.searchString = searchString;
   }
   
   @Remove
   public void destroy() {}
}
</pre>
            <div class="calloutlist">
              <table border="0" summary="Callout list">
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/1.png" alt="1" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The EJB standard <code class="literal">@Stateful</code> annotation identifies this class as a stateful session bean. Stateful session beans are scoped to the conversation context by default.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/2.png" alt="2" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The <code class="literal">@Restrict</code> annotation applies a security restriction to the component. It restricts access to the component allowing only logged-in users. The security chapter explains more about security in Seam.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/3.png" alt="3" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The <a href="ch26s10s01.html#datamodel-annotation"><code class="literal">@DataModel</code></a> annotation exposes a <code class="literal">List</code> as a JSF <code class="literal">ListDataModel</code>. This makes it easy to implement clickable lists for search screens. In this case, the list of hotels is exposed to the page as a <code class="literal">ListDataModel</code> in the conversation variable named <code class="literal">hotels</code>.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/4.png" alt="4" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The EJB standard <code class="literal">@Remove</code> annotation specifies that a stateful session bean should be removed and its state destroyed after invocation of the annotated method. In Seam, all stateful session beans must define a method with no parameters marked <code class="literal">@Remove</code>. This method will be called when Seam destroys the session context.
							</p>
                  </td>
                </tr>
              </table>
            </div>
          </div>
        </div>
        <h6 xmlns="">Example 1.23. </h6>
      </div>
      <br class="example-break" />
      <p>
				The main page of the application is a Facelets page. Let's look at the fragment which relates to searching for hotels:
			</p>
      <div class="example">
        <a id="id2852058"></a>
        <div class="example-contents">
          <div class="programlistingco">
            <pre class="programlisting">&lt;div class="section"&gt;
  
    &lt;span class="errors"&gt;
       &lt;h:messages globalOnly="true"/&gt;
    &lt;/span&gt;
    
    &lt;h1&gt;Search Hotels&lt;/h1&gt;

	&lt;h:form id="searchCriteria"&gt;
	&lt;fieldset&gt; 
	   &lt;h:inputText id="searchString" value="#{hotelSearch.searchString}" 
                    style="width: 165px;"&gt;
         &lt;a:support event="onkeyup" actionListener="#{hotelSearch.find}" 
                    reRender="searchResults" /&gt;
       &lt;/h:inputText&gt;
        
	   &lt;a:commandButton id="findHotels" value="Find Hotels" action="#{hotelSearch.find}" 
                        reRender="searchResults"/&gt;
        
       &lt;a:status&gt;
          &lt;f:facet name="start"&gt;
             &lt;h:graphicImage value="/img/spinner.gif"/&gt;
          &lt;/f:facet&gt;
       &lt;/a:status&gt;
	   &lt;br/&gt;
       &lt;h:outputLabel for="pageSize"&gt;Maximum results:&lt;/h:outputLabel&gt; 
       &lt;h:selectOneMenu value="#{hotelSearch.pageSize}" id="pageSize"&gt;
          &lt;f:selectItem itemLabel="5" itemValue="5"/&gt;
          &lt;f:selectItem itemLabel="10" itemValue="10"/&gt;
          &lt;f:selectItem itemLabel="20" itemValue="20"/&gt;
       &lt;/h:selectOneMenu&gt;
    &lt;/fieldset&gt;
    &lt;/h:form&gt;
    
&lt;/div&gt;

&lt;a:outputPanel id="searchResults"&gt;
  &lt;div class="section"&gt;
    &lt;h:outputText value="No Hotels Found"
                  rendered="#{hotels != null and hotels.rowCount==0}"/&gt;
    &lt;h:dataTable id="hotels" value="#{hotels}" var="hot" 
                 rendered="#{hotels.rowCount&gt;0}"&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Name&lt;/f:facet&gt;
            #{hot.name}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Address&lt;/f:facet&gt;
            #{hot.address}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;City, State&lt;/f:facet&gt;
            #{hot.city}, #{hot.state}, #{hot.country}
        &lt;/h:column&gt; 
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Zip&lt;/f:facet&gt;
            #{hot.zip}
        &lt;/h:column&gt;
        &lt;h:column&gt;
            &lt;f:facet name="header"&gt;Action&lt;/f:facet&gt;
            &lt;s:link id="viewHotel" value="View Hotel" 
                    action="#{hotelBooking.selectHotel(hot)}"/&gt;
        &lt;/h:column&gt;
    &lt;/h:dataTable&gt;
    &lt;s:link value="More results" action="#{hotelSearch.nextPage}" 
            rendered="#{hotelSearch.nextPageAvailable}"/&gt;
  &lt;/div&gt;
&lt;/a:outputPanel&gt;
</pre>
            <div class="calloutlist">
              <table border="0" summary="Callout list">
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/1.png" alt="1" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The RichFaces Ajax <code class="literal">&lt;a:support&gt;</code> tag allows a JSF action event listener to be called by asynchronous <code class="literal">XMLHttpRequest</code> when a JavaScript event like <code class="literal">onkeyup</code> occurs. Even better, the <code class="literal">reRender</code> attribute lets us render a fragment of the JSF page and perform a partial page update when the asynchronous response is received.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/2.png" alt="2" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The RichFaces Ajax <code class="literal">&lt;a:status&gt;</code> tag lets us display a cheesy annimated image while we wait for asynchronous requests to return.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/3.png" alt="3" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The RichFaces Ajax <code class="literal">&lt;a:outputPanel&gt;</code> tag defines a region of the page which can be re-rendered by an asynchronous request.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/4.png" alt="4" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The Seam <code class="literal">&lt;s:link&gt;</code> tag lets us attach a JSF action listener to an ordinary (non-JavaScript) HTML link. The advantage of this over the standard JSF <code class="literal">&lt;h:commandLink&gt;</code> is that it preserves the operation of "open in new window" and "open in new tab". Also notice that we use a method binding with a parameter: <code class="literal">#{hotelBooking.selectHotel(hot)}</code>. This is not possible in the standard Unified EL, but Seam provides an extension to the EL that lets you use parameters on any method binding expression.
							</p>
                    <p>
								If you're wondering how navigation occurs, you can find all the rules in <code class="literal">WEB-INF/pages.xml</code>; this is discussed in <a href="events.pageaction.navigation.html" title="5.6. Navigation">Section 5.6, “Navigation”</a>.
							</p>
                  </td>
                </tr>
              </table>
            </div>
          </div>
        </div>
        <h6 xmlns="">Example 1.24. </h6>
      </div>
      <br class="example-break" />
      <p>
				This page displays the search results dynamically as we type, and lets us choose a hotel and pass it to the <code class="literal">selectHotel()</code> method of the <code class="literal">HotelBookingAction</code>, which is where the <span class="emphasis"><em>really</em></span> interesting stuff is going to happen.
			</p>
      <p>
				Now let's see how the booking example application uses a conversation-scoped stateful session bean to achieve a natural cache of persistent data related to the conversation. The following code example is pretty long. But if you think of it as a list of scripted actions that implement the various steps of the conversation, it's understandable. Read the class from top to bottom, as if it were a story.
			</p>
      <div class="example">
        <a id="id2852301"></a>
        <div class="example-contents">
          <div class="programlistingco">
            <pre class="programlisting">@Stateful
@Name("hotelBooking")
@Restrict("#{identity.loggedIn}")
public class HotelBookingAction implements HotelBooking
{
   
   @PersistenceContext(type=EXTENDED)
   private EntityManager em;
   
   @In 
   private User user;
   
   @In(required=false) @Out
   private Hotel hotel;
   
   @In(required=false) 
   @Out(required=false)
   private Booking booking;
     
   @In
   private FacesMessages facesMessages;
      
   @In
   private Events events;
   
   @Logger 
   private Log log;
   
   private boolean bookingValid;
   
   @Begin
   public void selectHotel(Hotel selectedHotel)
   {
      hotel = em.merge(selectedHotel);
   }
   
   public void bookHotel()
   {      
      booking = new Booking(hotel, user);
      Calendar calendar = Calendar.getInstance();
      booking.setCheckinDate( calendar.getTime() );
      calendar.add(Calendar.DAY_OF_MONTH, 1);
      booking.setCheckoutDate( calendar.getTime() );
   }
   
   public void setBookingDetails()
   {
      Calendar calendar = Calendar.getInstance();
      calendar.add(Calendar.DAY_OF_MONTH, -1);
      if ( booking.getCheckinDate().before( calendar.getTime() ) )
      {
         facesMessages.addToControl("checkinDate", "Check in date must be a future date");
         bookingValid=false;
      }
      else if ( !booking.getCheckinDate().before( booking.getCheckoutDate() ) )
      {
         facesMessages.addToControl("checkoutDate", 
                                    "Check out date must be later than check in date");
         bookingValid=false;
      }
      else
      {
         bookingValid=true;
      }
   }
   
   public boolean isBookingValid()
   {
      return bookingValid;
   }
   
   @End
   public void confirm()
   {
      em.persist(booking);
      facesMessages.add("Thank you, #{user.name}, your confimation number " + 
                        " for #{hotel.name} is #{booking.id}");
      log.info("New booking: #{booking.id} for #{user.username}");
      events.raiseTransactionSuccessEvent("bookingConfirmed");
   }
   
   @End
   public void cancel() {}
   
   @Remove
   public void destroy() {}
</pre>
            <div class="calloutlist">
              <table border="0" summary="Callout list">
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/1.png" alt="1" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								This bean uses an EJB3 <span class="emphasis"><em>extended persistence context</em></span>, so that any entity instances remain managed for the whole lifecycle of the stateful session bean.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/2.png" alt="2" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The <a href="ch26s02.html#out-annotation"><code class="literal">@Out</code></a> annotation declares that an attribute value is <span class="emphasis"><em>outjected</em></span> to a context variable after method invocations. In this case, the context variable named <code class="literal">hotel</code> will be set to the value of the <code class="literal">hotel</code> instance variable after every action listener invocation completes.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/3.png" alt="3" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The <a href="ch26s04.html#begin-annotation" title="???TITLE???"><code class="literal">@Begin</code></a> annotation specifies that the annotated method begins a <span class="emphasis"><em>long-running conversation</em></span>, so the current conversation context will not be destroyed at the end of the request. Instead, it will be reassociated with every request from the current window, and destroyed either by timeout due to conversation inactivity or invocation of a matching <code class="literal">@End</code> method.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/4.png" alt="4" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								The <a href="ch26s04.html#end-annotation"><code class="literal">@End</code></a> annotation specifies that the annotated method ends the current long-running conversation, so the current conversation context will be destroyed at the end of the request.
							</p>
                  </td>
                </tr>
                <tr>
                  <td width="5%" valign="top" align="left">
                    <img src="./Common_Content/images/5.png" alt="5" border="0" />
                  </td>
                  <td valign="top" align="left">
                    <p>
								This EJB remove method will be called when Seam destroys the conversation context. Don't forget to define this method!
							</p>
                  </td>
                </tr>
              </table>
            </div>
          </div>
        </div>
        <h6 xmlns="">Example 1.25. </h6>
      </div>
      <br class="example-break" />
      <p>
				<code class="literal">HotelBookingAction</code> contains all the action listener methods that implement selection, booking and booking confirmation, and holds state related to this work in its instance variables. We think you'll agree that this code is much cleaner and simpler than getting and setting <code class="literal">HttpSession</code> attributes.
			</p>
      <p>
				Even better, a user can have multiple isolated conversations per login session. Try it! Log in, run a search, and navigate to different hotel pages in multiple browser tabs. You'll be able to work on creating two different hotel reservations at the same time. If you leave any one conversation inactive for long enough, Seam will eventually time out that conversation and destroy its state. If, after ending a conversation, you backbutton to a page of that conversation and try to perform an action, Seam will detect that the conversation was already ended, and redirect you to the search page.
			</p>
    </div>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="ch01s06s02.html"><strong>Prev</strong>1.6.2. Overview of the booking example</a>
      </li>
      <li class="up">
        <a accesskey="u" href="#">
          <strong>Up</strong>
        </a>
      </li>
      <li class="home">
        <a accesskey="h" href="index.html">
          <strong>Home</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch01s06s04.html"><strong>Next</strong>1.6.4. The Seam UI control library</a>
      </li>
    </ul>
  </body>
</html>
