<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head xmlns="http://www.w3.org/1999/xhtml">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>6.1. Seam's conversation model</title>
    <link rel="stylesheet" href="./Common_Content/css/default.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.72.0" />
    <link rel="start" href="index.html" title="Seam - Contextual Components" />
    <link rel="up" href="conversations.html" title="Chapter 6. Conversations and workspace management" />
    <link rel="prev" href="conversations.html" title="Chapter 6. Conversations and workspace management" />
    <link rel="next" href="ch06s02.html" title="6.2. Nested conversations" />
  </head>
  <body>
    <p xmlns="http://www.w3.org/1999/xhtml" id="title">
      <a href="http://www.redhat.com/docs">
        <strong>6.1. Seam's conversation model</strong>
      </a>
    </p>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="conversations.html">
          <strong>Prev</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch06s02.html">
          <strong>Next</strong>
        </a>
      </li>
    </ul>
    <div xmlns="http://www.w3.org/1999/xhtml" class="section" lang="en-US" xml:lang="en-US">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a id="id2799707"></a>6.1. Seam's conversation model</h2>
          </div>
        </div>
      </div>
      <p>
			The examples we have seen so far make use of a very simple conversation model that follows these rules:
		</p>
      <div class="itemizedlist">
        <ul>
          <li>
            <p>
					There is always a conversation context active during the apply request values, process validations, update model values, invoke application and render response phases of the JSF request lifecycle.
				</p>
          </li>
          <li>
            <p>
					At the end of the restore view phase of the JSF request lifecycle, Seam attempts to restore any previous long-running conversation context. If none exists, Seam creates a new temporary conversation context.
				</p>
          </li>
          <li>
            <p>
					When an <code class="literal">@Begin</code> method is encountered, the temporary conversation context is promoted to a long running conversation.
				</p>
          </li>
          <li>
            <p>
					When an <code class="literal">@End</code> method is encountered, any long-running conversation context is demoted to a temporary conversation.
				</p>
          </li>
          <li>
            <p>
					At the end of the render response phase of the JSF request lifecycle, Seam stores the contents of a long running conversation context or destroys the contents of a temporary conversation context.
				</p>
          </li>
          <li>
            <p>
					Any faces request (a JSF postback) will propagate the conversation context. By default, non-faces requests (GET requests, for example) do not propagate the conversation context, but see below for more information on this.
				</p>
          </li>
          <li>
            <p>
					If the JSF request lifecycle is foreshortened by a redirect, Seam transparently stores and restores the current conversation context—unless the conversation was already ended via <code class="literal">@End(beforeRedirect=true)</code>.
				</p>
          </li>
        </ul>
      </div>
      <p>
			Seam transparently propagates the conversation context (including the temporary conversation context) across JSF postbacks and redirects. If you don't do anything special, a <span class="emphasis"><em>non-faces request</em></span> (a GET request for example) will not propagate the conversation context and will be processed in a new temporary conversation. This is usually - but not always - the desired behavior.
		</p>
      <p>
			If you want to propagate a Seam conversation across a non-faces request, you need to explicitly code the Seam <span class="emphasis"><em>conversation id</em></span> as a request parameter:
		</p>
      <pre class="programlisting">&lt;a href="main.jsf?conversationId=#{conversation.id}"&gt;Continue&lt;/a&gt;
</pre>
      <p>
			Or, the more JSF-ish:
		</p>
      <pre class="programlisting">&lt;h:outputLink value="main.jsf"&gt;
    &lt;f:param name="conversationId" value="#{conversation.id}"/&gt;
    &lt;h:outputText value="Continue"/&gt;
&lt;/h:outputLink&gt;
</pre>
      <p>
			If you use the Seam tag library, this is equivalent:
		</p>
      <pre class="programlisting">&lt;h:outputLink value="main.jsf"&gt;
    &lt;s:conversationId/&gt;
    &lt;h:outputText value="Continue"/&gt;
&lt;/h:outputLink&gt;
</pre>
      <p>
			If you wish to disable propagation of the conversation context for a postback, a similar trick is used:
		</p>
      <pre class="programlisting">&lt;h:commandLink action="main" value="Exit"&gt;
    &lt;f:param name="conversationPropagation" value="none"/&gt;
&lt;/h:commandLink&gt;
</pre>
      <p>
			If you use the Seam tag library, this is equivalent:
		</p>
      <pre class="programlisting">&lt;h:commandLink action="main" value="Exit"&gt;
    &lt;s:conversationPropagation type="none"/&gt;
&lt;/h:commandLink&gt;
</pre>
      <p>
			Note that disabling conversation context propagation is absolutely not the same thing as ending the conversation.
		</p>
      <p>
			The <code class="literal">conversationPropagation</code> request parameter, or the <code class="literal">&lt;s:conversationPropagation&gt;</code> tag may even be used to begin and end conversation, or begin a nested conversation.
		</p>
      <pre class="programlisting">&lt;h:commandLink action="main" value="Exit"&gt;
    &lt;s:conversationPropagation type="end"/&gt;
&lt;/h:commandLink&gt;
</pre>
      <pre class="programlisting">&lt;h:commandLink action="main" value="Select Child"&gt;
    &lt;s:conversationPropagation type="nested"/&gt;
&lt;/h:commandLink&gt;
</pre>
      <pre class="programlisting">&lt;h:commandLink action="main" value="Select Hotel"&gt;
    &lt;s:conversationPropagation type="begin"/&gt;
&lt;/h:commandLink&gt;
</pre>
      <pre class="programlisting">&lt;h:commandLink action="main" value="Select Hotel"&gt;
    &lt;s:conversationPropagation type="join"/&gt;
&lt;/h:commandLink&gt;
</pre>
      <p>
			This conversation model makes it easy to build applications which behave correctly with respect to multi-window operation. For many applications, this is all that is needed. Some complex applications have either or both of the following additional requirements:
		</p>
      <div class="itemizedlist">
        <ul>
          <li>
            <p>
					A conversation spans many smaller units of user interaction, which execute serially or even concurrently. The smaller <span class="emphasis"><em>nested conversations</em></span> have their own isolated set of conversation state, and also have access to the state of the outer conversation.
				</p>
          </li>
          <li>
            <p>
					The user is able to switch between many conversations within the same browser window. This feature is called <span class="emphasis"><em>workspace management</em></span>.
				</p>
          </li>
        </ul>
      </div>
    </div>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="conversations.html"><strong>Prev</strong>Chapter 6. Conversations and workspace management</a>
      </li>
      <li class="up">
        <a accesskey="u" href="#">
          <strong>Up</strong>
        </a>
      </li>
      <li class="home">
        <a accesskey="h" href="index.html">
          <strong>Home</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch06s02.html"><strong>Next</strong>6.2. Nested conversations</a>
      </li>
    </ul>
  </body>
</html>
