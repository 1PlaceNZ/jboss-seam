<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head xmlns="http://www.w3.org/1999/xhtml">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>18.1.1. Asynchronous methods</title>
    <link rel="stylesheet" href="./Common_Content/css/default.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.72.0" />
    <link rel="start" href="index.html" title="Seam - Contextual Components" />
    <link rel="up" href="ch18s01.html" title="18.1. Asynchronicity" />
    <link rel="prev" href="ch18s01.html" title="18.1. Asynchronicity" />
    <link rel="next" href="ch18s01s02.html" title="18.1.2. Asynchronous methods with the Quartz Dispatcher" />
  </head>
  <body>
    <p xmlns="http://www.w3.org/1999/xhtml" id="title">
      <a href="http://www.redhat.com/docs">
        <strong>18.1.1. Asynchronous methods</strong>
      </a>
    </p>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="ch18s01.html">
          <strong>Prev</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch18s01s02.html">
          <strong>Next</strong>
        </a>
      </li>
    </ul>
    <div xmlns="http://www.w3.org/1999/xhtml" class="sect2" lang="en-US" xml:lang="en-US">
      <div class="titlepage">
        <div>
          <div>
            <h3 class="title"><a id="id2839060"></a>18.1.1. Asynchronous methods</h3>
          </div>
        </div>
      </div>
      <p>
		In simplest form, an asynchronous call just lets a method call be processed asynchronously (in a different thread) from the caller. We usually use an asynchronous call when we want to return an immediate response to the client, and let some expensive work be processed in the background. This pattern works very well in applications which use AJAX, where the client can automatically poll the server for the result of the work.
	</p>
      <p>
		For EJB components, we annotate the local interface to specify that a method is processed asynchronously.
	</p>
      <pre class="programlisting">@Local
public interface PaymentHandler
{
    @Asynchronous
    public void processPayment(Payment payment);
}
</pre>
      <p>
		(For JavaBean components we can annotate the component implementation class if we like.)
	</p>
      <p>
		The use of asynchronicity is transparent to the bean class:
	</p>
      <pre class="programlisting">@Stateless
@Name("paymentHandler")
public class PaymentHandlerBean implements PaymentHandler
{
    public void processPayment(Payment payment)
    {
        //do some work!
    }
}
</pre>
      <p>
		And also transparent to the client:
	</p>
      <pre class="programlisting">@Stateful
@Name("paymentAction")
public class CreatePaymentAction
{
    @In(create=true) PaymentHandler paymentHandler;
    @In Bill bill;
    
    public String pay()
    {
        paymentHandler.processPayment( new Payment(bill) );
        return "success";
    }
}
</pre>
      <p>
		The asynchronous method is processed in a completely new event context and does not have access to the session or conversation context state of the caller. However, the business process context <span class="emphasis"><em>is</em></span> propagated.
	</p>
      <p>
		Asynchronous method calls may be scheduled for later execution using the <code class="literal">@Duration</code>, <code class="literal">@Expiration</code> and <code class="literal">@IntervalDuration</code> annotations.
	</p>
      <pre class="programlisting">@Local
public interface PaymentHandler
{
    @Asynchronous
    public void processScheduledPayment(Payment payment, @Expiration Date date);

    @Asynchronous
    public void processRecurringPayment(Payment payment, 
                                        @Expiration Date date, 
                                        @IntervalDuration Long interval)'
}
</pre>
      <pre class="programlisting">@Stateful
@Name("paymentAction")
public class CreatePaymentAction
{
    @In(create=true) PaymentHandler paymentHandler;
    @In Bill bill;
    
    public String schedulePayment()
    {
        paymentHandler.processScheduledPayment( new Payment(bill), bill.getDueDate() );
        return "success";
    }

    public String scheduleRecurringPayment()
    {
        paymentHandler.processRecurringPayment( new Payment(bill), bill.getDueDate(), 
                                                ONE_MONTH );
        return "success";
    }
}
</pre>
      <p>
		Both client and server may access the <code class="literal">Timer</code> object associated with the invocation. The <code class="literal">Timer</code> object shown below is the EJB3 timer when you use the EJB3 dispatcher. For the default <code class="literal">ScheduledThreadPoolExecutor</code>, the returned object is <code class="literal">Future</code> from the JDK. For the Quartz dispatcher, it returns <code class="literal">QuartzTriggerHandle</code>, which we will discuss in the next section.
	</p>
      <pre class="programlisting">@Local
public interface PaymentHandler
{
    @Asynchronous
    public Timer processScheduledPayment(Payment payment, @Expiration Date date);
}
</pre>
      <pre class="programlisting">@Stateless
@Name("paymentHandler")
public class PaymentHandlerBean implements PaymentHandler
{
    @In Timer timer;
    
    public Timer processScheduledPayment(Payment payment, @Expiration Date date)
    {
        //do some work!
        
        return timer; //note that return value is completely ignored
    }

}
</pre>
      <pre class="programlisting">@Stateful
@Name("paymentAction")
public class CreatePaymentAction
{
    @In(create=true) PaymentHandler paymentHandler;
    @In Bill bill;
    
    public String schedulePayment()
    {
        Timer timer = paymentHandler.processScheduledPayment( new Payment(bill), 
                                                              bill.getDueDate() );
        return "success";
    }
}
</pre>
      <p>
		Asynchronous methods cannot return any other value to the caller.
	</p>
    </div>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="ch18s01.html"><strong>Prev</strong>18.1. Asynchronicity</a>
      </li>
      <li class="up">
        <a accesskey="u" href="#">
          <strong>Up</strong>
        </a>
      </li>
      <li class="home">
        <a accesskey="h" href="index.html">
          <strong>Home</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch18s01s02.html"><strong>Next</strong>18.1.2. Asynchronous methods with the Quartz Disp...</a>
      </li>
    </ul>
  </body>
</html>
