<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head xmlns="http://www.w3.org/1999/xhtml">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>8.3.3. Seam-managed persistence contexts and atomic conversations</title>
    <link rel="stylesheet" href="./Common_Content/css/default.css" type="text/css" />
    <meta name="generator" content="DocBook XSL Stylesheets V1.72.0" />
    <link rel="start" href="index.html" title="Seam - Contextual Components" />
    <link rel="up" href="persistence.seam-managed-persistence-contexts.html" title="8.3. Seam-managed persistence contexts" />
    <link rel="prev" href="ch08s03s02.html" title="8.3.2. Using a Seam-managed Hibernate session" />
    <link rel="next" href="ch08s04.html" title="8.4. Using the JPA &quot;delegate&quot;" />
  </head>
  <body>
    <p xmlns="http://www.w3.org/1999/xhtml" id="title">
      <a href="http://www.redhat.com/docs">
        <strong>8.3.3. Seam-managed persistence contexts and atomic conversations</strong>
      </a>
    </p>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="ch08s03s02.html">
          <strong>Prev</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch08s04.html">
          <strong>Next</strong>
        </a>
      </li>
    </ul>
    <div xmlns="http://www.w3.org/1999/xhtml" class="section" lang="en-US" xml:lang="en-US">
      <div class="titlepage">
        <div>
          <div>
            <h3 class="title"><a id="id2821276"></a>8.3.3. Seam-managed persistence contexts and atomic conversations</h3>
          </div>
        </div>
      </div>
      <p>
				Persistence contexts scoped to the conversation allows you to program optimistic transactions that span multiple requests to the server without the need to use the <code class="literal">merge()</code> operation , without the need to re-load data at the beginning of each request, and without the need to wrestle with the <code class="literal">LazyInitializationException</code> or <code class="literal">NonUniqueObjectException</code>.
			</p>
      <p>
				As with any optimistic transaction management, transaction isolation and consistency can be achieved via use of optimistic locking. Fortunately, both Hibernate and EJB 3.0 make it very easy to use optimistic locking, by providing the <code class="literal">@Version</code> annotation.
			</p>
      <p>
				By default, the persistence context is flushed (synchronized with the database) at the end of each transaction. This is sometimes the desired behavior. But very often, we would prefer that all changes are held in memory and only written to the database when the conversation ends successfully. This allows for truly atomic conversations. As the result of a truly stupid and shortsighted decision by certain non-JBoss, non-Sun and non-Sybase members of the EJB 3.0 expert group, there is currently no simple, usable and portable way to implement atomic conversations using EJB 3.0 persistence. However, Hibernate provides this feature as a vendor extension to the <code class="literal">FlushModeType</code>s defined by the specification, and it is our expectation that other vendors will soon provide a similar extension.
			</p>
      <p>
				Seam lets you specify <code class="literal">FlushModeType.MANUAL</code> when beginning a conversation. Currently, this works only when Hibernate is the underlying persistence provider, but we plan to support other equivalent vendor extensions.
			</p>
      <pre class="programlisting">@In EntityManager em; //a Seam-managed persistence context

@Begin(flushMode=MANUAL)
public void beginClaimWizard() {
    claim = em.find(Claim.class, claimId);
}
</pre>
      <p>
				Now, the <code class="literal">claim</code> object remains managed by the persistence context for the rest ot the conversation. We can make changes to the claim:
			</p>
      <pre class="programlisting">public void addPartyToClaim() {
    Party party = ....;
    claim.addParty(party);
}
</pre>
      <p>
				But these changes will not be flushed to the database until we explicitly force the flush to occur:
			</p>
      <pre class="programlisting">@End
public void commitClaim() {
    em.flush();
}
</pre>
      <p>
				Of course, you could set the <code class="literal">flushMode</code> to <code class="literal">MANUAL</code> from pages.xml, for example in a navigation rule:
			</p>
      <pre class="programlisting">&lt;begin-conversation flush-mode="MANUAL" /&gt;
</pre>
    </div>
    <ul xmlns="http://www.w3.org/1999/xhtml" class="docnav">
      <li class="previous">
        <a accesskey="p" href="ch08s03s02.html"><strong>Prev</strong>8.3.2. Using a Seam-managed Hibernate session</a>
      </li>
      <li class="up">
        <a accesskey="u" href="#">
          <strong>Up</strong>
        </a>
      </li>
      <li class="home">
        <a accesskey="h" href="index.html">
          <strong>Home</strong>
        </a>
      </li>
      <li class="next">
        <a accesskey="n" href="ch08s04.html"><strong>Next</strong>8.4. Using the JPA "delegate"</a>
      </li>
    </ul>
  </body>
</html>
