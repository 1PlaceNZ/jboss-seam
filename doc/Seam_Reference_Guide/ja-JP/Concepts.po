# translation of Tools.po to Japanese
# Noriko Mizumoto <noriko@redhat.com>, 2007.
msgid ""
msgstr ""
"Project-Id-Version: Tools\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2008-11-06 06:41+0000\n"
"PO-Revision-Date: 2009-02-28 15:51+0900\n"
"Last-Translator: Shinobu NOGAMI <s-nogami@sourceforge.jp>\n"
"Language-Team: Japanese <fedora-trans-ja@redhat.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#: Concepts.xml:5
#, no-c-format
msgid "The contextual component model"
msgstr "コンテキスト依存コンポーネントモデル"

#. Tag: para
#: Concepts.xml:6
#, no-c-format
msgid "The two core concepts in Seam are the notion of a <emphasis>context</emphasis> and the notion of a <emphasis>component</emphasis>. Components are stateful objects, usually EJBs, and an instance of a component is associated with a context, and given a name in that context. <emphasis>Bijection</emphasis> provides a mechanism for aliasing internal component names (instance variables) to contextual names, allowing component trees to be dynamically assembled, and reassembled by Seam."
msgstr "Seam における 2 つの中心的概念は、 <emphasis>コンテキスト</emphasis> の概念と <emphasis>コンポーネント</emphasis> の概念です。 コンポーネントは、ステートフルなオブジェクト、通常は EJB です。 コンポーネントのインスタンスは、コンテキストと関連づけられ、そのコンテキスト中で名前を与えられます。 バイジェクション (Bijection) は、内部のコンポーネント名 (インスタンス変数) をコンテキスト中の名前にエイリアスし、 Seam によるコンポーネントツリーの動的な組み立て、再組み立てを可能にするメカニズムを提供します。"

#. Tag: para
#: Concepts.xml:14
#, no-c-format
msgid "Let's start by describing the contexts built in to Seam."
msgstr "Seam に組み込まれたコンテキストから説明を始めましょう。"

#. Tag: title
#: Concepts.xml:19
#, no-c-format
msgid "Seam contexts"
msgstr "Seam コンテキスト"

#. Tag: para
#: Concepts.xml:20
#, no-c-format
msgid "Seam contexts are created and destroyed by the framework. The application does not control context demarcation via explicit Java API calls. Context are usually implicit. In some cases, however, contexts are demarcated via annotations."
msgstr "Seam コンテキストはフレームワークによって生成、破棄されます。 アプリケーションは Java API 呼び出しによってコンテキストの区分 (demarcation) を明示的に制御することはできません。 コンテキストは通常、暗黙的ですが、場合によってコンテキストはアノテーションによって区分されます。"

#. Tag: para
#: Concepts.xml:23
#, no-c-format
msgid "The basic Seam contexts are:"
msgstr "基本の Seam コンテキストは以下の通りです。"

#. Tag: para
#: Concepts.xml:27
#, no-c-format
msgid "<para>Stateless context</para>"
msgstr "<para>ステートレスコンテキスト</para>"

#. Tag: para
#: Concepts.xml:30
#, no-c-format
msgid "Event (or request) context"
msgstr "イベント (または要求) コンテキスト"

#. Tag: para
#: Concepts.xml:33
#: Concepts.xml:224
#, no-c-format
msgid "<para>Page context</para>"
msgstr "<para>ページコンテキスト</para>"

#. Tag: para
#: Concepts.xml:36
#: Concepts.xml:227
#, no-c-format
msgid "<para>Conversation context</para>"
msgstr "<para>対話コンテキスト</para>"

#. Tag: para
#: Concepts.xml:39
#: Concepts.xml:230
#, no-c-format
msgid "<para>Session context</para>"
msgstr "<para>セッションコンテキスト</para>"

#. Tag: para
#: Concepts.xml:42
#: Concepts.xml:233
#, no-c-format
msgid "<para>Business process context</para>"
msgstr "<para>ビジネスプロセスコンテキスト</para>"

#. Tag: para
#: Concepts.xml:45
#: Concepts.xml:236
#, no-c-format
msgid "<para>Application context</para>"
msgstr "<para>アプリケーションコンテキスト</para>"

#. Tag: para
#: Concepts.xml:49
#, no-c-format
msgid "You will recognize some of these contexts from servlet and related specifications. However, two of them might be new to you: <emphasis>conversation context</emphasis>, and <emphasis>business process context</emphasis>. One reason state management in web applications is so fragile and error-prone is that the three built-in contexts (request, session and application) are not especially meaningful from the point of view of the business logic. A user login session, for example, is a fairly arbitrary construct in terms of the actual application work flow. Therefore, most Seam components are scoped to the conversation or business process contexts, since they are the contexts which are most meaningful in terms of the application."
msgstr "これらのコンテキストのいくつかは、サーブレットや関連する仕様に由来していることがわかります。 しかし、このうち 2 つは目新しいかもしれません。 <emphasis>対話コンテキスト (conversation context)</emphasis> と<emphasis>ビジネスプロセスコンテキスト</emphasis>です。 Web アプリケーション中での状態管理がとても脆弱でエラーが発生しやすい 1 つの理由は、 3 つの組み込みコンテキスト (要求、セッション、アプリケーション) がビジネスロジックの観点から特定の意味を持たないからです。 例えば、実際のアプリケーションのワークフローの観点から見るとユーザーログインセッションは極めて自由裁量な構造です。 そのため、ほとんどの Seam コンポーネントは、対話コンテキストあるいはビジネスプロセスコンテキストのスコープに配置されます。 なぜなら、それらはアプリケーションの観点からとても意味のあるコンテキストだからです。"

#. Tag: para
#: Concepts.xml:60
#, no-c-format
msgid "Let's look at each context in turn."
msgstr "順に、それぞれのコンテキストを見ていきましょう。"

#. Tag: title
#: Concepts.xml:65
#, no-c-format
msgid "<title>Stateless context</title>"
msgstr "<title>ステートレスコンテキスト</title>"

#. Tag: para
#: Concepts.xml:66
#, no-c-format
msgid "Components which are truly stateless (stateless session beans, primarily) always live in the stateless context (this is really a non-context). Stateless components are not very interesting, and are arguably not very object-oriented. Nevertheless, they are important and often useful."
msgstr "本当に状態をもたないコンポーネント (主にステートレスセッション Bean) は、いつもステートレスコンテキスト (実際にはコンテキストではありません) に置かれます。 ステートレスコンポーネントは、あまり興味深いものでもなく、まったくオブジェクト指向でもありません。 しかし、これらは重要でしばしば役に立ちます。"

#. Tag: title
#: Concepts.xml:74
#, no-c-format
msgid "<title>Event context</title>"
msgstr "<title>イベントコンテキスト</title>"

#. Tag: para
#: Concepts.xml:75
#, no-c-format
msgid "The event context is the \"narrowest\" stateful context, and is a generalization of the notion of the web request context to cover other kinds of events. Nevertheless, the event context associated with the lifecycle of a JSF request is the most important example of an event context, and the one you will work with most often. Components associated with the event context are destroyed at the end of the request, but their state is available and well-defined for at least the lifecycle of the request."
msgstr "イベントコンテキストは「最も狭い」状態を持つコンテキストで、 他の種類のイベントを網羅する Web 要求コンテキストの概念の一般化です。 それにもかかわらず、JSF 要求のライフサイクルと関連づけられたイベントコンテキストは、 イベントコンテキストの最も重要な用例であり、最もよく利用されるものです。 要求終了時に、イベントコンテキストに関連するコンポーネントは破棄されますが、 それらの状態は、少なくとも要求のライフサイクルの間では有効かつ明確です。"

#. Tag: para
#: Concepts.xml:82
#, no-c-format
msgid "When you invoke a Seam component via RMI, or Seam Remoting, the event context is created and destroyed just for the invocation."
msgstr "RMI 経由あるいは Seam Remoting により Seam コンポーネントを呼び出すとき、 イベントコンテキストは、その呼び出しだけのために生成、破棄されます。"

#. Tag: title
#: Concepts.xml:89
#, no-c-format
msgid "<title>Page context</title>"
msgstr "<title>ページコンテキスト</title>"

#. Tag: para
#: Concepts.xml:90
#, no-c-format
msgid "The page context allows you to associate state with a particular instance of a rendered page. You can initialize state in your event listener, or while actually rendering the page, and then have access to it from any event that originates from that page. This is especially useful for functionality like clickable lists, where the list is backed by changing data on the server side. The state is actually serialized to the client, so this construct is extremely robust with respect to multi-window operation and the back button."
msgstr "ページコンテキストは、レンダリングされたページの特定のインスタンスと状態との関連づけを可能にします。 イベントリスナー内で状態の初期化が可能で、 実際にページをレンダリングしている間に、 ページに由来するどんなイベントからも状態にアクセスが可能です。 これは特にサーバサイドのデータ変化にリストが連動しているクリッカブルリストのような機能に役立ちます。 状態は実際にはクライアントのためにシリアライズされます。 そのため、この構造は複数ウインドの操作や戻るボタンに対して極めて堅牢です。"

#. Tag: title
#: Concepts.xml:101
#, no-c-format
msgid "<title>Conversation context</title>"
msgstr "<title>対話コンテキスト</title>"

#. Tag: para
#: Concepts.xml:102
#, no-c-format
msgid "The conversation context is a truly central concept in Seam. A <emphasis>conversation</emphasis> is a unit of work from the point of view of the user. It might span several interactions with the user, several requests, and several database transactions. But to the user, a conversation solves a single problem. For example, \"book hotel\", \"approve contract\", \"create order\" are all conversations. You might like to think of a conversation implementing a single \"use case\" or \"user story\", but the relationship is not necessarily quite exact."
msgstr "対話コンテキストは Seam でまさに中心となるコンセプトです。 <emphasis>対話 (conversation)</emphasis> は、ユーザーの観点からの作業単位です。 それはユーザーとのインタラクション、要求、およびデータベーストランザクションをまたぐかもしれません。 しかし、ユーザーにとって対話は、1 つの問題を解決します。 例えば、「ホテル予約」、「契約承認」、「注文作成」はすべて対話です。 対話というものが 1 つの「ユースケース」あるいは「ユーザーストーリ」を実装していると考えたいかもしれませんが、関係は必ずしもその通りにはなりません。"

#. Tag: para
#: Concepts.xml:110
#, no-c-format
msgid "A conversation holds state associated with \"what the user is doing now, in this window\". A single user may have multiple conversations in progress at any point in time, usually in multiple windows. The conversation context allows us to ensure that state from the different conversations does not collide and cause bugs."
msgstr "対話は、「ユーザーがこのウィンドウの中で現在していること」と関連づけられた状態を保持します。 1 人のユーザーは、通常マルチウィンドウで、ある時点に進行中の複数の対話を持っているかもしれません。 対話コンテキストは、異なる対話からの状態の衝突をなくし、バグの原因とならないことを保証します。"

#. Tag: para
#: Concepts.xml:116
#, no-c-format
msgid "It might take you some time to get used to thinking of applications in terms of conversations. But once you get used to it, we think you'll love the notion, and never be able to not think in terms of conversations again!"
msgstr "対話の観点からアプリケーションについて考えることに慣れるには時間がかかるかもしれません。 しかし、慣れてしまうと、このコンセプトが大好きになり、もう対話なしでは考えられなくなるだろうと思います。"

#. Tag: para
#: Concepts.xml:121
#, no-c-format
msgid "Some conversations last for just a single request. Conversations that span multiple requests must be demarcated using annotations provided by Seam."
msgstr "ある対話は単に 1 つの要求の間続いています。 複数の要求をまたぐ対話は、Seam によって提供されたアノテーションを使って、区分を示されなければなりません。"

#. Tag: para
#: Concepts.xml:125
#, no-c-format
msgid "Some conversations are also <emphasis>tasks</emphasis>. A task is a conversation that is significant in terms of a long-running business process, and has the potential to trigger a business process state transition when it is successfully completed. Seam provides a special set of annotations for task demarcation."
msgstr "一部の対話は <emphasis>タスク</emphasis> でもあります。 タスクは長期ビジネスプロセスの観点では重要な意味を持つ対話であり、 タスクが首尾よく完了する場合、 ビジネスプロセスの状態遷移を引き起こす可能性を持っています。 Seam はタスク区分用に特別なアノテーションのセットを提供します。"

#. Tag: para
#: Concepts.xml:131
#, no-c-format
msgid "Conversations may be <emphasis>nested</emphasis>, with one conversation taking place \"inside\" a wider conversation. This is an advanced feature."
msgstr "より広い対話の \"内部\" で対話を発生させるような <emphasis>ネスト</emphasis> も可能です。 これは拡張機能です。"

#. Tag: para
#: Concepts.xml:135
#, no-c-format
msgid "Usually, conversation state is actually held by Seam in the servlet session between requests. Seam implements configurable <emphasis>conversation timeout</emphasis>, automatically destroying inactive conversations, and thus ensuring that the state held by a single user login session does not grow without bound if the user abandons conversations."
msgstr "通常、実際には要求と要求の間サーブレットセッション中で Seam により対話状態は保持されます。 Seam は設定可能な <emphasis>対話タイムアウト (conversation timeout)</emphasis> を実装し、 自動的に不活性な対話を破棄し、 ユーザーが対話を中断しても、ユーザーログインセッションにより保持される状態は際限なく増加しないことが保証されています。"

#. Tag: para
#: Concepts.xml:141
#, no-c-format
msgid "Seam serializes processing of concurrent requests that take place in the same long-running conversation context, in the same process."
msgstr "Seam は同じプロセス中の同じ長期対話コンテキスト中で発生する並列の要求処理をシリアル化します。"

#. Tag: para
#: Concepts.xml:145
#, no-c-format
msgid "Alternatively, Seam may be configured to keep conversational state in the client browser."
msgstr "あるいは、Seam はクライアントブラウザの中に対話の状態を保持するように設定される場合もあります。"

#. Tag: title
#: Concepts.xml:151
#, no-c-format
msgid "<title>Session context</title>"
msgstr "<title>セッションコンテキスト</title>"

#. Tag: para
#: Concepts.xml:152
#, no-c-format
msgid "A session context holds state associated with the user login session. While there are some cases where it is useful to share state between several conversations, we generally frown on the use of session context for holding components other than global information about the logged in user."
msgstr "セッションコンテキストはユーザーログインに関する状態を保持します。 いくつかの場合では対話の間で状態を共有することが有用なことがありますが、 ログインユーザーに関するグローバル情報以外のコンポーネントを保持するために、 セッションコンテキストを使用することは賛成できません。"

#. Tag: para
#: Concepts.xml:157
#, no-c-format
msgid "In a JSR-168 portal environment, the session context represents the portlet session."
msgstr "JSR-168 ポータル環境では、セッションコンテキストはポートレットセッションを意味します。"

#. Tag: title
#: Concepts.xml:163
#, no-c-format
msgid "<title>Business process context</title>"
msgstr "<title>ビジネスプロセスコンテキスト</title>"

#. Tag: para
#: Concepts.xml:164
#, no-c-format
msgid "The business process context holds state associated with the long running business process. This state is managed and made persistent by the BPM engine (JBoss jBPM). The business process spans multiple interactions with multiple users, so this state is shared between multiple users, but in a well-defined manner. The current task determines the current business process instance, and the lifecycle of the business process is defined externally using a <emphasis>process definition language</emphasis>, so there are no special annotations for business process demarcation."
msgstr "ビジネスプロセスコンテキストは長期ビジネスプロセスに関する状態を保持します。 この状態は BPM エンジン (JBoss jBPM) によって管理や永続化が行われます。 ビジネスプロセスは、複数ユーザーの複数インタラクションを橋渡しします。 従って、この状態は複数ユーザーの間で明確な方法で共有されます。 現在のタスクは現在のビジネスプロセスインスタンスを決定し、 ビジネスプロセスのライフサイクルは <emphasis>プロセス定義言語 (process definition language)</emphasis> を使用することで外部に定義されます。 従って、ビジネスプロセスの区分のために特別なアノテーションはありません。"

#. Tag: title
#: Concepts.xml:175
#, no-c-format
msgid "<title>Application context</title>"
msgstr "<title>アプリケーションコンテキスト</title>"

#. Tag: para
#: Concepts.xml:176
#, no-c-format
msgid "The application context is the familiar servlet context from the servlet spec. Application context is mainly useful for holding static information such as configuration data, reference data or metamodels. For example, Seam stores its own configuration and metamodel in the application context."
msgstr "アプリケーションコンテキストはサーブレット仕様からおなじみのサーブレットのコンテキストです。 アプリケーションコンテキストは主に、設定データ、参照データ、メタモデルのような静的な情報を保持するために役立ちます。 例えば、Seam はアプリケーションコンテキスト内に Seam 設定やメタモデルを保管しています。"

#. Tag: title
#: Concepts.xml:184
#, no-c-format
msgid "Context variables"
msgstr "コンテキスト変数"

#. Tag: para
#: Concepts.xml:185
#, no-c-format
msgid "A context defines a namespace, a set of <emphasis>context variables</emphasis>. These work much the same as session or request attributes in the servlet spec. You may bind any value you like to a context variable, but usually we bind Seam component instances to context variables."
msgstr "コンテキストは名前空間、<emphasis>コンテキスト変数</emphasis> のセットを定義します。 これらはサーブレット仕様のセッションや要求属性と同様に機能します。 どのような値でもコンテキスト変数とバインドができますが、 通常、Seam コンポーネントインスタンスをコンテキスト変数にバインドします。"

#. Tag: para
#: Concepts.xml:191
#, no-c-format
msgid "So, within a context, a component instance is identified by the context variable name (this is usually, but not always, the same as the component name). You may programatically access a named component instance in a particular scope via the <literal>Contexts</literal> class, which provides access to several thread-bound instances of the <literal>Context</literal> interface:"
msgstr "従って、コンテキスト中では、 コンポーネントインスタンスは、コンテキスト変数名 (いつもではないが通常はコンポーネント名と同じ) で識別されます。 <literal>Contexts</literal> クラスを通して特定のスコープの指定されたコンポーネントインスタンスにプログラム的にアクセスもできます。 それは <literal>Context</literal> インタフェースのスレッドに結びついたインスタンスへのアクセスを提供します。"

#. Tag: programlisting
#: Concepts.xml:198
#, no-c-format
msgid "<![CDATA[User user = (User) Contexts.getSessionContext().get(\"user\");]]>"
msgstr "<![CDATA[User user = (User) Contexts.getSessionContext().get(\"user\");]]>"

#. Tag: para
#: Concepts.xml:200
#, no-c-format
msgid "You may also set or change the value associated with a name:"
msgstr "名前に関連する値を設定したり変更したりすることもできます。"

#. Tag: programlisting
#: Concepts.xml:204
#, no-c-format
msgid "<![CDATA[Contexts.getSessionContext().set(\"user\", user);]]>"
msgstr "<![CDATA[Contexts.getSessionContext().set(\"user\", user);]]>"

#. Tag: para
#: Concepts.xml:206
#, no-c-format
msgid "Usually, however, we obtain components from a context via injection, and put component instances into a context via outjection."
msgstr "しかしながら、通常、インジェクションを通してコンテキストからコンポーネントを取得し、 アウトジェクションを通してコンポーネントインスタンスをコンテキストに配置します。"

#. Tag: title
#: Concepts.xml:213
#, no-c-format
msgid "Context search priority"
msgstr "コンテキスト検索優先順位"

#. Tag: para
#: Concepts.xml:214
#, no-c-format
msgid "Sometimes, as above, component instances are obtained from a particular known scope. Other times, all stateful scopes are searched, in <emphasis>priority order</emphasis>. The order is as follows:"
msgstr "上記のように、コンポーネントインスタンスは特定の周知のスコープから取得することもありますが、 それ以外の場合、すべてのステートフルスコープは <emphasis>優先順位</emphasis> に従って検索されます。 その順序は以下の通りです。"

#. Tag: para
#: Concepts.xml:221
#, no-c-format
msgid "<para>Event context</para>"
msgstr "<para>イベントコンテキスト</para>"

#. Tag: para
#: Concepts.xml:240
#, no-c-format
msgid "You can perform a priority search by calling <literal>Contexts.lookupInStatefulContexts()</literal>. Whenever you access a component by name from a JSF page, a priority search occurs."
msgstr "<literal>Contexts.lookupInStatefulContexts()</literal> を呼び出すことによって優先順位の検索も可能です。 JSF ページから名前によってアクセスする場合はいつも、優先順位検索が発生します。"

#. Tag: title
#: Concepts.xml:248
#, no-c-format
msgid "Concurrency model"
msgstr "同時並行処理モデル"

#. Tag: para
#: Concepts.xml:249
#, no-c-format
msgid "Neither the servlet nor EJB specifications define any facilities for managing concurrent requests originating from the same client. The servlet container simply lets all threads run concurrently and leaves enforcing threadsafeness to application code. The EJB container allows stateless components to be accessed concurrently, and throws an exception if multiple threads access a stateful session bean."
msgstr "サーブレット仕様も EJB 仕様も同じクライアントから起こる同時並行の要求を管理するための仕組みをまったく定義していません。 サーブレットコンテナは単純にすべてのスレッドを同時並行的に稼動させ、 スレッドセーフとすることをアプリケーションコードに任せます。 EJB コンテナはステートレスコンポーネントが同時並行的にアクセスされることを可能にし、 複数のスレッドがひとつのステートレスセッション Bean にアクセスするならば例外をスローします。"

#. Tag: para
#: Concepts.xml:255
#, no-c-format
msgid "This behavior might have been okay in old-style web applications which were based around fine-grained, synchronous requests. But for modern applications which make heavy use of many fine-grained, asynchronous (AJAX) requests, concurrency is a fact of life, and must be supported by the programming model. Seam weaves a concurrency management layer into its context model."
msgstr "この振る舞いは粒度の細かい同期要求をベースとする古いスタイルの Web アプリケーションでは大丈夫であったかもしれません。 しかし、多くの粒度の細かい非同期要求 (AJAX) を多用する最新のアプリケーションにとって、 同時並行はまぎれもない事実であり、プログラムモデルとしてサポートされなければなりません。 Seam は同時並行管理レイヤをコンテキストモデルに織り込みます。"

#. Tag: para
#: Concepts.xml:261
#, no-c-format
msgid "The Seam session and application contexts are multithreaded. Seam will allow concurrent requests in a context to be processed concurrently. The event and page contexts are by nature single threaded. The business process context is strictly speaking multi-threaded, but in practice concurrency is sufficiently rare that this fact may be disregarded most of the time. Finally, Seam enforces a <emphasis>single thread per conversation per process</emphasis> model for the conversation context by serializing concurrent requests in the same long-running conversation context."
msgstr "Seam セッションとアプリケーションコンテキストはマルチスレッドになっています。 Seam は同時並行的に処理されるためにコンテキスト中での同時並行要求を許します。 イベントとページコンテキストは本来シングルスレッドです。 厳密に言えばビジネスプロセスコンテキストはマルチスレッドですが、 実際には同時並行はとてもまれで、この事実はほとんど着目されないかもしれません。 最後に、 同じ長期対話コンテキスト中の同時並行要求をシリアライズすることによって、 Seam は、対話コンテキストのために <emphasis>プロセスごと対話ごとのシングルスレッド</emphasis> モデルを実施します。"

# 2.1
#. Tag: para
#: Concepts.xml:269
#, no-c-format
msgid "Since the session context is multithreaded, and often contains volatile state, session scope components are always protected by Seam from concurrent access so long as the Seam interceptors are not disabled for that component. If interceptors are disabled, then any thread-safety that is required must be implemented by the component itself. Seam serializes requests to session scope session beans and JavaBeans by default (and detects and breaks any deadlocks that occur). This is not the default behaviour for application scoped components however, since application scoped components do not usually hold volatile state and because synchronization at the global level is <emphasis>extremely</emphasis> expensive. However, you can force a serialized threading model on any session bean or JavaBean component by adding the <literal>@Synchronized</literal> annotation."
msgstr "セッションコンテキストはマルチスレッドで、よく揮発性の状態を含むので、 そのコンポーネントのSeamインタセプタが無効にされていない限り、Seam によりセッションスコープコンポーネントは同時並行アクセスからいつも保護されています。 もしインタセプタが無効にされていたら、要求されるスレッドセーフ性はコンポーネント自身によって実装されなければなりません。Seam はデフォルトで要求を セッションスコープセッション Bean と JavaBean にシリアライズします。 ( そして、発生するどんなデッドロックも検出して打開します。) アプリケーションスコープのコンポーネントは通常揮発性の状態を保持しないため、 これはアプリケーションスコープのコンポーネントのためのデフォルトの振る舞いではありません。 なぜなら、グローバルレベルの同期化は <emphasis>極端に</emphasis> コストがかかるからです。 しかし、 <literal>@Synchronized</literal> アノテーションを追加することで、 セッション Bean または JavaBean コンポーネントにシリアライズされたスレッドモデルを強制可能です。"

#. Tag: para
#: Concepts.xml:280
#, no-c-format
msgid "This concurrency model means that AJAX clients can safely use volatile session and conversational state, without the need for any special work on the part of the developer."
msgstr "この同時並行モデルは、 開発者側での特別な作業をまったく必要とすることなく、 AJAX クライアントが安全に揮発性セッションや対話状態を使用できることを意味します。"

#. Tag: title
#: Concepts.xml:289
#, no-c-format
msgid "Seam components"
msgstr "Seam コンポーネント"

#. Tag: para
#: Concepts.xml:290
#, no-c-format
msgid "Seam components are POJOs (Plain Old Java Objects). In particular, they are JavaBeans or EJB 3.0 enterprise beans. While Seam does not require that components be EJBs and can even be used without an EJB 3.0 compliant container, Seam was designed with EJB 3.0 in mind and includes deep integration with EJB 3.0. Seam supports the following <emphasis>component types</emphasis>."
msgstr "Seam コンポーネントは POJO (Plain Old Java Objects) です。 具体的には、Seam コンポーネントは JavaBean もしくは EJB 3.0 エンタープライズ Bean です。 Seam は コンポーネントが EJB であることが必須ではなく、また EJB 3.0 準拠のコンテナがなくても使用できますが、 Seam は EJB 3.0 を念頭にして設計され、EJB 3.0 と強く統合されています。 Seam は以下の <emphasis>コンポーネントタイプ</emphasis> をサポートします。"

#. Tag: para
#: Concepts.xml:299
#, no-c-format
msgid "EJB 3.0 stateless session beans"
msgstr "EJB 3.0 ステートレスセッション Bean"

#. Tag: para
#: Concepts.xml:302
#, no-c-format
msgid "EJB 3.0 stateful session beans"
msgstr "EJB 3.0 ステートフルセッション Bean"

#. Tag: para
#: Concepts.xml:305
#, no-c-format
msgid "EJB 3.0 entity beans"
msgstr "EJB 3.0 エンティティ Bean"

#. Tag: para
#: Concepts.xml:308
#, no-c-format
msgid "<para>JavaBeans</para>"
msgstr "<para>JavaBeans</para>"

#. Tag: para
#: Concepts.xml:311
#, no-c-format
msgid "EJB 3.0 message-driven beans"
msgstr "EJB 3.0 メッセージ駆動型 Bean"

#. Tag: title
#: Concepts.xml:316
#, no-c-format
msgid "Stateless session beans"
msgstr "ステートレスセッション Bean"

#. Tag: para
#: Concepts.xml:317
#, no-c-format
msgid "Stateless session bean components are not able to hold state across multiple invocations. Therefore, they usually work by operating upon the state of other components in the various Seam contexts. They may be used as JSF action listeners, but cannot provide properties to JSF components for display."
msgstr "ステートレスセッション Bean コンポーネントは、複数の呼出しに対して状態を保持することができません。 従って、それらは通常さまざまな Seam コンテキスト内の別コンポーネントの状態を操作するのに役に立ちます。 それらは JSF のアクションリスナーとして使用できるかもしれませんが、 表示のために JSF コンポーネントにプロパティを提供することはできません。"

#. Tag: para
#: Concepts.xml:322
#, no-c-format
msgid "Stateless session beans always live in the stateless context."
msgstr "ステートレスセッション Bean はいつもステートレスコンテキストに置かれます。"

#. Tag: para
#: Concepts.xml:325
#, no-c-format
msgid "Stateless session beans can be accessed concurrently as a new instance is used for each request. Assigning the instance to the request is the responsibility of the EJB3 container (normally instances will be allocated from a reusable pool meaning that you may find any instance variables contain data from previous uses of the bean)."
msgstr "新しいインスタンスが各要求で使用されるのと同様にステートレスセッション Bean は同時並行的にアクセスされることが可能です。 インスタンスを要求に割り当てることは EJB3 コンテナの責務です。 ( 通常インスタンスは再利用可能なプールから割り当てられます、 つまり、Bean の使用済みのものからデータを含むインスタンス変数を見つけることができることを意味します。) "

#. Tag: para
#: Concepts.xml:331
#, no-c-format
msgid "Stateless session beans are the least interesting kind of Seam component."
msgstr "ステートレスセッション Bean は最も興味のわかない種類の Seam コンポーネントです。"

#. Tag: para
#: Concepts.xml:334
#, no-c-format
msgid "Seam stateless session bean components may be instantiated using <literal>Component.getInstance()</literal> or <literal>@In(create=true)</literal>. They should not be directly instantiated via JNDI lookup or the <literal>new</literal> operator."
msgstr "Seam ステートレスセッション Bean コンポーネントは <literal>Component.getInstance()</literal> または <literal>@In(create=true)</literal> を使用してインスタンス化可能です。これらは JNDI ルックアップや 直接 new オペレータでインスタンス化されるべきではありません。 "

#. Tag: title
#: Concepts.xml:342
#, no-c-format
msgid "Stateful session beans"
msgstr "ステートフルセッション Bean"

#. Tag: para
#: Concepts.xml:343
#, no-c-format
msgid "Stateful session bean components are able to hold state not only across multiple invocations of the bean, but also across multiple requests. Application state that does not belong in the database should usually be held by stateful session beans. This is a major difference between Seam and many other web application frameworks. Instead of sticking information about the current conversation directly in the <literal>HttpSession</literal>, you should keep it in instance variables of a stateful session bean that is bound to the conversation context. This allows Seam to manage the lifecycle of this state for you, and ensure that there are no collisions between state relating to different concurrent conversations."
msgstr "ステートフルセッション Bean コンポーネントは、 Bean の複数の呼出しに対して状態を保持することができるだけでなく、 複数の要求に対して状態を保持することもできます。 データベースに保持されていないアプリケーションの状態は、 通常、ステートフルセッション Bean によって保持される必要があります。 これは Seam と他の多くの Web アプリケーションフレームワークとの大きな違いです。 現在の対話の情報を直接 <literal>HttpSession</literal> に押し込める代わりに、 対話コンテキストに結びついたステートフルセッション Bean のインスタンス変数の中にそれを保持すべきです。 これは、Seam がこの状態のライフサイクルの管理を可能にし、 異なる同時実行中の対話に関連する状態の間に衝突がないことを保証します。"

#. Tag: para
#: Concepts.xml:353
#, no-c-format
msgid "Stateful session beans are often used as JSF action listener, and as backing beans that provide properties to JSF components for display or form submission."
msgstr "ステートフルセッション Bean はしばしば JSF アクションリスナー、または、 表示もしくはフォームのサブミットのためにプロパティを提供する JSF コンポーネントのバッキング Bean として使用されます。"

#. Tag: para
#: Concepts.xml:357
#, no-c-format
msgid "By default, stateful session beans are bound to the conversation context. They may never be bound to the page or stateless contexts."
msgstr "デフォルトで、ステートフルセッション Bean は対話コンテキストとバインドします。 ページもしくはステートレスコンテキストとバインドできません。"

# 2.1
#. Tag: para
#: Concepts.xml:361
#, no-c-format
msgid "Concurrent requests to session-scoped stateful session beans are always serialized by Seam as long as the Seam interceptors are not disabled for the bean."
msgstr "セッションスコープのステートレスセッション Bean への同時並行要求は、 そのBeanへのSeamインタセプタが無効にされていない限り、常に Seam によってシリアライズされます。"

#. Tag: para
#: Concepts.xml:366
#, no-c-format
msgid "Seam stateful session bean components may be instantiated using <literal>Component.getInstance()</literal> or <literal>@In(create=true)</literal>. They should not be directly instantiated via JNDI lookup or the <literal>new</literal> operator."
msgstr "Seam ステートフルセッション Bean コンポーネントは <literal>Component.getInstance()</literal> または <literal>@In(create=true)</literal> を使用してインスタンス化可能です。これらは JNDI ルックアップや 直接 <literal>new</literal> オペレータでインスタンス化されるべきではありません。 "

#. Tag: title
#: Concepts.xml:374
#, no-c-format
msgid "Entity beans"
msgstr "エンティティ Bean"

#. Tag: para
#: Concepts.xml:375
#, no-c-format
msgid "Entity beans may be bound to a context variable and function as a seam component. Because entities have a persistent identity in addition to their contextual identity, entity instances are usually bound explicitly in Java code, rather than being instantiated implicitly by Seam."
msgstr "エンティティ Bean はコンテキスト変数とバインドし、Seamコンポーネントとして機能することもあります。 エンティティは、コンテキスト依存識別子に加えて永続識別子を持つために、 エンティティのインスタンスは、Seam によって暗黙的にインスタンス化されるより、 むしろ Java コード中で明示的にバインドされます。"

#. Tag: para
#: Concepts.xml:380
#, no-c-format
msgid "Entity bean components do not support bijection or context demarcation. Nor does invocation of an entity bean trigger validation."
msgstr "エンティティ Bean コンポーネントはバイジェクションもコンテキスト区分もサポートしません。 また、エンティティ Bean トリガのデータ妥当性検証の呼び出しもサポートしていません。"

#. Tag: para
#: Concepts.xml:384
#, no-c-format
msgid "Entity beans are not usually used as JSF action listeners, but do often function as backing beans that provide properties to JSF components for display or form submission. In particular, it is common to use an entity as a backing bean, together with a stateless session bean action listener to implement create/update/delete type functionality."
msgstr "エンティティ Bean は、通常 JSF アクションリスナーとして使用されませんが、 しばしば、表示あるいはフォームのサブミットのために JSF コンポーネントにプロパティを提供するバッキング Bean として機能します。 特に、エンティティ Bean をバッキング Bean として使用することは一般的であり、 追加 / 変更 / 削除タイプの機能の実装のためのステートレスセッション Bean アクションリスナーと一緒に使用されます。"

#. Tag: para
#: Concepts.xml:390
#, no-c-format
msgid "By default, entity beans are bound to the conversation context. They may never be bound to the stateless context."
msgstr "デフォルトで、エンティティ Bean は対話コンテキストとバインドします。 ステートレスセッション Bean とはバインドしません。"

#. Tag: para
#: Concepts.xml:394
#, no-c-format
msgid "Note that it in a clustered environment is somewhat less efficient to bind an entity bean directly to a conversation or session scoped Seam context variable than it would be to hold a reference to the entity bean in a stateful session bean. For this reason, not all Seam applications define entity beans to be Seam components."
msgstr "クラスタリングされた環境では、 ステートフルセッション Bean 中でエンティティ Bean の参照を保持することより、 エンティティ Bean を直接的に対話あるいはセッションスコープの Seam コンテキスト変数にバインドする方が多少非効率的であることに留意してください。 この理由のため、すべての Seam アプリケーションが Seam コンポーネントであるためにエンティティ Bean を定義するわけではありません。"

#. Tag: para
#: Concepts.xml:400
#, no-c-format
msgid "Seam entity bean components may be instantiated using <literal>Component.getInstance()</literal>, <literal>@In(create=true)</literal> or directly using the <literal>new</literal> operator."
msgstr "Seam エンティティ Bean コンポーネントは <literal>Component.getInstance()</literal> または <literal>@In(create=true)</literal> を使用してインスタンス化可能です。あるいは、直接 <literal>new</literal> オペレータを使用することが可能です。 "

#. Tag: title
#: Concepts.xml:407
#, no-c-format
msgid "<title>JavaBeans</title>"
msgstr "<title>JavaBeans</title>"

#. Tag: para
#: Concepts.xml:408
#, no-c-format
msgid "Javabeans may be used just like a stateless or stateful session bean. However, they do not provide the functionality of a session bean (declarative transaction demarcation, declarative security, efficient clustered state replication, EJB 3.0 persistence, timeout methods, etc)."
msgstr "JavaBean はステートレスあるいはステートフルセッション Bean のように使用されることもあります。 しかし、それらはセッション Bean の機能を提供していません。 (宣言的トランザクション区分、 宣言的セキュリティ、 効率的にクラスタ化された状態レプリケーション、 EJB 3.0 永続性、 タイムアウトメソッドなど)"

#. Tag: para
#: Concepts.xml:413
#, no-c-format
msgid "In a later chapter, we show you how to use Seam and Hibernate without an EJB container. In this use case, components are JavaBeans instead of session beans. Note, however, that in many application servers it is somewhat less efficient to cluster conversation or session scoped Seam JavaBean components than it is to cluster stateful session bean components."
msgstr "後の章で、EJB コンテナなしで Seam や Hibernate を使用する方法を紹介しています。 このユースケースでは、コンポーネントはセッション Bean の代わりに JavaBean です。 しかし、多くのアプリケーションサーバーでは、 ステートフルセッション Bean コンポーネントをクラスタリングするより、 対話あるいはセッションスコープの Seam JavaBean コンポーネントをクラスタリングする方が多少非効率的であることに留意してください。"

#. Tag: para
#: Concepts.xml:419
#, no-c-format
msgid "By default, JavaBeans are bound to the event context."
msgstr "デフォルトで、JavaBean はイベントコンテキストとバインドします。"

#. Tag: para
#: Concepts.xml:422
#, no-c-format
msgid "Concurrent requests to session-scoped JavaBeans are always serialized by Seam."
msgstr "セッションスコープの JavaBean への同時並行要求はいつも Seam によりシリアライズされます。"

#. Tag: para
#: Concepts.xml:425
#, no-c-format
msgid "Seam JavaBean components may be instantiated using <literal>Component.getInstance()</literal> or <literal>@In(create=true)</literal>. They should not be directly instantiated using the <literal>new</literal> operator."
msgstr "Seam JavaBean コンポーネントは <literal>Component.getInstance()</literal> または <literal>@In(create=true)</literal> を使用してインスタンス化可能です。これらは直接 <literal>new</literal> オペレータでインスタンス化されるべきではありません。 "

#. Tag: title
#: Concepts.xml:433
#, no-c-format
msgid "Message-driven beans"
msgstr "メッセージ駆動型 Bean"

#. Tag: para
#: Concepts.xml:434
#, no-c-format
msgid "Message-driven beans may function as a seam component. However, message-driven beans are called quite differently to other Seam components - instead of invoking them via the context variable, they listen for messages sent to a JMS queue or topic."
msgstr "メッセージ駆動形 Bean は Seam コンポーネントとして機能することができます。 しかし、メッセージ駆動型 Bean は、他の Seam コンポーネントとまったく異なった形で呼び出されます。 コンテキスト変数を通じてそれらを呼び出す代わりに、 JMS キュー あるいは、トピックに送信されたメッセージを待ち受けます。"

#. Tag: para
#: Concepts.xml:439
#, no-c-format
msgid "Message-driven beans may not be bound to a Seam context. Nor do they have access to the session or conversation state of their \"caller\". However, they do support bijection and some other Seam functionality."
msgstr "メッセージ駆動形 Bean は、Seam コンテキストとバインドできません。 また、それらの「呼び出し元」のセッションや対話状態にアクセスできません。 しかし、メッセージ駆動形 Bean は、バイジェクションと他の Seam の機能をサポートします。"

#. Tag: para
#: Concepts.xml:444
#, no-c-format
msgid "Message-driven beans are never instantiated by the application. They are instantiated by the EJB container when a message is received."
msgstr "メッセージ駆動型 Bean はアプリケーションによってインスタンス化されません。これらはメッセージを受信したときに EJB コンテナによってインスタンス化されます。 "

#. Tag: title
#: Concepts.xml:451
#, no-c-format
msgid "Interception"
msgstr "インタセプション"

#. Tag: para
#: Concepts.xml:452
#, no-c-format
msgid "In order to perform its magic (bijection, context demarcation, validation, etc), Seam must intercept component invocations. For JavaBeans, Seam is in full control of instantiation of the component, and no special configuration is needed. For entity beans, interception is not required since bijection and context demarcation are not defined. For session beans, we must register an EJB interceptor for the session bean component. We could use an annotation, as follows:"
msgstr "Seamのマジック (バイジェクション、コンテキスト区分、データ妥当性検証など) を実行するために、 Seam はコンポーネントの呼び出しをインタセプトしなければなりません。 JavaBean では、Seam はコンポーネントのインスタンス化を完全に制御するため、特別な設定は不要です。 エンティティ Bean では、バイジェクションとコンテキスト区分が指定されていないため、インタセプションは不要です。 セッション Bean では、EJB インタセプタをセッション Bean コンポーネントのために登録しなければなりません。 アノテーションは以下のように使用します。"

#. Tag: programlisting
#: Concepts.xml:460
#, no-c-format
msgid ""
"<![CDATA[@Stateless\n"
"@Interceptors(SeamInterceptor.class)\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Stateless\n"
"@Interceptors(SeamInterceptor.class)\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:462
#, no-c-format
msgid "But a much better way is to define the interceptor in <literal>ejb-jar.xml</literal>."
msgstr "しかし、もっと良い方法は、<literal>ejb-jar.xml</literal> にインタセプタを定義することです。"

#. Tag: programlisting
#: Concepts.xml:466
#, no-c-format
msgid ""
"<![CDATA[<interceptors>\n"
"   <interceptor>\n"
"      <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>\n"
"   </interceptor>\n"
"</interceptors>\n"
"   \n"
"<assembly-descriptor>\n"
"   <interceptor-binding>\n"
"      <ejb-name>*</ejb-name>\n"
"      <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>\n"
"   </interceptor-binding>\n"
"</assembly-descriptor>]]>"
msgstr ""
"<![CDATA[<interceptors>\n"
"   <interceptor>\n"
"      <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>\n"
"   </interceptor>\n"
"</interceptors>\n"
"   \n"
"<assembly-descriptor>\n"
"   <interceptor-binding>\n"
"      <ejb-name>*</ejb-name>\n"
"      <interceptor-class>org.jboss.seam.ejb.SeamInterceptor</interceptor-class>\n"
"   </interceptor-binding>\n"
"</assembly-descriptor>]]>"

#. Tag: title
#: Concepts.xml:471
#, no-c-format
msgid "Component names"
msgstr "コンポーネント名"

#. Tag: para
#: Concepts.xml:472
#, no-c-format
msgid "All seam components need a name. We can assign a name to a component using the <literal>@Name</literal> annotation:"
msgstr "すべての Seam コンポーネントは名前が必要です。 <literal>@Name</literal> アノテーションを使用してコンポーネントに名前を割り当てます。"

#. Tag: programlisting
#: Concepts.xml:477
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:479
#, no-c-format
msgid "This name is the <emphasis>seam component name</emphasis> and is not related to any other name defined by the EJB specification. However, seam component names work just like JSF managed bean names and you can think of the two concepts as identical."
msgstr "この名前は、<emphasis>Seam コンポーネント名</emphasis> で、 EJB 標準で定義された他の名前との関連はありません。 しかし、Seam コンポーネント名はちょうど JSF 管理 Bean のように動作するため、 2 つのコンセプトは同一と考えることができます。"

#. Tag: para
#: Concepts.xml:485
#, no-c-format
msgid "<literal>@Name</literal> is not the only way to define a component name, but we always need to specify the name <emphasis>somewhere</emphasis>. If we don't, then none of the other Seam annotations will function."
msgstr "<literal>@Name</literal> はコンポーネント名を定義する唯一の方法ではありませんが、 いつも、<emphasis>どこか</emphasis>で名前を指定する必要があります。 もしそうしないと、他の Seam アノテーションはどれも機能しないでしょう。"

#. Tag: para
#: Concepts.xml:491
#, no-c-format
msgid "Just like in JSF, a seam component instance is usually bound to a context variable with the same name as the component name. So, for example, we would access the <literal>LoginAction</literal> using <literal>Contexts.getStatelessContext().get(\"loginAction\")</literal>. In particular, whenever Seam itself instantiates a component, it binds the new instance to a variable with the component name. However, again like JSF, it is possible for the application to bind a component to some other context variable by programmatic API call. This is only useful if a particular component serves more than one role in the system. For example, the currently logged in <literal>User</literal> might be bound to the <literal>currentUser</literal> session context variable, while a <literal>User</literal> that is the subject of some administration functionality might be bound to the <literal>user</literal> conversation context variable."
msgstr "ちょうど JSF のように、Seam コンポーネントインスタンスは、 通常コンポーネント名と同じ名前のコンテキスト変数と結合します。 従って、例えば、<literal>Contexts.getStatelessContext().get(\"loginAction\")</literal> を使って、 <literal>LoginAction</literal> にアクセスできるでしょう。 具体的には、Seam 自身がコンポーネントをインスタンス化する時はいつでも、 それはコンポーネント名によって新しいインスタンスを変数と結合します。 しかし、この場合も JSF のように、 アプリケーションはプログラムに基づいた API コールによってコンポーネントを他のコンテキスト変数と結合させることも可能です。 特定のコンポーネントがシステムの中で複数のロールを提供する場合のみ、これは有用です。 例えば、現在のログイン <literal>User</literal> は <literal>currentUser</literal> セッションコンテキスト変数に結合されているかもしれませんが、 一方で、ある管理機能を果たす <literal>User</literal> は <literal>user</literal> 対話コンテキスト変数に結合されているかもしれません。"

#. Tag: para
#: Concepts.xml:504
#, no-c-format
msgid "For very large applications, and for built-in seam components, qualified names are often used."
msgstr "非常に大規模なアプリケーションのために、そして組み込み Seam コンポーネントのために、修飾名はしばしば使われます。"

#. Tag: programlisting
#: Concepts.xml:508
#, no-c-format
msgid ""
"<![CDATA[@Name(\"com.jboss.myapp.loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"com.jboss.myapp.loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:510
#, no-c-format
msgid "We may use the qualified component name both in Java code and in JSF's expression language:"
msgstr "Java コード中でも JSF の式言語中でも修飾されたコンポーネント名は使用できます。"

#. Tag: programlisting
#: Concepts.xml:514
#, no-c-format
msgid ""
"<![CDATA[<h:commandButton type=\"submit\" value=\"Login\"\n"
"                 action=\"#{com.jboss.myapp.loginAction.login}\"/>]]>"
msgstr ""
"<![CDATA[<h:commandButton type=\"submit\" value=\"Login\"\n"
"                 action=\"#{com.jboss.myapp.loginAction.login}\"/>]]>"

#. Tag: para
#: Concepts.xml:516
#, no-c-format
msgid "Since this is noisy, Seam also provides a means of aliasing a qualified name to a simple name. Add a line like this to the <literal>components.xml</literal> file:"
msgstr "これはうっとうしいので、Seam は修飾名を簡単な名前にエイリアスする機能も提供します。 以下のような行を <literal>components.xml</literal> ファイルに追加してください。"

#. Tag: programlisting
#: Concepts.xml:521
#, no-c-format
msgid "<![CDATA[<factory name=\"loginAction\" scope=\"STATELESS\" value=\"#{com.jboss.myapp.loginAction}\"/>]]>"
msgstr "<![CDATA[<factory name=\"loginAction\" scope=\"STATELESS\" value=\"#{com.jboss.myapp.loginAction}\"/>]]>"

# 2.1
#. Tag: para
#: Concepts.xml:523
#, no-c-format
msgid "All of the built-in Seam components have qualified names but can be accessed through their unqualified names due to the namespace import feature of Seam. The <literal>components.xml</literal> file included in the Seam JAR defines the following namespaces."
msgstr "すべての組み込み Seam コンポーネントは修飾名を持っていますが、 Seamの名前空間をインポートする機能によって非修飾名でもアクセスすることができます。Seam JARに含まれる <literal>components.xml</literal> ファイルは以下の名前空間を定義します。"

#. Tag: programlisting
#: Concepts.xml:530
#, no-c-format
msgid ""
"&lt;components xmlns=&quot;http://jboss.com/products/seam/components&quot;&gt;\n"
"    \n"
"    &lt;import&gt;org.jboss.seam.core&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.cache&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.transaction&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.framework&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.web&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.faces&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.international&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.theme&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.pageflow&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.bpm&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.jms&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.mail&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.security&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.security.management&lt;/import&gt;  \n"
"    &lt;import&gt;org.jboss.seam.security.permission&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.captcha&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.excel.exporter&lt;/import&gt;\n"
"    &lt;!-- ... ---&gt;\n"
"&lt;/components&gt;"
msgstr ""
"&lt;components xmlns=&quot;http://jboss.com/products/seam/components&quot;&gt;\n"
"    \n"
"    &lt;import&gt;org.jboss.seam.core&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.cache&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.transaction&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.framework&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.web&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.faces&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.international&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.theme&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.pageflow&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.bpm&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.jms&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.mail&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.security&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.security.management&lt;/import&gt;  \n"
"    &lt;import&gt;org.jboss.seam.security.permission&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.captcha&lt;/import&gt;\n"
"    &lt;import&gt;org.jboss.seam.excel.exporter&lt;/import&gt;\n"
"    &lt;!-- ... ---&gt;\n"
"&lt;/components&gt;"

# 2.1
#. Tag: para
#: Concepts.xml:532
#, no-c-format
msgid "When attempting to resolve an unqualified name, Seam will check each of those namespaces, in order. You can include additional namespaces in your application's <literal>components.xml</literal> file for application-specific namespaces."
msgstr "修飾された名前を解決するときは、Seamは順にそれぞれの名前空間を調べます。アプリケーション固有の名前空間のためにはアプリケーションの<literal>components.xml</literal>ファイルに追加する名前空間を含めます。"

#. Tag: title
#: Concepts.xml:540
#, no-c-format
msgid "Defining the component scope"
msgstr "コンポーネントスコープの定義"

#. Tag: para
#: Concepts.xml:541
#, no-c-format
msgid "We can override the default scope (context) of a component using the <literal>@Scope</literal> annotation. This lets us define what context a component instance is bound to, when it is instantiated by Seam."
msgstr "<literal>@Scope</literal>アノテーションを使用して、コンポーネントのデフォルトスコープ (コンテキスト) をオーバーライドすることができます。 これにより Seam によってインスタンス化される時に、 コンポーネントインスタンスがどんなコンテキストと結合するかを定義ができます。"

#. Tag: programlisting
#: Concepts.xml:547
#, no-c-format
msgid ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(SESSION)\n"
"public class User { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(SESSION)\n"
"public class User { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:549
#, no-c-format
msgid "<literal>org.jboss.seam.ScopeType</literal> defines an enumeration of possible scopes."
msgstr "<literal>org.jboss.seam.ScopeType</literal> は、可能なスコープの列挙を定義します。"

#. Tag: title
#: Concepts.xml:556
#, no-c-format
msgid "Components with multiple roles"
msgstr "複数ロールを持つコンポーネント"

#. Tag: para
#: Concepts.xml:557
#, no-c-format
msgid "Some Seam component classes can fulfill more than one role in the system. For example, we often have a <literal>User</literal> class which is usually used as a session-scoped component representing the current user but is used in user administration screens as a conversation-scoped component. The <literal>@Role</literal> annotation lets us define an additional named role for a component, with a different scope&#8212;it lets us bind the same component class to different context variables. (Any Seam component <emphasis>instance</emphasis> may be bound to multiple context variables, but this lets us do it at the class level, and take advantage of auto-instantiation.)"
msgstr "一部の Seam コンポーネントクラスはシステムの中で複数のロールを果たすことができます。 例えば、セッションスコープのコンポーネント <literal>User</literal> クラスは、 よく現在のユーザーとして使用されますが、ユーザー管理画面では対話スコープのコンポーネントとして使用されます。 <literal>@Role</literal> アノテーションは、コンポーネントに対して異なったスコープを持つ追加指定のロールの定義を可能にしています。 これにより、 同じコンポーネントクラスを異なるコンテキスト変数にバインドすることができるようになります。 (どの Seam コンポーネント <emphasis>インスタンス</emphasis> も複数のコンテキスト変数にバインドが可能ですが、 これはクラスレベルで可能であり自動インスタンス化を利用しています。)"

#. Tag: programlisting
#: Concepts.xml:567
#, no-c-format
msgid ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(CONVERSATION)\n"
"@Role(name=\"currentUser\", scope=SESSION)\n"
"public class User { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(CONVERSATION)\n"
"@Role(name=\"currentUser\", scope=SESSION)\n"
"public class User { \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:569
#, no-c-format
msgid "The <literal>@Roles</literal> annotation lets us specify as many additional roles as we like."
msgstr "<literal>@Roles</literal> アノテーションは、欲しいだけ多くの追加のロールの指定を可能にします。"

#. Tag: programlisting
#: Concepts.xml:573
#, no-c-format
msgid ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(CONVERSATION)\n"
"@Roles({@Role(name=\"currentUser\", scope=SESSION),\n"
"        @Role(name=\"tempUser\", scope=EVENT)})\n"
"public class User { \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"user\")\n"
"@Entity\n"
"@Scope(CONVERSATION)\n"
"@Roles({@Role(name=\"currentUser\", scope=SESSION),\n"
"        @Role(name=\"tempUser\", scope=EVENT)})\n"
"public class User { \n"
"    ... \n"
"}]]>"

#. Tag: title
#: Concepts.xml:578
#, no-c-format
msgid "Built-in components"
msgstr "組み込みコンポーネント"

#. Tag: para
#: Concepts.xml:579
#, no-c-format
msgid "Like many good frameworks, Seam eats its own dogfood and is implemented mostly as a set of built-in Seam interceptors (see later) and Seam components. This makes it easy for applications to interact with built-in components at runtime or even customize the basic functionality of Seam by replacing the built-in components with custom implementations. The built-in components are defined in the Seam namespace <literal>org.jboss.seam.core</literal> and the Java package of the same name."
msgstr "多くの良いフレームワークのように、 Seam は自分自身が提供している機能を使うことを心掛けています (Eat Your Own Dog Food) 。 組み込みの Seam インタセプタ (後述) と Seamコンポーネントのセットで実装されています。 これは、アプリケーションがランタイムで組み込みのコンポーネントとやり取り行うことを容易にします。 さらに、組み込みのコンポーネントを独自の実装に置き換えることによって Seam の基本機能をカスタマイズすることさえ容易にします。 組み込みのコンポーネントは Seam の名前空間 <literal>org.jboss.seam.core</literal> と 同じ名前の Java パッケージにおいて定義されます。"

#. Tag: para
#: Concepts.xml:586
#, no-c-format
msgid "The built-in components may be injected, just like any Seam components, but they also provide convenient static <literal>instance()</literal> methods:"
msgstr "組み込みコンポーネントは、Seam コンポーネントと同様にインジェクトすることも可能ですが、 便利なスタティック <literal>instance()</literal> メソッドも提供します。"

#. Tag: programlisting
#: Concepts.xml:590
#, no-c-format
msgid "<![CDATA[FacesMessages.instance().add(\"Welcome back, #{user.name}!\");]]>"
msgstr "<![CDATA[FacesMessages.instance().add(\"Welcome back, #{user.name}!\");]]>"

#. Tag: title
#: Concepts.xml:596
#, no-c-format
msgid "Bijection"
msgstr "バイジェクション"

#. Tag: para
#: Concepts.xml:597
#, no-c-format
msgid "<emphasis>Dependency injection</emphasis> or <emphasis>inversion of control</emphasis> is by now a familiar concept to most Java developers. Dependency injection allows a component to obtain a reference to another component by having the container \"inject\" the other component to a setter method or instance variable. In all dependency injection implementations that we have seen, injection occurs when the component is constructed, and the reference does not subsequently change for the lifetime of the component instance. For stateless components, this is reasonable. From the point of view of a client, all instances of a particular stateless component are interchangeable. On the other hand, Seam emphasizes the use of stateful components. So traditional dependency injection is no longer a very useful construct. Seam introduces the notion of <emphasis>bijection</emphasis> as a generalization of injection. In contrast to injection, bijection is:"
msgstr "<emphasis>依存性の注入 (dependency injection)</emphasis> あるいは <emphasis>制御の逆転 (inversion of control)</emphasis> は今ではもう大多数の Java 開発者によく知られた概念です。 依存性の注入はあるコンポーネントが他のコンポーネントの参照を持つのを可能にします。 それはコンテナによって setter メソッドあるいはインスタンス変数に他のコンポーネントを「インジェクト (注入）」させることで実現します。 これまであったすべての依存性の注入の実装では、 インジェクションはコンポーネントが生成されたときに起こり、 その後、参照はコンポーネントのライフサイクルの間で変化しません。 ステートレスコンポーネントにおいて、これは理にかなっています。 クライアントの観点から、特定のステートレスなコンポーネントのすべてのインスタンスは交換可能です。 一方、Seamはステートフルなコンポーネントの使用に重点を置いています。 従って、典型的な依存性の注入はもはやあまり有用な構造ではありません。 Seam はインジェクションの一般化として、<emphasis>バイジェクション (bijection)</emphasis> の概念を導入しました。 インジェクションと対比すると、バイジェクションは以下のようになります。"

# 2.0 modified
#. Tag: para
#: Concepts.xml:611
#, no-c-format
msgid "<emphasis>contextual</emphasis> - bijection is used to assemble stateful components from various different contexts (a component from a \"wider\" context may even have a reference to a component from a \"narrower\" context)"
msgstr "<emphasis>コンテキスト依存 (contextual)</emphasis> - バイジェクションはさまざまな異なるコンテキストからステートフルなコンポーネントを組み立てるために使用されます。 (「より広い (wider) 」コンテキストからのコンポーネントは「より狭い  (narrow) 」コンテキストからの参照も持つかもしれません。)"

# 2.0 modified
#. Tag: para
#: Concepts.xml:618
#, no-c-format
msgid "<emphasis>bidirectional</emphasis> - values are injected from context variables into attributes of the component being invoked, and also <emphasis>outjected</emphasis> from the component attributes back out to the context, allowing the component being invoked to manipulate the values of contextual variables simply by setting its own instance variables"
msgstr "<emphasis>双方向性 (bidirectional)</emphasis> - 値はコンテキスト変数から呼ばれるコンポーネントの属性にインジェクトされ、 また、コンポーネント属性からコンテキストに<emphasis>アウトジェクト (outject)</emphasis> され戻されます。 インスタンス変数そのものを設定することで、呼ばれたコンポーネントが簡単にコンテキスト変数の値を操作することを可能にします。"

#. Tag: para
#: Concepts.xml:626
#, no-c-format
msgid "<emphasis>dynamic</emphasis> - since the value of contextual variables changes over time, and since Seam components are stateful, bijection takes place every time a component is invoked"
msgstr "<emphasis>動的 (dynamic)</emphasis> - バイジェクションはコンポーネントが呼ばれるたびに発生します。 なぜなら、コンテキストの値は時間経過で変化し、 Seam コンポーネントがステートフルだからです。"

#. Tag: para
#: Concepts.xml:633
#, no-c-format
msgid "In essence, bijection lets you alias a context variable to a component instance variable, by specifying that the value of the instance variable is injected, outjected, or both. Of course, we use annotations to enable bijection."
msgstr "本質的に、インスタンス変数の値をインジェクト、アウトジェクト、両方により指定することで、 バイジェクションはコンテキスト変数をコンポーネントのインスタンス変数にエイリアスを可能にします もちろん、バイジェクションを可能にするためにアノテーションが使用されています。"

#. Tag: para
#: Concepts.xml:639
#, no-c-format
msgid "The <literal>@In</literal> annotation specifies that a value should be injected, either into an instance variable:"
msgstr "<literal>@In</literal> アノテーションは値がインスタンス変数にインジェクトされることを指定しています。"

#. Tag: programlisting
#: Concepts.xml:644
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In User user;\n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In User user;\n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:646
#, no-c-format
msgid "or into a setter method:"
msgstr "あるいは、setter メソッドにインジェクトされます。"

#. Tag: programlisting
#: Concepts.xml:650
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @In\n"
"    public void setUser(User user) {\n"
"        this.user=user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @In\n"
"    public void setUser(User user) {\n"
"        this.user=user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:653
#, no-c-format
msgid "By default, Seam will do a priority search of all contexts, using the name of the property or instance variable that is being injected. You may wish to specify the context variable name explicitly, using, for example, <literal>@In(\"currentUser\")</literal>."
msgstr "デフォルトでは、 Seam はプロパティ名あるいはインジェクトされたインスタンス変数名を使用して、 すべてのコンテキストの優先順位検索を行います。 例えば、 <literal>@In(\"currentUser\")</literal>を使用することで明示的にコンテキスト変数を指定することもできます。"

#. Tag: para
#: Concepts.xml:659
#, no-c-format
msgid "If you want Seam to create an instance of the component when there is no existing component instance bound to the named context variable, you should specify <literal>@In(create=true)</literal>. If the value is optional (it can be null), specify <literal>@In(required=false)</literal>."
msgstr "指定されたコンテキスト変数と関連した既存のコンポーネントインスタンスが存在しないときに、 Seam にコンポーネントのインスタンスの生成を望むならば、 <literal>@In(create=true)</literal> を指定する必要があります。 値がオプションで (null でも可能) であれば、<literal>@In(required=false)</literal> を指定してください。"

#. Tag: para
#: Concepts.xml:665
#, no-c-format
msgid "For some components, it can be repetitive to have to specify <literal>@In(create=true)</literal> everywhere they are used. In such cases, you can annotate the component <literal>@AutoCreate</literal>, and then it will always be created, whenever needed, even without the explicit use of <literal>create=true</literal>."
msgstr "いくつかのコンポーネントでは、 それらが使用されるところではどこでも繰り返し <literal>@In(create=true)</literal> を指定する必要があるかもしれません。 このような場合、 コンポーネントに <literal>@AutoCreate</literal> アノテーションを付けることが可能で、 <literal>create=true</literal> を明示的に使用しなくても、 必要なとき常に作成されるようになります。"

#. Tag: para
#: Concepts.xml:671
#, no-c-format
msgid "You can even inject the value of an expression:"
msgstr "式の値をインジェクトすることも可能です。"

#. Tag: programlisting
#: Concepts.xml:675
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In(\"#{user.username}\") String username;\n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In(\"#{user.username}\") String username;\n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:677
#, no-c-format
msgid "Injected values are disinjected (i.e, set to <literal>null</literal>) immediately after method completion and outjection."
msgstr "注入された値はメソッドが終了しアウトジェクトされた後に逆方向に注入されます( 例えば <literal>null</literal> に設定されます )。"

#. Tag: para
#: Concepts.xml:682
#, no-c-format
msgid "(There is much more information about component lifecycle and injection in the next chapter.)"
msgstr "(コンポーネントライフサイクルとインジェクションについては次章により多くの情報があります。)"

#. Tag: para
#: Concepts.xml:686
#, no-c-format
msgid "The <literal>@Out</literal> annotation specifies that an attribute should be outjected, either from an instance variable:"
msgstr "<literal>@Out</literal>アノテーションは、属性がインスタンス変数からもアウトジェクトされるべきことを指定します。"

#. Tag: programlisting
#: Concepts.xml:691
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @Out User user;\n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @Out User user;\n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:693
#, no-c-format
msgid "or from a getter method:"
msgstr "あるいは getter メソッドからアウトジェクトされます。"

#. Tag: programlisting
#: Concepts.xml:697
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @Out\n"
"    public User getUser() {\n"
"        return user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @Out\n"
"    public User getUser() {\n"
"        return user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:699
#, no-c-format
msgid "An attribute may be both injected and outjected:"
msgstr "属性値はインジェクトされることもアウトジェクトされることも可能です。"

#. Tag: programlisting
#: Concepts.xml:703
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In @Out User user;\n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    @In @Out User user;\n"
"    ... \n"
"}]]>"

#. Tag: para
#: Concepts.xml:705
#, no-c-format
msgid "<para>or:</para>"
msgstr "<para>または、</para>"

#. Tag: programlisting
#: Concepts.xml:709
#, no-c-format
msgid ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @In\n"
"    public void setUser(User user) {\n"
"        this.user=user;\n"
"    }\n"
"    \n"
"    @Out\n"
"    public User getUser() {\n"
"        return user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"loginAction\")\n"
"@Stateless\n"
"public class LoginAction implements Login { \n"
"    User user;\n"
"    \n"
"    @In\n"
"    public void setUser(User user) {\n"
"        this.user=user;\n"
"    }\n"
"    \n"
"    @Out\n"
"    public User getUser() {\n"
"        return user;\n"
"    }\n"
"    \n"
"    ... \n"
"}]]>"

#. Tag: title
#: Concepts.xml:714
#, no-c-format
msgid "Lifecycle methods"
msgstr "ライフサイクルメソッド"

#. Tag: para
#: Concepts.xml:716
#, no-c-format
msgid "Session bean and entity bean Seam components support all the usual EJB 3.0 lifecycle callback (<literal>@PostConstruct</literal>, <literal>@PreDestroy</literal>, etc). But Seam also supports the use of any of these callbacks with JavaBean components. However, since these annotations are not available in a J2EE environment, Seam defines two additional component lifecycle callbacks, equivalent to <literal>@PostConstruct</literal> and <literal>@PreDestroy</literal>."
msgstr "セッション Bean とエンティティ Bean Seam コンポーネントは通常の EJB 3.0 のライフサイクルのコールバック (<literal>@PostConstruct</literal>、<literal>@PreDestroy</literal> など) のすべてをサポートしています。 しかも、Seam は JavaBean コンポーネント でのこれらコールバックの使用もサポートしています。 しかし、これらのアノテーションは J2EE 環境では有効とならないため、Seam は <literal>@PostConstruct</literal> と <literal>@PreDestroy</literal> と等価な 2 つの追加コンポーネントライフサイクルコールバックを定義しています。"

# 2.1 modified
#. Tag: para
#: Concepts.xml:724
#, no-c-format
msgid "The <literal>@Create</literal> method is called after Seam instantiates a component. Components may define only one <literal>@Create</literal> method."
msgstr " <literal>@Create</literal>  メソッドは Seam がコンポーネントをインスタンス化した後に呼ばれます。 コンポーネントは 1 つの <literal>@Create</literal >メソッドのみ定義可能です。 "

#. Tag: para
#: Concepts.xml:729
#, no-c-format
msgid "The <literal>@Destroy</literal> method is called when the context that the Seam component is bound to ends. Components may define only one <literal>@Destroy</literal> method."
msgstr " <literal>@Destroy</literal> メソッドは Seam コンポーネントがバインドするコンテキストが終了するときに呼ばれます。 コンポーネントは 1 つの <literal>@Destroy</literal> メソッドのみ定義可能です。 "

#. Tag: para
#: Concepts.xml:734
#, no-c-format
msgid "In addition, stateful session bean components <emphasis>must</emphasis> define a method with no parameters annotated <literal>@Remove</literal>. This method is called by Seam when the context ends."
msgstr "さらに、ステートフルセッション Bean コンポーネントはパラメータ無しの<literal>@Remove</literal>を付けることが<emphasis>必須</emphasis> です。このメソッドはコンテキストが終了するときに Seam により呼ばれます。"

#. Tag: para
#: Concepts.xml:739
#, no-c-format
msgid "Finally, a related annotation is the <literal>@Startup</literal> annotation, which may be applied to any application or session scoped component. The <literal>@Startup</literal> annotation tells Seam to instantiate the component immediately, when the context begins, instead of waiting until it is first referenced by a client. It is possible to control the order of instantiation of startup components by specifying <literal>@Startup(depends={....})</literal>."
msgstr "最後に、関連するアノテーションは <literal>@Startup</literal> アノテーションです。 それはアプリケーションやセッションスコープコンポーネントで利用可能です。 <literal>@Startup</literal> アノテーションは、 コンテキストが開始されたときにクライアントによる初めての参照を待つのではなく、 Seam に即座にコンポーネントをインスタンス化させさせます。 <literal>@Startup(depends={....})</literal> を指定することで、 スタートアップコンポーネントのインスタンス化する順序の制御が可能です。"

#. Tag: title
#: Concepts.xml:750
#, no-c-format
msgid "Conditional installation"
msgstr "条件付きインストール"

#. Tag: para
#: Concepts.xml:752
#, no-c-format
msgid "The <literal>@Install</literal> annotation lets you control conditional installation of components that are required in some deployment scenarios and not in others. This is useful if:"
msgstr "<literal>@Install</literal> アノテーションは、 特定のデプロイメントシナリオでは必須で別の場合はそうでないようなコンポーネントの条件付インストレーションを可能にします。 これは以下の場合に便利です。"

#. Tag: para
#: Concepts.xml:759
#, no-c-format
msgid "You want to mock out some infrastructural component in tests."
msgstr "テストで特定のインフラストラクチャのコンポーネントをモックとしたい。"

#. Tag: para
#: Concepts.xml:764
#, no-c-format
msgid "You want change the implementation of a component in certain deployment scenarios."
msgstr "特定のデプロイメントシナリオでコンポーネント実装を変更したい。"

#. Tag: para
#: Concepts.xml:770
#, no-c-format
msgid "You want to install some components only if their dependencies are available (useful for framework authors)."
msgstr "依存性が有効な場合だけに特定のコンポーネントをインストールしたい (フレームワークの作者に便利)。"

#. Tag: para
#: Concepts.xml:777
#, no-c-format
msgid "<literal>@Install</literal> works by letting you specify <emphasis>precedence</emphasis> and <emphasis>dependencies</emphasis>."
msgstr "<literal>@Install</literal> は <emphasis>優先順位</emphasis> と <emphasis>依存性</emphasis> を指定することで動作します。"

#. Tag: para
#: Concepts.xml:782
#, no-c-format
msgid "The precedence of a component is a number that Seam uses to decide which component to install when there are multiple classes with the same component name in the classpath. Seam will choose the component with the higher precendence. There are some predefined precedence values (in ascending order):"
msgstr "コンポーネントの優先順位は、 クラスパス中に同じコンポーネント名を持つ複数のクラスがある場合に、 インストールすべきコンポーネントを決定するために Seam が使用する番号です。 Seam はより優先順位が高いコンポーネントを選択します。 あらかじめ決められた優先順位の値があります (昇順)。"

#. Tag: para
#: Concepts.xml:791
#, no-c-format
msgid "<literal>BUILT_IN</literal> &#8212; the lowest precedece components are the components built in to Seam."
msgstr "<literal>BUILT_IN</literal> &#8212; Seam に組み込まれた最も優先順位が低いコンポーネントです。"

# 2.0 modified
#. Tag: para
#: Concepts.xml:797
#, no-c-format
msgid "<literal>FRAMEWORK</literal> &#8212; components defined by third-party frameworks may override built-in components, but are overridden by application components."
msgstr "<literal>FRAMEWORK</literal> &#8212; サードパーティフレームワークによって定義されたコンポーネントは組み込みコンポーネントをオーバーライドすることが可能ですが、アプリケーションコンポーネントによってオーバーライドされます。"

#. Tag: para
#: Concepts.xml:804
#, no-c-format
msgid "<literal>APPLICATION</literal> &#8212; the default precedence. This is appropriate for most application components."
msgstr "<literal>APPLICATION</literal> &#8212; デフォルト優先順位、 これはほとんどのアプリケーションコンポーネントにおいて適切です。"

#. Tag: para
#: Concepts.xml:810
#, no-c-format
msgid "<literal>DEPLOYMENT</literal> &#8212; for application components which are deployment-specific."
msgstr "<literal>DEPLOYMENT</literal> &#8212; デプロイメント固有のアプリケーションコンポーネント用です。"

#. Tag: para
#: Concepts.xml:816
#, no-c-format
msgid "<literal>MOCK</literal> &#8212; for mock objects used in testing."
msgstr "<literal>MOCK</literal> &#8212; テストに使用されるモックオブジェクト用です。"

# 2.0 modified
#. Tag: para
#: Concepts.xml:822
#, no-c-format
msgid "Suppose we have a component named <literal>messageSender</literal> that talks to a JMS queue."
msgstr "JMS キューと対話する <literal>messageSender</literal> という名前のコンポーネントがあるとします。"

#. Tag: programlisting
#: Concepts.xml:827
#, no-c-format
msgid ""
"<![CDATA[@Name(\"messageSender\") \n"
"public class MessageSender {\n"
"    public void sendMessage() {\n"
"        //do something with JMS\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"messageSender\") \n"
"public class MessageSender {\n"
"    public void sendMessage() {\n"
"        //do something with JMS\n"
"    }\n"
"}]]>"

#. Tag: para
#: Concepts.xml:829
#, no-c-format
msgid "In our unit tests, we don't have a JMS queue available, so we would like to stub out this method. We'll create a <emphasis>mock</emphasis> component that exists in the classpath when unit tests are running, but is never deployed with the application:"
msgstr "ユニットテストでは、 有効なJMS キューがないので、このメソッドをスタブにしてしまいたくなります。 ユニットテストが実行されるときにクラスパスに存在するけれどアプリケーションではデプロイされない <emphasis>mock</emphasis> コンポーネントを作成します。"

#. Tag: programlisting
#: Concepts.xml:836
#, no-c-format
msgid ""
"<![CDATA[@Name(\"messageSender\") \n"
"@Install(precedence=MOCK)\n"
"public class MockMessageSender extends MessageSender {\n"
"    public void sendMessage() {\n"
"        //do nothing!\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"messageSender\") \n"
"@Install(precedence=MOCK)\n"
"public class MockMessageSender extends MessageSender {\n"
"    public void sendMessage() {\n"
"        //do nothing!\n"
"    }\n"
"}]]>"

#. Tag: para
#: Concepts.xml:838
#, no-c-format
msgid "The <literal>precedence</literal> helps Seam decide which version to use when it finds both components in the classpath."
msgstr "<literal>優先順位</literal> はクラスパスで両方のコンポーネントを発見したとき、 Seam がどちらのバージョンを使用するかを助けます。"

#. Tag: para
#: Concepts.xml:843
#, no-c-format
msgid "This is nice if we are able to control exactly which classes are in the classpath. But if I'm writing a reusable framework with many dependecies, I don't want to have to break that framework across many jars. I want to be able to decide which components to install depending upon what other components are installed, and upon what classes are available in the classpath. The <literal>@Install</literal> annotation also controls this functionality. Seam uses this mechanism internally to enable conditional installation of many of the built-in components. However, you probably won't need to use it in your application."
msgstr "クラスパスにある複数のクラスを正確に制御できるならば、 これはすばらしいことです。 しかし、多くの依存性を持つ再利用可能なフレームワークを記述している場合、 多くの Jar 全体にそのフレームワークを分散させたいとは思わないでしょう。 他にどのようなコンポーネントがインストールされているか、クラスパス中にどんなクラスが使用可能であるかに応じて、 インストールすべきコンポーネントを決める方法の方が好まれるはずです。 <literal>@Install</literal> アノテーションはこの機能も制御しています。 Seam は多くの組み込みコンポーネントの条件付きインストールを実現するために内部でこのメカニズムを使用します。 しかし、アプリケーションでは恐らく使用する必要がないでしょう。"

#. Tag: title
#: Concepts.xml:857
#, no-c-format
msgid "Logging"
msgstr "ロギング"

#. Tag: para
#: Concepts.xml:859
#, no-c-format
msgid "Who is not totally fed up with seeing noisy code like this?"
msgstr "以下のようなうっとうしいコードを見るのに飽き飽きしていませんか。"

#. Tag: programlisting
#: Concepts.xml:863
#, no-c-format
msgid ""
"<![CDATA[private static final Log log = LogFactory.getLog(CreateOrderAction.class);\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    if ( log.isDebugEnabled() ) {\n"
"        log.debug(\"Creating new order for user: \" + user.username() + \n"
"            \" product: \" + product.name() \n"
"            + \" quantity: \" + quantity);\n"
"    }\n"
"    return new Order(user, product, quantity);\n"
"}]]>"
msgstr ""
"<![CDATA[private static final Log log = LogFactory.getLog(CreateOrderAction.class);\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    if ( log.isDebugEnabled() ) {\n"
"        log.debug(\"Creating new order for user: \" + user.username() + \n"
"            \" product: \" + product.name() \n"
"            + \" quantity: \" + quantity);\n"
"    }\n"
"    return new Order(user, product, quantity);\n"
"}]]>"

#. Tag: para
#: Concepts.xml:865
#, no-c-format
msgid "It is difficult to imagine how the code for a simple log message could possibly be more verbose. There is more lines of code tied up in logging than in the actual business logic! I remain totally astonished that the Java community has not come up with anything better in 10 years."
msgstr "簡単なログメッセージのためのコードをどうしてこんなに冗長にすることができるのか想像するのは困難です。 実際のビジネスロジックに関連するコード行よりロギングに関連する方がより多くあります。 Java コミュニティが 10 年の間もっと良いものを考え出せなかったことは本当に驚きです。"

#. Tag: para
#: Concepts.xml:871
#, no-c-format
msgid "Seam provides a logging API that simplifies this code significantly:"
msgstr "Seam はたくさんのコードを簡素化するロギング API を提供します。"

#. Tag: programlisting
#: Concepts.xml:875
#, no-c-format
msgid ""
"<![CDATA[@Logger private Log log;\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    log.debug(\"Creating new order for user: #0 product: #1 quantity: #2\", user.username(), product.name(), quantity);\n"
"    return new Order(user, product, quantity);\n"
"}]]>"
msgstr ""
"<![CDATA[@Logger private Log log;\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    log.debug(\"Creating new order for user: #0 product: #1 quantity: #2\", user.username(), product.name(), quantity);\n"
"    return new Order(user, product, quantity);\n"
"}]]>"

# 2.0 modified
#. Tag: para
#: Concepts.xml:877
#, no-c-format
msgid "It doesn't matter if you declare the <literal>log</literal> variable static or not&#8212;it will work either way, except for entity bean components which require the <literal>log</literal> variable to be static."
msgstr "<literal>log</literal> 変数が静的であると宣言するかどうかは問題ではありません — <literal>log</literal> 変数が静的である必要があるエンティティ Bean コンポーネント以外なら、 どちらの方法でもうまくいくでしょう。"

#. Tag: para
#: Concepts.xml:883
#, no-c-format
msgid "Note that we don't need the noisy <literal>if ( log.isDebugEnabled() )</literal> guard, since string concatenation happens <emphasis>inside</emphasis> the <literal>debug()</literal> method. Note also that we don't usually need to specify the log category explicitly, since Seam knows what component it is injecting the <literal>Log</literal> into."
msgstr "ストリング連結は、<literal>debug()</literal>  メソッドの <emphasis>内部</emphasis> で起こるため、 うっとうしい <literal>if ( log.isDebugEnabled() )</literal> による監視は不要であることに留意してください。 Seam はどのコンポーネントに <literal>Log</literal> をインジェクトしたかを知っているため、 通常、ログカテゴリを明示的に指定する必要ないことも留意してください。"

#. Tag: para
#: Concepts.xml:898
#, no-c-format
msgid "If <literal>User</literal> and <literal>Product</literal> are Seam components available in the current contexts, it gets even better:"
msgstr "<literal>User</literal> と <literal>Product</literal> が、 現在のコンテキストで有効な Seam コンポーネントの場合、それはさらに良くなります。"

#. Tag: programlisting
#: Concepts.xml:903
#, no-c-format
msgid ""
"<![CDATA[@Logger private Log log;\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    log.debug(\"Creating new order for user: #{user.username} product: #{product.name} quantity: #0\", quantity);\n"
"    return new Order(user, product, quantity);\n"
"}]]>"
msgstr ""
"<![CDATA[@Logger private Log log;\n"
"        \n"
"public Order createOrder(User user, Product product, int quantity) {\n"
"    log.debug(\"Creating new order for user: #{user.username} product: #{product.name} quantity: #0\", quantity);\n"
"    return new Order(user, product, quantity);\n"
"}]]>"

#. Tag: para
#: Concepts.xml:905
#, no-c-format
msgid "Seam logging automagically chooses whether to send output to log4j or JDK logging. If log4j is in the classpath, Seam with use it. If it is not, Seam will use JDK logging."
msgstr "Seam ロギングは自動的に log4j あるいは JDK logging に出力を送付するかを選択します。 log4j がクラスパスに通っていれば、Seam はそれを使用します。 そうでなければ、Seam は JDK logging を使用します。"

#. Tag: title
#: Concepts.xml:913
#, no-c-format
msgid "The <literal>Mutable</literal> interface and <literal>@ReadOnly</literal>"
msgstr "<literal>Mutable</literal> インタフェースと <literal>@ReadOnly</literal>"

#. Tag: para
#: Concepts.xml:914
#, no-c-format
msgid "Many application servers feature an amazingly broken implementation of <literal>HttpSession</literal> clustering, where changes to the state of mutable objects bound to the session are only replicated when the application calls <literal>setAttribute()</literal> explicitly. This is a source of bugs that can not effectively be tested for at development time, since they will only manifest when failover occurs. Furthermore, the actual replication message contains the entire serialized object graph bound to the session attribute, which is inefficient."
msgstr "アプリケーションが明示的に <literal>setAttribute()</literal> を呼び出すとときに、 セッションにバインドした可変オブジェクトの状態変化が複製されるだけなので、 多くのアプリケーションサーバーの機能は驚くほどいい加減な <literal>HttpSession</literal> クラスタリングの実装を持っています。 これはフェイルオーバが発生するときにだけに現れるので、 効果的に開発時にテストされることができないバグの原因です。 さらに実際の複製メッセージはセッション属性とバインドしたシリアライズされたオブジェクトグラフ全体を含んでいます。 そして、それは非効率です。"

#. Tag: para
#: Concepts.xml:923
#, no-c-format
msgid "Of course, EJB stateful session beans must perform automatic dirty checking and replication of mutable state and a sophisticated EJB container can introduce optimizations such as attribute-level replication. Unfortunately, not all Seam users have the good fortune to be working in an environment that supports EJB 3.0. So, for session and conversation scoped JavaBean and entity bean components, Seam provides an extra layer of cluster-safe state management over the top of the web container session clustering."
msgstr "もちろん、EJB ステートフルセッション Bean は自動的にダーティなチェックと可変状態の複製を実行するのが必要であり、 洗練された EJB コンテナは属性レベルの複製などの最適化を行うことが可能です。 あいにく、すべての Seam ユーザーが EJB 3.0 をサポートする恵まれた環境で作業をしているわけではありません。 そこで、セッションと対話スコープの JavaBean とエンティティ Bean コンポーネントのために、 Seam は Web コンテナセッションクラスタリングの上でクラスタセーフな状態管理の特別なレイヤを提供します。"

#. Tag: para
#: Concepts.xml:931
#, no-c-format
msgid "For session or conversation scoped JavaBean components, Seam automatically forces replication to occur by calling <literal>setAttribute()</literal> once in every request that the component was invoked by the application. Of course, this strategy is inefficient for read-mostly components. You can control this behavior by implementing the <literal>org.jboss.seam.core.Mutable</literal> interface, or by extending <literal>org.jboss.seam.core.AbstractMutable</literal>, and writing your own dirty-checking logic inside the component. For example,"
msgstr "セッションや対話スコープの JavaBean コンポーネントのために、Seam は、 コンポーネントがアプリケーションにより呼び出される要求の毎に、 <literal>setAttribute()</literal> を呼ぶことにより自動的に複製を命じます。 もちろん、このストラテジは読み取りばかりするコンポーネントでは不十分です。 この振る舞いは、 <literal>org.jboss.seam.core.Mutable</literal> インタフェースを実装するか、 <literal>org.jboss.seam.core.AbstractMutable</literal> を拡張するか、 あるいは、コンポーネント中に独自のダーティチェックのロジックを記述するかにより制御可能です。 以下に例を示します。"

#. Tag: programlisting
#: Concepts.xml:940
#, no-c-format
msgid ""
"<![CDATA[@Name(\"account\")\n"
"public class Account extends AbstractMutable\n"
"{\n"
"    private BigDecimal balance;\n"
"    \n"
"    public void setBalance(BigDecimal balance)\n"
"    {\n"
"        setDirty(this.balance, balance);\n"
"        this.balance = balance;\n"
"    }\n"
"    \n"
"    public BigDecimal getBalance()\n"
"    {\n"
"        return balance;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"account\")\n"
"public class Account extends AbstractMutable\n"
"{\n"
"    private BigDecimal balance;\n"
"    \n"
"    public void setBalance(BigDecimal balance)\n"
"    {\n"
"        setDirty(this.balance, balance);\n"
"        this.balance = balance;\n"
"    }\n"
"    \n"
"    public BigDecimal getBalance()\n"
"    {\n"
"        return balance;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"

#. Tag: para
#: Concepts.xml:942
#, no-c-format
msgid "Or, you can use the <literal>@ReadOnly</literal> annotation to achieve a similar effect:"
msgstr "あるいは、同様の効果を得るために <literal>@ReadOnly</literal> アノテーションの使用も可能です。"

#. Tag: programlisting
#: Concepts.xml:946
#, no-c-format
msgid ""
"<![CDATA[@Name(\"account\")\n"
"public class Account\n"
"{\n"
"    private BigDecimal balance;\n"
"    \n"
"    public void setBalance(BigDecimal balance)\n"
"    {\n"
"        this.balance = balance;\n"
"    }\n"
"    \n"
"    @ReadOnly\n"
"    public BigDecimal getBalance()\n"
"    {\n"
"        return balance;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"account\")\n"
"public class Account\n"
"{\n"
"    private BigDecimal balance;\n"
"    \n"
"    public void setBalance(BigDecimal balance)\n"
"    {\n"
"        this.balance = balance;\n"
"    }\n"
"    \n"
"    @ReadOnly\n"
"    public BigDecimal getBalance()\n"
"    {\n"
"        return balance;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"

#. Tag: para
#: Concepts.xml:948
#, no-c-format
msgid "For session or conversation scoped entity bean components, Seam automatically forces replication to occur by calling <literal>setAttribute()</literal> once in every request, <emphasis>unless the (conversation-scoped) entity is currently associated with a Seam-managed persistence context, in which case no replication is needed</emphasis>. This strategy is not necessarily efficient, so session or conversation scope entity beans should be used with care. You can always write a stateful session bean or JavaBean component to \"manage\" the entity bean instance. For example,"
msgstr "セッションや対話スコープのエンティティ Bean コンポーネントの場合、 Seam は <emphasis>(対話スコープの) エンティティが現在の Seam 管理の永続コンテキストに関連付けられていて、複製が不要ではない場合に限り</emphasis>、 要求毎に <literal>setAttribute()</literal> を呼ぶことにより自動的に複製の作成を強制します。 このストラテジは必ずしも効率的ではないので、 セッションや対話スコープエンティティ Bean は注意して使用してください。 エンティティ Bean インスタンスを「管理」するために、 ステートフルセッション Bean や JavaBean をいつでも記述することができます。 以下に例を示します。"

#. Tag: programlisting
#: Concepts.xml:957
#, no-c-format
msgid ""
"<![CDATA[@Stateful\n"
"@Name(\"account\")\n"
"public class AccountManager extends AbstractMutable\n"
"{\n"
"    private Account account; // an entity bean\n"
"    \n"
"    @Unwrap\n"
"    public Account getAccount()\n"
"    {\n"
"        return account;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"
msgstr ""
"<![CDATA[@Stateful\n"
"@Name(\"account\")\n"
"public class AccountManager extends AbstractMutable\n"
"{\n"
"    private Account account; // an entity bean\n"
"    \n"
"    @Unwrap\n"
"    public Account getAccount()\n"
"    {\n"
"        return account;\n"
"    }\n"
"    \n"
"    ...\n"
"    \n"
"}]]>"

#. Tag: para
#: Concepts.xml:959
#, no-c-format
msgid "Note that the <literal>EntityHome</literal> class in the Seam Application Framework provides a great example of managing an entity bean instance using a Seam component."
msgstr "Seam アプリケーションフレームワークにおいて <literal>EntityHome</literal> クラスは Seam コンポーネントを使用することでエンティティ Bean インスタンスを管理する優れたサンプルを提供していることに留意してください。 "

#. Tag: title
#: Concepts.xml:967
#, no-c-format
msgid "Factory and manager components"
msgstr "ファクトリと管理コンポーネント"

#. Tag: para
#: Concepts.xml:968
#, no-c-format
msgid "We often need to work with objects that are not Seam components. But we still want to be able to inject them into our components using <literal>@In</literal> and use them in value and method binding expressions, etc. Sometimes, we even need to tie them into the Seam context lifecycle (<literal>@Destroy</literal>, for example). So the Seam contexts can contain objects which are not Seam components, and Seam provides a couple of nice features that make it easier to work with non-component objects bound to contexts."
msgstr "Seam コンポーネントではないオブジェクトと連携することもしばしばあります。 しかし、やはり <literal>@In</literal> を使用して Seam コンポーネントにインジェクトし、 値やメソッドのバインディング式などでそれらを使いたいと思うことがあります。 時には、それを Seam コンテキストのライフサイクルに関連付ける必要さえあります (例えば <literal>@Destroy</literal>)。 そこで、Seam コンテキストは Seam コンポーネントではないオブジェクトを含むことが可能で、 Seam は、コンテキストにバインドする非コンポーネントと連携することを容易にする 2、3 の優れた機能を提供します。"

#. Tag: para
#: Concepts.xml:976
#, no-c-format
msgid "The <emphasis>factory component pattern</emphasis> lets a Seam component act as the instantiator for a non-component object. A <emphasis>factory method</emphasis> will be called when a context variable is referenced but has no value bound to it. We define factory methods using the <literal>@Factory</literal> annotation. The factory method binds a value to the context variable, and determines the scope of the bound value. There are two styles of factory method. The first style returns a value, which is bound to the context by Seam:"
msgstr "<emphasis>ファクトリコンポーネントパターン</emphasis> は、 Seam コンポーネントをコンポーネントではないオブジェクトのインスタンス化する機能として動作させます。 <emphasis>ファクトリメソッド</emphasis> は、 コンテキスト変数が参照されたときに呼び出されますが、 それとバインドした値は持っていません。 <literal>@Factory</literal> アノテーションを使用してファクトリメソッドを定義します。 ファクトリメソッドは値をコンテキスト変数とバインドし、 バインドされた値のスコープを決定します。 二種類のファクトリメソッドスタイルがあります。 最初のスタイルは、Seam によりコンテキストにバインドされた値を返します。"

#. Tag: programlisting
#: Concepts.xml:985
#, no-c-format
msgid ""
"<![CDATA[@Factory(scope=CONVERSATION)\n"
"public List<Customer> getCustomerList() { \n"
"    return ... ;\n"
"} ]]>"
msgstr ""
"<![CDATA[@Factory(scope=CONVERSATION)\n"
"public List<Customer> getCustomerList() { \n"
"    return ... ;\n"
"} ]]>"

#. Tag: para
#: Concepts.xml:987
#, no-c-format
msgid "The second style is a method of type <literal>void</literal> which binds the value to the context variable itself:"
msgstr "二番目のスタイルは、 値をコンテキスト変数そのものにバインドした <literal>void</literal> タイプのメソッドです。"

#. Tag: programlisting
#: Concepts.xml:992
#, no-c-format
msgid ""
"<![CDATA[@DataModel List<Customer> customerList;\n"
"\n"
"@Factory(\"customerList\")\n"
"public void initCustomerList() { \n"
"    customerList = ...  ;\n"
"} ]]>"
msgstr ""
"<![CDATA[@DataModel List<Customer> customerList;\n"
"\n"
"@Factory(\"customerList\")\n"
"public void initCustomerList() { \n"
"    customerList = ...  ;\n"
"} ]]>"

#. Tag: para
#: Concepts.xml:994
#, no-c-format
msgid "In both cases, the factory method is called when we reference the <literal>customerList</literal> context variable and its value is null, and then has no further part to play in the lifecycle of the value. An even more powerful pattern is the <emphasis>manager component pattern</emphasis>. In this case, we have a Seam component that is bound to a context variable, that manages the value of the context variable, while remaining invisible to clients."
msgstr "どちらの場合も、 <literal>customerList</literal> コンテキスト変数を参照してその値が null になり、 その値のライフサイクルで行うことがこれ以上ない場合、 ファクトリメソッドが呼ばれます。 さらに強力なパターンは <emphasis>管理コンポーネントパターン</emphasis> です。 この場合、 コンテキスト変数にバインドする Seam コンポーネントがあり、 このコンポーネントがコンテキスト変数の値を管理し、 残りはクライアントで見えない場合です。"

#. Tag: para
#: Concepts.xml:1002
#, no-c-format
msgid "A manager component is any component with an <literal>@Unwrap</literal> method. This method returns the value that will be visable to clients, and is called <emphasis>every time</emphasis> a context variable is referenced."
msgstr "管理コンポーネントは <literal>@Unwrap</literal> メソッドを持つすべてのコンポーネントです。 このメソッドは、クライアントに見えなくなる値を返し、 <emphasis>毎回</emphasis> コンテキスト変数が参照されれば呼び出されます。"

#. Tag: programlisting
#: Concepts.xml:1010
#, no-c-format
msgid ""
"<![CDATA[@Name(\"customerList\")\n"
"@Scope(CONVERSATION)\n"
"public class CustomerListManager\n"
"{\n"
"    ...\n"
"    \n"
"    @Unwrap\n"
"    public List<Customer> getCustomerList() { \n"
"        return ... ;\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"customerList\")\n"
"@Scope(CONVERSATION)\n"
"public class CustomerListManager\n"
"{\n"
"    ...\n"
"    \n"
"    @Unwrap\n"
"    public List<Customer> getCustomerList() { \n"
"        return ... ;\n"
"    }\n"
"}]]>"

#. Tag: para
#: Concepts.xml:1012
#, no-c-format
msgid "The manager component pattern is especially useful if we have an object where you need more control over the lifecycle of the component. For example, if you have a heavyweight object that needs a cleanup operation when the context ends you could <literal>@Unwrap</literal> the object, and perform cleanup in the <literal>@Destroy</literal> method of the manager component."
msgstr "マネージャコンポーネントパターンはコンポーネントのライフサイクルでより制御を必要とする場面でオブジェクトがあるとき特に有用です。 例えば、コンテキスト終了時にクリーンアップを必要とする重量級のオブジェクトがあるとき、オブジェクトを <literal>@Unwrap</literal> し、マネージャコンポーネントの <literal>@Destroy</literal> メソッドでクリーンアップすることが可能です。"

#. Tag: programlisting
#: Concepts.xml:1019
#, no-c-format
msgid ""
"<![CDATA[@Name(\"hens\")\n"
"@Scope(APPLICATION) \n"
"public class HenHouse {\n"
"    \n"
"    Set<Hen> hens;\n"
"    \n"
"    @In(required=false) Hen hen;\n"
"    \n"
"    @Unwrap\n"
"    public List<Hen> getHens() {\n"
"        if (hens == null) {\n"
"            // Setup our hens\n"
"        }\n"
"        return hens;\n"
"    }\n"
"    \n"
"    @Observer({\"chickBorn\", \"chickenBoughtAtMarket\"})\n"
"    public addHen() {\n"
"        hens.add(hen);\n"
"    }\n"
"    \n"
"    @Observer(\"chickenSoldAtMarket\")\n"
"    public removeHen() {\n"
"        hens.remove(hen);\n"
"    }\n"
"    \n"
"    @Observer(\"foxGetsIn\")\n"
"    public removeAllHens() {\n"
"        hens.clear();\n"
"    }\n"
"    ...\n"
"}]]>"
msgstr ""
"<![CDATA[@Name(\"hens\")\n"
"@Scope(APPLICATION) \n"
"public class HenHouse {\n"
"    \n"
"    Set<Hen> hens;\n"
"    \n"
"    @In(required=false) Hen hen;\n"
"    \n"
"    @Unwrap\n"
"    public List<Hen> getHens() {\n"
"        if (hens == null) {\n"
"            // Setup our hens\n"
"        }\n"
"        return hens;\n"
"    }\n"
"    \n"
"    @Observer({\"chickBorn\", \"chickenBoughtAtMarket\"})\n"
"    public addHen() {\n"
"        hens.add(hen);\n"
"    }\n"
"    \n"
"    @Observer(\"chickenSoldAtMarket\")\n"
"    public removeHen() {\n"
"        hens.remove(hen);\n"
"    }\n"
"    \n"
"    @Observer(\"foxGetsIn\")\n"
"    public removeAllHens() {\n"
"        hens.clear();\n"
"    }\n"
"    ...\n"
"}]]>"

#. Tag: para
#: Concepts.xml:1021
#, no-c-format
msgid "Here the managed component observes many events which change the underlying object. The component manages these actions itself, and because the object is unwrapped on every access, a consistent view is provided."
msgstr "ここでは管理コンポーネントが基礎をなすオブジェクトの多くのイベント監視をしています。 コンポーネントはこれらのアクションそのものを管理し、オブジェクトはアクセスごとにアンラップされるために一貫性のあるビューが提供されます。"

