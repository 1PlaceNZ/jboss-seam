<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>Chapter 19. Caching</title>
      <link rel="stylesheet" href="css/jbossorg.css" type="text/css"/>
      <meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/>
      <link rel="start" href="index.html" title="Seam - Contextual Components"/>
      <link rel="up" href="index.html" title="Seam - Contextual Components"/>
      <link rel="prev" href="ch18s02s04.html" title="18.2.4. Receiving messages in the client"/>
      <link rel="next" href="ch19s01.html" title="19.1. Using JBossCache in Seam"/>
   </head>
   <body>
      <p id="title">
         <a href="http://www.jboss.org" class="jbossOrg_href">
            <strong>
						        JBoss.org	
						</strong>
         </a>
         <a href="http://labs.jboss.com/projects/docs" class="commDoc_href">
            <strong>
						        Community Documentation	
						</strong>
         </a>
      </p>
      <ul class="docnav">
         <li class="previous">
            <a accesskey="p" href="ch18s02s04.html">
               <strong>Prev</strong>
            </a>
         </li>
         <li class="next">
            <a accesskey="n" href="ch19s01.html">
               <strong>Next</strong>
            </a>
         </li>
      </ul>
      <div class="chapter" lang="en">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title">
                     <a id="cache"/>Chapter 19. Caching</h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <dl>
               <dt>
                  <span class="section">
                     <a href="ch19s01.html">19.1. Using JBossCache in Seam</a>
                  </span>
               </dt>
               <dt>
                  <span class="section">
                     <a href="ch19s02.html">19.2. Page fragment caching</a>
                  </span>
               </dt>
            </dl>
         </div>
         <p>
        In almost all enterprise applications, the database is the primary 
        bottleneck, and the least scalable tier of the runtime environment. 
        People from a PHP/Ruby environment will try to tell you that so-called
        "shared nothing" architectures scale well. While that may be literally
        true, I don't know of many interesting multi-user applications which 
        can be implemented with no sharing of resources between different 
        nodes of the cluster. What these silly people are really thinking of 
        is a "share nothing except for the database" architecture. Of course, 
        sharing the database is the primary problem with scaling a multi-user 
        application—so the claim that this architecture is highly scalable 
        is absurd, and tells you a lot about the kind of applications that these
        folks spend most of their time working on. 
    </p>
         <p>
        Almost anything we can possibly do to share the database <span class="emphasis">
               <em>less 
        often</em>
            </span> is worth doing.
    </p>
         <p>
        This calls for a cache. Well, not just one cache. A well designed Seam
        application will feature a rich, multi-layered caching strategy that
        impacts every layer of the application:
    </p>
         <div class="itemizedlist">
            <ul>
               <li>
                  <p>
                The database, of course, has its own cache. This is 
                super-important, but can't scale like a cache in the
                application tier.
            </p>
               </li>
               <li>
                  <p>
                Your ORM solution (Hibernate, or some other JPA implementation)
                has a second-level cache of data from the database. This is
                a very powerful capability, but is often misused. In a clustered
                environment, keeping the data in the cache transactionally
                consistent across the whole cluster, and with the database,
                is quite expensive. It makes most sense for data which is shared
                between many users, and is updated rarely. In traditional 
                stateless architectures, people often try to use the second-level
                cache for conversational state. This is always bad, and is
                especially wrong in Seam.
            </p>
               </li>
               <li>
                  <p>
                The Seam conversation context is a cache of conversational state.
                Components you put into the conversation context can hold and cache
                state relating to the current user interaction.
            </p>
               </li>
               <li>
                  <p>
                In particular, the
                Seam-managed persistence context (or an extended EJB container-managed
                persistence context associated with a conversation-scoped stateful
                session bean) acts as a cache of data that has been read in the
                current conversation. This cache tends to have a pretty high
                hitrate! Seam optimizes the replication of Seam-managed persistence 
                contexts in a clustered environment, and there is no requirement for 
                transactional consistency with the database (optimistic locking is 
                sufficient) so you don't need to worry too much about the performance 
                implications of this cache, unless you read thousands of objects into
                a single persistence context.
            </p>
               </li>
               <li>
                  <p>
                The application can cache non-transactional state in the Seam
                application context. State kept in the application context is
                of course not visible to other nodes in the cluster.
            </p>
               </li>
               <li>
                  <p>
                The application can cache transactional state using the Seam
                <code class="literal">pojoCache</code> component, which integrates
                JBossCache into the Seam environment. This state will be visible
                to other nodes if you run JBoss cache in a clustered mode.
            </p>
               </li>
               <li>
                  <p>
                Finally, Seam lets you cache rendered fragments of a JSF page. Unlike  
                the ORM second-level cache, this cache is not automatically invalidated 
                when data changes, so you need to write application code to perform
                explicit invalidation, or set appropriate expiration policies.
            </p>
               </li>
            </ul>
         </div>
         <p>
        For more information about the second-level cache, you'll need to refer to
        the documentation of your ORM solution, since this is an extremely complex
        topic. In this section we'll discuss the use of JBossCache directly, via
        the <code class="literal">pojoCache</code> component, or as the page fragment cache,
        via the <code class="literal">&lt;s:cache&gt;</code> control.
    </p>
      </div>
      <ul class="docnav">
         <li class="previous">
            <a accesskey="p" href="ch18s02s04.html">
               <strong>Prev</strong>18.2.4. Receiving messages in the client</a>
         </li>
         <li class="up">
            <a accesskey="u" href="#">
               <strong>Top of page</strong>
            </a>
         </li>
         <li class="home">
            <a accesskey="h" href="index.html">
               <strong>Front page</strong>
            </a>
         </li>
         <li class="next">
            <a accesskey="n" href="ch19s01.html">
               <strong>Next</strong>19.1. Using JBossCache in Seam</a>
         </li>
      </ul>
   </body>
</html>