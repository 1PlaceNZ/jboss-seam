<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <title>3.1.10. Concurrency model</title>
      <link rel="stylesheet" href="css/jbossorg.css" type="text/css"/>
      <meta name="generator" content="DocBook XSL Stylesheets V1.72.0"/>
      <link rel="start" href="index.html" title="Seam - Contextual Components"/>
      <link rel="up" href="ch03s01.html" title="3.1. Seam contexts"/>
      <link rel="prev" href="ch03s01s09.html" title="3.1.9. Context search priority"/>
      <link rel="next" href="ch03s02.html" title="3.2. Seam components"/>
   </head>
   <body>
      <p id="title">
         <a href="http://www.jboss.org" class="jbossOrg_href">
            <strong>
						        JBoss.org	
						</strong>
         </a>
         <a href="http://labs.jboss.com/projects/docs" class="commDoc_href">
            <strong>
						        Community Documentation	
						</strong>
         </a>
      </p>
      <ul class="docnav">
         <li class="previous">
            <a accesskey="p" href="ch03s01s09.html">
               <strong>Prev</strong>
            </a>
         </li>
         <li class="next">
            <a accesskey="n" href="ch03s02.html">
               <strong>Next</strong>
            </a>
         </li>
      </ul>
      <div class="sect2" lang="en">
         <div class="titlepage">
            <div>
               <div>
                  <h3 class="title">
                     <a id="concurrency"/>3.1.10. Concurrency model</h3>
               </div>
            </div>
         </div>
         <p> 
                Neither the servlet nor EJB specifications define any facilities for managing concurrent requests
                originating from the same client. The servlet container simply lets all threads run concurrently and
                leaves enforcing threadsafeness to application code. The EJB container allows stateless components to be
                accessed concurrently, and throws an exception if multiple threads access a stateful session bean. 
            </p>
         <p> 
                This behavior might have been okay in old-style web applications which were based around
                fine-grained, synchronous requests. But for modern applications which make heavy use of many
                fine-grained, asynchronous (AJAX) requests, concurrency is a fact of life, and must be supported by the
                programming model. Seam weaves a concurrency management layer into its context model. 
            </p>
         <p> 
                The Seam session and application contexts are multithreaded. Seam will allow concurrent requests in a
                context to be processed concurrently. The event and page contexts are by nature single threaded. The
                business process context is strictly speaking multi-threaded, but in practice concurrency is
                sufficiently rare that this fact may be disregarded most of the time. Finally, Seam enforces a
                <span class="emphasis">
               <em>single thread per conversation per process</em>
            </span> model for the conversation context
                by serializing concurrent requests in the same long-running conversation context. 
            </p>
         <p> 
                Since the session context is multithreaded, and often contains volatile state, session scope
                components are always protected by Seam from concurrent access. Seam serializes requests to session
                scope session beans and JavaBeans by default (and detects and breaks any deadlocks that occur). This is
                not the default behaviour for application scoped components however, since application scoped components
                do not usually hold volatile state and because synchronization at the global level is
                <span class="emphasis">
               <em>extremely</em>
            </span> expensive. However, you can force a serialized threading model on any
                session bean or JavaBean component by adding the <code class="literal">@Synchronized</code> annotation. 
            </p>
         <p> 
                This concurrency model means that AJAX clients can safely use volatile session and conversational
                state, without the need for any special work on the part of the developer.
            </p>
      </div>
      <ul class="docnav">
         <li class="previous">
            <a accesskey="p" href="ch03s01s09.html">
               <strong>Prev</strong>3.1.9. Context search priority</a>
         </li>
         <li class="up">
            <a accesskey="u" href="#">
               <strong>Top of page</strong>
            </a>
         </li>
         <li class="home">
            <a accesskey="h" href="index.html">
               <strong>Front page</strong>
            </a>
         </li>
         <li class="next">
            <a accesskey="n" href="ch03s02.html">
               <strong>Next</strong>3.2. Seam components</a>
         </li>
      </ul>
   </body>
</html>