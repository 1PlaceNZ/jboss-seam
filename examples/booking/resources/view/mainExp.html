<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<title>In-depth Explanation</title>
	<link href="css/trailblazer_main.css" rel="stylesheet" type="text/css" />
</head>

<body>

<div id="main">
  <div class="trail">
    <div class="numbox">4</div>
    <h2>Stateful conversations</h2>
    <img src="img/header_line.gif" />
    
    <p><center><form><INPUT type="button" value="Close Window" onClick="window.close()"></form></center></p>

<p>The hotel search form uses the <code>#{hotelBooking}</code> bean, which is mapped from the <code>HotelBookingAction</code> session bean via the Seam <code>@Name</code> annotation.</p>

<code class="block">
&lt;h:inputText value="#{hotelBooking.searchString}" />
&lt;h:commandButton value="Find Hotels" 
                 action="#{hotelBooking.find}" 
                 styleClass="button" />
</code>

<p>Now, let's look into the relevant parts of the <code>HotelBookingAction</code> class. First, we note that it is a stateful bean since its state (e.g., the hotels found) is used in multiple pages. Second, it uses the <code>@LoggedIn</code> annotation to indicate that the user must be logged in to use this bean.</p>

<code class="block">
@Stateful
@Name("hotelBooking")
@Interceptor(SeamInterceptor.class)
@Conversational(ifNotBegunOutcome="main")
@LoggedIn
public class HotelBookingAction implements HotelBooking, Serializable {

   @PersistenceContext(type=EXTENDED)
   private EntityManager em;
   
   private String searchString;
  
   @DataModel
   private List &lt;Hotel> hotels;
   @DataModelSelectionIndex
   private int hotelIndex;
   
   @Out(required=false)
   private Hotel hotel;
   
   // ... ...
   
   @Begin
   public String find() {
      hotel = null;
      String searchPattern = 
        searchString==null ? "%" : '%' + 
        searchString.toLowerCase().replace('*', '%') + '%';
      
      hotels = em.createQuery(
        "from Hotel where lower(name) like :search " + 
        "or lower(city) like :search or lower(zip) like :search " + 
        "or lower(address) like :search")
            .setParameter("search", searchPattern)
            .setMaxResults(50)
            .getResultList();
      
      return "main";
   }
   
   public String getSearchString() {
      return searchString;
   }

   public void setSearchString(String searchString) {
      this.searchString = searchString;
   }
   
    // ... ...
}
</code>

<p>What you see here is that the <code>HotelBookingAction.find()</code> method takes the <code>searchString</code> property collected from the form and find a list of hotels in the database. The <code>EntityManager</code> in this class must have <code>EXTENDED</code> scope since it needs to manage entity objects across multiple threads (i.e., multiple page requests to the bean methods). This is generally true for <code>EntityManager</code> objects in all stateful session  beans. Now, let's look at how the conversation is constructed.</p>

<p>The Seam <code>@Conversational</code> annotation declares this as a conversational component that cannot be invoked outside of a long-running conversation that was started by a call to its <code>@Begin</code> method. If such an invocation does occur, Seam returns the <code>ifNotBegunOutcome</code> to JSF. The <code>@Begin</code> annotation specifies that the annotated method begins a long-running conversation, so the current conversation context will not be destroyed at the end of the request. Instead, it will be reassociated with every request from the current window, and destroyed either by timeout due to conversation inactivity or invocation of a matching <code>@End</code> method, which happens after you finished the booking.</p>

<p>After the <code>find()</code> method finds the hotels from the database, it populates them into a <code>List</code> object <code>hotels</code>. The <code>hotels</code> property is marked with the <code>@DataModel</code> annotation, which tells SEAM to convert it to a JSF <code>ListDataModel</code>. This makes it easy to implement clickable lists for search screens. The <code>@DataModelSelectionIndex</code> annotation defines a field or get/set pair as holding the row index for the corresponding <code>@DataModel</code> property. Therefore, in the <code>main.xhtml</code> page, it is trivial to display the hotel search results with no JSF display data conversion needed.</p>

<code class="block">
&lt;div class="section">
	&lt;h:outputText value="No Hotels Found" 
	              rendered="#{hotels != null and empty hotels}"/>
	&lt;h:dataTable value="#{hotels}" var="hot" 
	              rendered="#{not empty hotels}">
		&lt;h:column>
			&lt;f:facet name="header">Name&lt;/f:facet>
			#{hot.name}
		&lt;/h:column>
		&lt;h:column>
			&lt;f:facet name="header">Address&lt;/f:facet>
			#{hot.address}
		&lt;/h:column>
		&lt;h:column>
			&lt;f:facet name="header">City, State&lt;/f:facet>
			#{hot.city}, #{hot.state}
		&lt;/h:column>
		&lt;h:column>
			&lt;f:facet name="header">Zip&lt;/f:facet>
			#{hot.zip}
		&lt;/h:column>
		&lt;h:column>
			&lt;f:facet name="header">Action&lt;/f:facet>
			&lt;h:commandLink action="#{hotelBooking.selectHotel}">View Hotel&lt;/h:commandLink>
		&lt;/h:column>
	&lt;/h:dataTable>
&lt;/div>
</code>

<p>The "View Hotel" action method, <code>HotelBookingAction.selectHotel()</code>, does not have any annotation. It is just a method inside the conversation started by <code>find()</code>. It selects the hotel and pushes JSF to the next page.

<code class="block">
@Stateful
@Name("hotelBooking")
@Interceptor(SeamInterceptor.class)
@Conversational(ifNotBegunOutcome="main")
@LoggedIn
public class HotelBookingAction implements HotelBooking, Serializable {

   public String selectHotel() {
      if ( hotels==null ) return "main";
      setHotel();
      return "selected";
   }
   
   private void setHotel() {
      hotel = hotels.get(hotelIndex);
   }
   
   // ... ...
}
</code>

<p><center><form><INPUT type="button" value="Close Window" onClick="window.close()"></form></center></p>

  </div>
</div>

</body>
</html>
